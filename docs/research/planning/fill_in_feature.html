<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fill It In Feature - Nabokov Web Clipper</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #e0e0e0;
        }
        h1, h2, h3 { color: #ffd700; border-left: 4px solid #dc143c; padding-left: 1rem; }
        .hero {
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 100%);
            padding: 2rem;
            border-radius: 12px;
            margin: 2rem 0;
            box-shadow: 0 8px 32px rgba(220, 20, 60, 0.3);
        }
        .hero h2 { border: none; color: #ffd700; }
        .workflow {
            background: #2a2a2a;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #4a90e2;
        }
        .code-block {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        .visual-demo {
            background: #1a1a1a;
            border: 2px dashed #4a90e2;
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
            font-family: monospace;
            white-space: pre;
            line-height: 1.8;
        }
        .feature-box {
            background: linear-gradient(135deg, #2a4858 0%, #3a5868 100%);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #ffd700;
        }
        .implementation-step {
            background: #2a2a2a;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
            border-left: 3px solid #dc143c;
        }
        .note {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        code {
            background: #1a1a1a;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            color: #4a90e2;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        ul, ol { padding-left: 2rem; }
        li { margin: 0.5rem 0; }
        .advantage { color: #90EE90; }
        .challenge { color: #FFB6C1; }
    </style>
</head>
<body>
    <h1>ğŸ”—âœ¨ Fill It In Feature</h1>

    <div class="hero">
        <h2>ğŸ¯ Develop Ideas Through Connection-Based Synthesis</h2>
        <p><strong>Concept:</strong> Create a sparse note with a basic idea, connect it to relevant existing notes, then use AI to synthesize and integrate information from connected notes to fully develop the new note.</p>
        <p><strong>Why It's Powerful:</strong> Transforms Nabokov from a passive storage system into an active thinking partner that helps you elaborate ideas by intelligently combining knowledge from your existing notes.</p>
    </div>

    <h2>ğŸ“‹ User Workflow</h2>

    <div class="visual-demo">
<span style="color: #ffd700;">Step 1: Create sparse note</span>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¡ "Neural networks    â”‚  <-- User creates basic note (Cmd+N)
â”‚  for time series"      â”‚      with just a title or brief idea
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span style="color: #ffd700;">Step 2: Connect to relevant notes</span>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ RNN basics   â”‚
        â”‚ (from paper) â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¡ Neural networks        â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”‚ LSTM gates   â”‚
â”‚  for time series          â”‚         â”‚ (clipped)    â”‚
â”‚                           â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ [Empty - needs filling]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†‘
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Forecasting  â”‚
        â”‚ techniques   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span style="color: #ffd700;">Step 3: Trigger "Fill it in"</span>
User right-clicks â†’ "Fill in from connections"
OR clicks "ğŸ”— Fill In" button in card header

<span style="color: #ffd700;">Step 4: AI synthesizes content</span>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¡ Neural networks for time series â”‚
â”‚                                    â”‚
â”‚ <span style="color: #90EE90;">[Generated content]</span>              â”‚
â”‚ Neural networks are particularly   â”‚
â”‚ well-suited for time series due to â”‚
â”‚ their ability to capture temporal  â”‚
â”‚ dependencies. RNNs process         â”‚
â”‚ sequential data by maintaining     â”‚
â”‚ hidden states... LSTMs extend this â”‚
â”‚ with gating mechanisms (forget,    â”‚
â”‚ input, output gates) that help     â”‚
â”‚ preserve long-range dependencies...â”‚
â”‚                                    â”‚
â”‚ For forecasting applications,      â”‚
â”‚ encoder-decoder architectures...   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    </div>

    <div class="workflow">
        <h3>Detailed Workflow</h3>
        <ol>
            <li><strong>Create Note:</strong> User creates a new note card with a title or brief idea</li>
            <li><strong>Establish Connections:</strong> User draws arrows to connect to 3-5 relevant existing cards</li>
            <li><strong>Trigger Fill-In:</strong> User activates the feature via:
                <ul>
                    <li>Right-click context menu â†’ "Fill in from connections"</li>
                    <li>Button in card header (shows count: "ğŸ”— Fill In (4 cards)")</li>
                    <li>Keyboard shortcut: <code>Cmd+Shift+F</code></li>
                </ul>
            </li>
            <li><strong>Preview Mode:</strong> Modal shows:
                <ul>
                    <li>List of connected cards that will contribute</li>
                    <li>Fill-in strategy options (replace, append, merge)</li>
                    <li>Tone/style controls (academic, creative, concise)</li>
                </ul>
            </li>
            <li><strong>Generation:</strong> System streams AI response into card content</li>
            <li><strong>Review & Edit:</strong> User can edit, accept, or regenerate</li>
            <li><strong>Iterate:</strong> User can connect more cards and fill in again to further develop</li>
        </ol>
    </div>

    <h2>ğŸ—ï¸ Technical Implementation</h2>

    <div class="implementation-step">
        <h3>Step 1: Data Model Extensions</h3>
        <p>Extend Card interface to track fill-in metadata:</p>
        <div class="code-block">
<span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">Card</span> {
  <span style="color: #9cdcfe;">id</span>: <span style="color: #4ec9b0;">string</span>;
  <span style="color: #9cdcfe;">content</span>: <span style="color: #4ec9b0;">string</span>;
  <span style="color: #6a9955;">// ... existing fields</span>

  <span style="color: #6a9955;">// New: Track fill-in history</span>
  <span style="color: #9cdcfe;">fillInHistory</span>?: {
    <span style="color: #9cdcfe;">timestamp</span>: <span style="color: #4ec9b0;">number</span>;
    <span style="color: #9cdcfe;">sourceCardIds</span>: <span style="color: #4ec9b0;">string</span>[];      <span style="color: #6a9955;">// Which cards contributed</span>
    <span style="color: #9cdcfe;">strategy</span>: <span style="color: #ce9178;">'replace'</span> | <span style="color: #ce9178;">'append'</span> | <span style="color: #ce9178;">'merge'</span>;
    <span style="color: #9cdcfe;">userPrompt</span>?: <span style="color: #4ec9b0;">string</span>;         <span style="color: #6a9955;">// Optional user guidance</span>
    <span style="color: #9cdcfe;">previousContent</span>?: <span style="color: #4ec9b0;">string</span>;     <span style="color: #6a9955;">// For undo</span>
  }[];
}

<span style="color: #6a9955;">// Connection interface (already exists)</span>
<span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">CardConnection</span> {
  <span style="color: #9cdcfe;">id</span>: <span style="color: #4ec9b0;">string</span>;
  <span style="color: #9cdcfe;">source</span>: <span style="color: #4ec9b0;">string</span>;      <span style="color: #6a9955;">// Card ID</span>
  <span style="color: #9cdcfe;">target</span>: <span style="color: #4ec9b0;">string</span>;      <span style="color: #6a9955;">// Card ID</span>
  <span style="color: #9cdcfe;">createdAt</span>: <span style="color: #4ec9b0;">number</span>;
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 2: Connection Context Service</h3>
        <p>Create <code>src/services/connectionContextService.ts</code> to gather connected cards:</p>
        <div class="code-block">
<span style="color: #c586c0;">import</span> { Card, CardConnection } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/types/card'</span>;
<span style="color: #c586c0;">import</span> { getConnections } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/utils/connectionStorage'</span>;

<span style="color: #6a9955;">/**
 * Get all cards connected to the target card
 * @param cardId - The card to find connections for
 * @param allCards - All available cards
 * @param direction - Include incoming, outgoing, or both connections
 */</span>
<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">async</span> <span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">getConnectedCards</span>(
  <span style="color: #9cdcfe;">cardId</span>: <span style="color: #4ec9b0;">string</span>,
  <span style="color: #9cdcfe;">allCards</span>: <span style="color: #4ec9b0;">Card</span>[],
  <span style="color: #9cdcfe;">direction</span>: <span style="color: #ce9178;">'incoming'</span> | <span style="color: #ce9178;">'outgoing'</span> | <span style="color: #ce9178;">'both'</span> = <span style="color: #ce9178;">'both'</span>
): <span style="color: #4ec9b0;">Promise</span>&lt;<span style="color: #4ec9b0;">Card</span>[]&gt; {
  <span style="color: #569cd6;">const</span> connections = <span style="color: #569cd6;">await</span> <span style="color: #dcdcaa;">getConnections</span>();

  <span style="color: #569cd6;">const</span> connectedIds = <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Set</span>&lt;<span style="color: #4ec9b0;">string</span>&gt;();

  connections.<span style="color: #dcdcaa;">forEach</span>(<span style="color: #9cdcfe;">conn</span> <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #c586c0;">if</span> (direction === <span style="color: #ce9178;">'outgoing'</span> || direction === <span style="color: #ce9178;">'both'</span>) {
      <span style="color: #c586c0;">if</span> (conn.source === cardId) connectedIds.<span style="color: #dcdcaa;">add</span>(conn.target);
    }
    <span style="color: #c586c0;">if</span> (direction === <span style="color: #ce9178;">'incoming'</span> || direction === <span style="color: #ce9178;">'both'</span>) {
      <span style="color: #c586c0;">if</span> (conn.target === cardId) connectedIds.<span style="color: #dcdcaa;">add</span>(conn.source);
    }
  });

  <span style="color: #c586c0;">return</span> allCards.<span style="color: #dcdcaa;">filter</span>(<span style="color: #9cdcfe;">card</span> <span style="color: #569cd6;">=&gt;</span> connectedIds.<span style="color: #dcdcaa;">has</span>(card.id));
}

<span style="color: #6a9955;">/**
 * Merge contexts from multiple connected cards
 */</span>
<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">buildFillInContext</span>(<span style="color: #9cdcfe;">connectedCards</span>: <span style="color: #4ec9b0;">Card</span>[]): <span style="color: #4ec9b0;">string</span> {
  <span style="color: #c586c0;">return</span> connectedCards
    .<span style="color: #dcdcaa;">map</span>((<span style="color: #9cdcfe;">card</span>, <span style="color: #9cdcfe;">index</span>) <span style="color: #569cd6;">=&gt;</span> {
      <span style="color: #569cd6;">const</span> header = [
        <span style="color: #ce9178;">`[Connected Card </span><span style="color: #569cd6;">${</span>index + <span style="color: #b5cea8;">1</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">: </span><span style="color: #569cd6;">${</span>card.metadata.title<span style="color: #569cd6;">}</span><span style="color: #ce9178;">]`</span>,
        <span style="color: #ce9178;">`Source: </span><span style="color: #569cd6;">${</span>card.metadata.url<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>,
        <span style="color: #ce9178;">`Type: </span><span style="color: #569cd6;">${</span>card.cardType || <span style="color: #ce9178;">'clipped'</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>,
      ].<span style="color: #dcdcaa;">join</span>(<span style="color: #ce9178;">'\n'</span>);

      <span style="color: #569cd6;">const</span> content = card.content || <span style="color: #ce9178;">'[No content]'</span>;

      <span style="color: #c586c0;">return</span> <span style="color: #ce9178;">`</span><span style="color: #569cd6;">${</span>header<span style="color: #569cd6;">}</span><span style="color: #ce9178;">\n\n</span><span style="color: #569cd6;">${</span>content<span style="color: #569cd6;">}</span><span style="color: #ce9178;">\n\n---`</span>;
    })
    .<span style="color: #dcdcaa;">join</span>(<span style="color: #ce9178;">'\n\n'</span>);
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 3: Fill-In Service</h3>
        <p>Create <code>src/services/fillInService.ts</code> with AI integration:</p>
        <div class="code-block">
<span style="color: #c586c0;">import</span> { Card } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/types/card'</span>;
<span style="color: #c586c0;">import</span> { getConnectedCards, buildFillInContext } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'./connectionContextService'</span>;
<span style="color: #c586c0;">import</span> { mockClaudeAPI } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'./chatService'</span>;

<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">type</span> <span style="color: #4ec9b0;">FillInStrategy</span> = <span style="color: #ce9178;">'replace'</span> | <span style="color: #ce9178;">'append'</span> | <span style="color: #ce9178;">'merge'</span>;

<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">FillInOptions</span> {
  <span style="color: #9cdcfe;">strategy</span>: <span style="color: #4ec9b0;">FillInStrategy</span>;
  <span style="color: #9cdcfe;">userPrompt</span>?: <span style="color: #4ec9b0;">string</span>;         <span style="color: #6a9955;">// Optional guidance</span>
  <span style="color: #9cdcfe;">tone</span>?: <span style="color: #ce9178;">'academic'</span> | <span style="color: #ce9178;">'creative'</span> | <span style="color: #ce9178;">'concise'</span>;
}

<span style="color: #6a9955;">/**
 * Generate content for a card based on its connections
 */</span>
<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">async</span> <span style="color: #569cd6;">function</span>* <span style="color: #dcdcaa;">fillInFromConnections</span>(
  <span style="color: #9cdcfe;">targetCard</span>: <span style="color: #4ec9b0;">Card</span>,
  <span style="color: #9cdcfe;">allCards</span>: <span style="color: #4ec9b0;">Card</span>[],
  <span style="color: #9cdcfe;">options</span>: <span style="color: #4ec9b0;">FillInOptions</span>
): <span style="color: #4ec9b0;">AsyncGenerator</span>&lt;<span style="color: #4ec9b0;">string</span>, <span style="color: #4ec9b0;">void</span>, <span style="color: #4ec9b0;">unknown</span>&gt; {
  <span style="color: #6a9955;">// 1. Get connected cards</span>
  <span style="color: #569cd6;">const</span> connectedCards = <span style="color: #569cd6;">await</span> <span style="color: #dcdcaa;">getConnectedCards</span>(targetCard.id, allCards);

  <span style="color: #c586c0;">if</span> (connectedCards.length === <span style="color: #b5cea8;">0</span>) {
    <span style="color: #c586c0;">throw</span> <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Error</span>(<span style="color: #ce9178;">'No connected cards found. Please connect this card to other notes first.'</span>);
  }

  <span style="color: #6a9955;">// 2. Build context from connections</span>
  <span style="color: #569cd6;">const</span> context = <span style="color: #dcdcaa;">buildFillInContext</span>(connectedCards);

  <span style="color: #6a9955;">// 3. Build system prompt based on strategy</span>
  <span style="color: #569cd6;">const</span> systemPrompt = <span style="color: #dcdcaa;">buildSystemPrompt</span>(options);

  <span style="color: #6a9955;">// 4. Build user prompt</span>
  <span style="color: #569cd6;">const</span> userPrompt = <span style="color: #dcdcaa;">buildUserPrompt</span>(targetCard, context, options);

  <span style="color: #6a9955;">// 5. Stream response from LLM</span>
  <span style="color: #569cd6;">const</span> generator = <span style="color: #dcdcaa;">mockClaudeAPI</span>(systemPrompt, userPrompt);

  <span style="color: #c586c0;">for</span> <span style="color: #c586c0;">await</span> (<span style="color: #569cd6;">const</span> chunk <span style="color: #569cd6;">of</span> generator) {
    <span style="color: #c586c0;">yield</span> chunk;
  }
}

<span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">buildSystemPrompt</span>(<span style="color: #9cdcfe;">options</span>: <span style="color: #4ec9b0;">FillInOptions</span>): <span style="color: #4ec9b0;">string</span> {
  <span style="color: #569cd6;">const</span> toneInstructions = {
    <span style="color: #9cdcfe;">academic</span>: <span style="color: #ce9178;">'Write in an academic style with proper citations and formal language.'</span>,
    <span style="color: #9cdcfe;">creative</span>: <span style="color: #ce9178;">'Write in a creative, engaging style with vivid examples and analogies.'</span>,
    <span style="color: #9cdcfe;">concise</span>: <span style="color: #ce9178;">'Write concisely, focusing on key points and avoiding unnecessary detail.'</span>
  };

  <span style="color: #569cd6;">const</span> strategyInstructions = {
    <span style="color: #9cdcfe;">replace</span>: <span style="color: #ce9178;">'Generate a complete, comprehensive note that synthesizes all the connected information.'</span>,
    <span style="color: #9cdcfe;">append</span>: <span style="color: #ce9178;">'Generate additional content that expands on the existing note using the connected information.'</span>,
    <span style="color: #9cdcfe;">merge</span>: <span style="color: #ce9178;">'Intelligently integrate information from connected notes while preserving key insights from the existing content.'</span>
  };

  <span style="color: #c586c0;">return</span> <span style="color: #ce9178;">`You are helping develop a note by synthesizing information from connected notes.

</span><span style="color: #569cd6;">${</span>strategyInstructions[options.strategy]<span style="color: #569cd6;">}</span><span style="color: #ce9178;">
</span><span style="color: #569cd6;">${</span>options.tone ? toneInstructions[options.tone] : <span style="color: #ce9178;">''</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">

Focus on creating coherent, well-structured content that integrates ideas from multiple sources.
Use HTML formatting with proper semantic tags (&lt;p&gt;, &lt;h3&gt;, &lt;ul&gt;, &lt;strong&gt;, etc.).`</span>;
}

<span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">buildUserPrompt</span>(
  <span style="color: #9cdcfe;">targetCard</span>: <span style="color: #4ec9b0;">Card</span>,
  <span style="color: #9cdcfe;">context</span>: <span style="color: #4ec9b0;">string</span>,
  <span style="color: #9cdcfe;">options</span>: <span style="color: #4ec9b0;">FillInOptions</span>
): <span style="color: #4ec9b0;">string</span> {
  <span style="color: #569cd6;">const</span> parts = [
    <span style="color: #ce9178;">`# Target Note`</span>,
    <span style="color: #ce9178;">`Title: </span><span style="color: #569cd6;">${</span>targetCard.metadata?.title || <span style="color: #ce9178;">'Untitled'</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>,
  ];

  <span style="color: #c586c0;">if</span> (targetCard.content && options.strategy !== <span style="color: #ce9178;">'replace'</span>) {
    parts.<span style="color: #dcdcaa;">push</span>(<span style="color: #ce9178;">`Current Content:\n</span><span style="color: #569cd6;">${</span>targetCard.content<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>);
  }

  parts.<span style="color: #dcdcaa;">push</span>(<span style="color: #ce9178;">`\n# Connected Notes\n</span><span style="color: #569cd6;">${</span>context<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>);

  <span style="color: #c586c0;">if</span> (options.userPrompt) {
    parts.<span style="color: #dcdcaa;">push</span>(<span style="color: #ce9178;">`\n# User Instructions\n</span><span style="color: #569cd6;">${</span>options.userPrompt<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>);
  }

  <span style="color: #c586c0;">return</span> parts.<span style="color: #dcdcaa;">join</span>(<span style="color: #ce9178;">'\n\n'</span>);
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 4: Fill-In Modal UI</h3>
        <p>Create <code>src/components/FillInModal.tsx</code>:</p>
        <div class="code-block">
<span style="color: #6a9955;">/** @jsxImportSource @emotion/react */</span>
<span style="color: #c586c0;">import</span> { useState, useEffect } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'react'</span>;
<span style="color: #c586c0;">import</span> { Card } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/types/card'</span>;
<span style="color: #c586c0;">import</span> { fillInFromConnections, FillInStrategy } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/services/fillInService'</span>;
<span style="color: #c586c0;">import</span> { getConnectedCards } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/services/connectionContextService'</span>;

<span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">FillInModalProps</span> {
  <span style="color: #9cdcfe;">card</span>: <span style="color: #4ec9b0;">Card</span>;
  <span style="color: #9cdcfe;">allCards</span>: <span style="color: #4ec9b0;">Card</span>[];
  <span style="color: #9cdcfe;">onClose</span>: () <span style="color: #569cd6;">=&gt;</span> <span style="color: #4ec9b0;">void</span>;
  <span style="color: #9cdcfe;">onSave</span>: (<span style="color: #9cdcfe;">updatedCard</span>: <span style="color: #4ec9b0;">Card</span>) <span style="color: #569cd6;">=&gt;</span> <span style="color: #4ec9b0;">void</span>;
}

<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">FillInModal</span>({ <span style="color: #9cdcfe;">card, allCards, onClose, onSave</span> }: <span style="color: #4ec9b0;">FillInModalProps</span>) {
  <span style="color: #569cd6;">const</span> [connectedCards, setConnectedCards] = <span style="color: #dcdcaa;">useState</span>&lt;<span style="color: #4ec9b0;">Card</span>[]&gt;([]);
  <span style="color: #569cd6;">const</span> [strategy, setStrategy] = <span style="color: #dcdcaa;">useState</span>&lt;<span style="color: #4ec9b0;">FillInStrategy</span>&gt;(<span style="color: #ce9178;">'replace'</span>);
  <span style="color: #569cd6;">const</span> [userPrompt, setUserPrompt] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #ce9178;">''</span>);
  <span style="color: #569cd6;">const</span> [generatedContent, setGeneratedContent] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #ce9178;">''</span>);
  <span style="color: #569cd6;">const</span> [isGenerating, setIsGenerating] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #569cd6;">false</span>);

  <span style="color: #6a9955;">// Load connected cards on mount</span>
  <span style="color: #dcdcaa;">useEffect</span>(() <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #dcdcaa;">getConnectedCards</span>(card.id, allCards).<span style="color: #dcdcaa;">then</span>(setConnectedCards);
  }, [card.id, allCards]);

  <span style="color: #569cd6;">const</span> handleGenerate = <span style="color: #569cd6;">async</span> () <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #dcdcaa;">setIsGenerating</span>(<span style="color: #569cd6;">true</span>);
    <span style="color: #dcdcaa;">setGeneratedContent</span>(<span style="color: #ce9178;">''</span>);

    <span style="color: #c586c0;">try</span> {
      <span style="color: #569cd6;">const</span> generator = <span style="color: #dcdcaa;">fillInFromConnections</span>(card, allCards, {
        strategy,
        userPrompt: userPrompt || <span style="color: #569cd6;">undefined</span>
      });

      <span style="color: #c586c0;">for</span> <span style="color: #c586c0;">await</span> (<span style="color: #569cd6;">const</span> chunk <span style="color: #569cd6;">of</span> generator) {
        <span style="color: #dcdcaa;">setGeneratedContent</span>(<span style="color: #9cdcfe;">prev</span> <span style="color: #569cd6;">=&gt;</span> prev + chunk);
      }
    } <span style="color: #c586c0;">catch</span> (<span style="color: #9cdcfe;">error</span>) {
      console.<span style="color: #dcdcaa;">error</span>(<span style="color: #ce9178;">'[FillInModal] Generation failed:'</span>, error);
      <span style="color: #dcdcaa;">alert</span>(error.<span style="color: #dcdcaa;">message</span>);
    } <span style="color: #c586c0;">finally</span> {
      <span style="color: #dcdcaa;">setIsGenerating</span>(<span style="color: #569cd6;">false</span>);
    }
  };

  <span style="color: #569cd6;">const</span> handleSave = () <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #569cd6;">const</span> updatedCard = { ...card };

    <span style="color: #c586c0;">if</span> (strategy === <span style="color: #ce9178;">'replace'</span>) {
      updatedCard.content = generatedContent;
    } <span style="color: #c586c0;">else</span> <span style="color: #c586c0;">if</span> (strategy === <span style="color: #ce9178;">'append'</span>) {
      updatedCard.content = (card.content || <span style="color: #ce9178;">''</span>) + <span style="color: #ce9178;">'\n\n'</span> + generatedContent;
    } <span style="color: #c586c0;">else</span> {
      <span style="color: #6a9955;">// merge - for now, just replace (could be smarter)</span>
      updatedCard.content = generatedContent;
    }

    <span style="color: #6a9955;">// Add to fill-in history</span>
    updatedCard.fillInHistory = [
      ...(card.fillInHistory || []),
      {
        timestamp: <span style="color: #4ec9b0;">Date</span>.<span style="color: #dcdcaa;">now</span>(),
        sourceCardIds: connectedCards.<span style="color: #dcdcaa;">map</span>(<span style="color: #9cdcfe;">c</span> <span style="color: #569cd6;">=&gt;</span> c.id),
        strategy,
        userPrompt: userPrompt || <span style="color: #569cd6;">undefined</span>,
        previousContent: card.content
      }
    ];

    <span style="color: #dcdcaa;">onSave</span>(updatedCard);
    <span style="color: #dcdcaa;">onClose</span>();
  };

  <span style="color: #c586c0;">return</span> (
    <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span> <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"fill-in-modal"</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">h2</span><span style="color: #808080;">&gt;</span>ğŸ”— Fill In from Connections<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">h2</span><span style="color: #808080;">&gt;</span>

      <span style="color: #6a9955;">{/* Connected cards preview */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">h3</span><span style="color: #808080;">&gt;</span>Connected Cards ({connectedCards.length})<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">h3</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">ul</span><span style="color: #808080;">&gt;</span>
          {connectedCards.<span style="color: #dcdcaa;">map</span>(<span style="color: #9cdcfe;">c</span> <span style="color: #569cd6;">=&gt;</span> (
            <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">li</span> <span style="color: #9cdcfe;">key</span>={c.id}<span style="color: #808080;">&gt;</span>{c.metadata?.title || <span style="color: #ce9178;">'Untitled'</span>}<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">li</span><span style="color: #808080;">&gt;</span>
          ))}
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">ul</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>

      <span style="color: #6a9955;">{/* Strategy selector */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">label</span><span style="color: #808080;">&gt;</span>Strategy:<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">label</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">select</span> <span style="color: #9cdcfe;">value</span>={strategy} <span style="color: #9cdcfe;">onChange</span>={<span style="color: #9cdcfe;">e</span> <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setStrategy</span>(e.target.value <span style="color: #569cd6;">as</span> <span style="color: #4ec9b0;">FillInStrategy</span>)}<span style="color: #808080;">&gt;</span>
          <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">option</span> <span style="color: #9cdcfe;">value</span>=<span style="color: #ce9178;">"replace"</span><span style="color: #808080;">&gt;</span>Replace - Start fresh<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">option</span><span style="color: #808080;">&gt;</span>
          <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">option</span> <span style="color: #9cdcfe;">value</span>=<span style="color: #ce9178;">"append"</span><span style="color: #808080;">&gt;</span>Append - Add to existing<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">option</span><span style="color: #808080;">&gt;</span>
          <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">option</span> <span style="color: #9cdcfe;">value</span>=<span style="color: #ce9178;">"merge"</span><span style="color: #808080;">&gt;</span>Merge - Integrate with existing<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">option</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">select</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>

      <span style="color: #6a9955;">{/* Optional user guidance */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">textarea</span>
        <span style="color: #9cdcfe;">placeholder</span>=<span style="color: #ce9178;">"Optional: Provide specific guidance (e.g., 'Focus on practical applications')"</span>
        <span style="color: #9cdcfe;">value</span>={userPrompt}
        <span style="color: #9cdcfe;">onChange</span>={<span style="color: #9cdcfe;">e</span> <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setUserPrompt</span>(e.target.value)}
      <span style="color: #808080;">/&gt;</span>

      <span style="color: #6a9955;">{/* Generated content preview */}</span>
      {generatedContent && (
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span>
          <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"preview"</span>
          <span style="color: #9cdcfe;">dangerouslySetInnerHTML</span>={{ __html: generatedContent }}
        <span style="color: #808080;">/&gt;</span>
      )}

      <span style="color: #6a9955;">{/* Actions */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span> <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"actions"</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span> <span style="color: #9cdcfe;">onClick</span>={handleGenerate} <span style="color: #9cdcfe;">disabled</span>={isGenerating}<span style="color: #808080;">&gt;</span>
          {isGenerating ? <span style="color: #ce9178;">'Generating...'</span> : <span style="color: #ce9178;">'Generate'</span>}
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span> <span style="color: #9cdcfe;">onClick</span>={handleSave} <span style="color: #9cdcfe;">disabled</span>={!generatedContent}<span style="color: #808080;">&gt;</span>
          Save
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span> <span style="color: #9cdcfe;">onClick</span>={onClose}<span style="color: #808080;">&gt;</span>Cancel<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
    <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
  );
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 5: Integrate into CardNode</h3>
        <p>Add "Fill In" button to cards with connections:</p>
        <div class="code-block">
<span style="color: #6a9955;">// In CardNode.tsx</span>
<span style="color: #569cd6;">const</span> [showFillInModal, setShowFillInModal] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #569cd6;">false</span>);
<span style="color: #569cd6;">const</span> [connectionCount, setConnectionCount] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #b5cea8;">0</span>);

<span style="color: #6a9955;">// Count connections for this card</span>
<span style="color: #dcdcaa;">useEffect</span>(() <span style="color: #569cd6;">=&gt;</span> {
  <span style="color: #dcdcaa;">getConnections</span>().<span style="color: #dcdcaa;">then</span>(<span style="color: #9cdcfe;">connections</span> <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #569cd6;">const</span> count = connections.<span style="color: #dcdcaa;">filter</span>(
      <span style="color: #9cdcfe;">c</span> <span style="color: #569cd6;">=&gt;</span> c.source === card.id || c.target === card.id
    ).length;
    <span style="color: #dcdcaa;">setConnectionCount</span>(count);
  });
}, [card.id]);

<span style="color: #6a9955;">// In card header, after other buttons:</span>
{connectionCount &gt; <span style="color: #b5cea8;">0</span> && (
  <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span>
    <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"fill-in-button"</span>
    <span style="color: #9cdcfe;">onClick</span>={() <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setShowFillInModal</span>(<span style="color: #569cd6;">true</span>)}
    <span style="color: #9cdcfe;">title</span>=<span style="color: #ce9178;">"Fill in from connected cards"</span>
  <span style="color: #808080;">&gt;</span>
    ğŸ”— Fill In ({connectionCount})
  <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
)}

{showFillInModal && (
  <span style="color: #808080;">&lt;</span><span style="color: #4ec9b0;">FillInModal</span>
    <span style="color: #9cdcfe;">card</span>={card}
    <span style="color: #9cdcfe;">allCards</span>={allCards}  <span style="color: #6a9955;">// Pass from Canvas via props</span>
    <span style="color: #9cdcfe;">onClose</span>={() <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setShowFillInModal</span>(<span style="color: #569cd6;">false</span>)}
    <span style="color: #9cdcfe;">onSave</span>={handleUpdateCard}
  <span style="color: #808080;">/&gt;</span>
)}
        </div>
    </div>

    <h2>ğŸ¨ UX Enhancements</h2>

    <div class="feature-box">
        <h3>Visual Feedback</h3>
        <ul>
            <li><strong>Connection Indicators:</strong> Show badge with connection count on all cards</li>
            <li><strong>Source Attribution:</strong> In generated content, highlight which parts came from which connected cards (color-coded)</li>
            <li><strong>Diff View:</strong> Before saving, show side-by-side comparison of old vs. new content</li>
            <li><strong>Animation:</strong> Pulse/glow effect on connected cards during generation</li>
        </ul>
    </div>

    <div class="feature-box">
        <h3>Iterative Refinement</h3>
        <ul>
            <li><strong>Multiple Rounds:</strong> User can connect more cards and fill in again to further develop</li>
            <li><strong>History Timeline:</strong> Show fill-in history with ability to revert to previous versions</li>
            <li><strong>Selective Include:</strong> Choose which connected cards to include in each fill-in operation</li>
            <li><strong>Manual Edits:</strong> User can edit generated content before saving</li>
        </ul>
    </div>

    <div class="feature-box">
        <h3>Smart Connections</h3>
        <ul>
            <li><strong>Auto-Suggest:</strong> When user creates a new note, suggest relevant cards to connect based on content similarity</li>
            <li><strong>Connection Types:</strong> Label connections (supports, contradicts, extends, examples-of)</li>
            <li><strong>Weighted Influence:</strong> Give more weight to certain connections in synthesis</li>
        </ul>
    </div>

    <h2>ğŸ”„ Advanced Workflows</h2>

    <div class="workflow">
        <h3>Research Synthesis Workflow</h3>
        <ol>
            <li>Create new note: "Deep learning for healthcare"</li>
            <li>Connect to 5 clipped research papers</li>
            <li>Fill in with strategy: "Replace" â†’ Get comprehensive overview</li>
            <li>Connect 2 more papers with specific techniques</li>
            <li>Fill in again with strategy: "Append" â†’ Add technical details</li>
            <li>Manually edit to add personal insights</li>
            <li>Export as final literature review</li>
        </ol>
    </div>

    <div class="workflow">
        <h3>Concept Development Workflow</h3>
        <ol>
            <li>Create sparse note: "Product idea: AI tutor"</li>
            <li>Connect to market research card</li>
            <li>Fill in â†’ Get market context</li>
            <li>Connect to technical feasibility card</li>
            <li>Fill in (append) â†’ Add technical details</li>
            <li>Connect to competitor analysis card</li>
            <li>Fill in (merge) â†’ Integrate competitive positioning</li>
            <li>Result: Fully developed product proposal</li>
        </ol>
    </div>

    <div class="workflow">
        <h3>Progressive Elaboration</h3>
        <ol>
            <li>Start with minimal note: "Transformer architecture"</li>
            <li>Round 1: Connect to "Attention mechanism" â†’ Fill in basics</li>
            <li>Round 2: Connect to "Positional encoding" â†’ Fill in (append)</li>
            <li>Round 3: Connect to "Multi-head attention" â†’ Fill in (append)</li>
            <li>Round 4: Connect to "Applications" â†’ Fill in (append)</li>
            <li>Result: Comprehensive guide built incrementally</li>
        </ol>
    </div>

    <h2>ğŸ’¡ Implementation Timeline</h2>

    <div class="note">
        <h3>Phase 1: Core Fill-In (6-8 hours)</h3>
        <ul>
            <li>âœ… Extend Card type with fillInHistory (30 min)</li>
            <li>âœ… Create connectionContextService (1 hour)</li>
            <li>âœ… Create fillInService with AI integration (2 hours)</li>
            <li>âœ… Build FillInModal UI (2 hours)</li>
            <li>âœ… Integrate into CardNode (1 hour)</li>
            <li>âœ… Testing and debugging (1.5 hours)</li>
        </ul>
    </div>

    <div class="note">
        <h3>Phase 2: UX Polish (3-4 hours)</h3>
        <ul>
            <li>ğŸ”² Add visual feedback and animations</li>
            <li>ğŸ”² Implement diff view for preview</li>
            <li>ğŸ”² Add undo/history timeline</li>
            <li>ğŸ”² Connection count badges</li>
        </ul>
    </div>

    <div class="note">
        <h3>Phase 3: Advanced Features (4-6 hours)</h3>
        <ul>
            <li>ğŸ”² Auto-suggest relevant connections</li>
            <li>ğŸ”² Connection type labels</li>
            <li>ğŸ”² Selective card inclusion</li>
            <li>ğŸ”² Source attribution in generated content</li>
        </ul>
    </div>

    <h2>ğŸ¯ Why This Feature is Powerful</h2>

    <div class="feature-box">
        <p class="advantage">âœ… <strong>Active Knowledge Integration:</strong> Transforms passive note storage into active synthesis</p>
        <p class="advantage">âœ… <strong>Iterative Thinking:</strong> Supports progressive elaboration of ideas</p>
        <p class="advantage">âœ… <strong>Connection-Driven:</strong> Leverages existing connection infrastructure</p>
        <p class="advantage">âœ… <strong>Low Barrier:</strong> User just creates sparse note + connections, AI does the heavy lifting</p>
        <p class="advantage">âœ… <strong>Preserves Agency:</strong> User controls which cards contribute and can edit results</p>
        <p class="advantage">âœ… <strong>Complements Other Features:</strong> Works alongside expandable cards, multi-card queries</p>
    </div>

    <div class="note">
        <h3>ğŸ”— Connection to Literature</h3>
        <p>This feature embodies <strong>Ted Nelson's concept of "transclusion"</strong> - where content from multiple sources is dynamically combined to create new documents. It also aligns with <strong>Vannevar Bush's vision of "trails of association"</strong> where links between documents create meaningful pathways for knowledge exploration.</p>
    </div>

    <h2>ğŸš€ Next Steps</h2>
    <ol>
        <li>Implement Phase 1 (core fill-in functionality)</li>
        <li>Test with real research scenarios</li>
        <li>Gather user feedback on strategy options</li>
        <li>Iterate on UX based on usage patterns</li>
        <li>Consider adding to <code>next-steps.html</code> as a major feature</li>
    </ol>

</body>
</html>