<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Worker Communication Patterns</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --ink-black: #1a1a1a;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #555;
            --level-4: #888;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.3;
            font-size: 14px;
            padding: 12px;
        }

        h1 {
            font-size: 28px;
            font-weight: 900;
            margin: 8px 0;
            padding: 8px 0;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
            text-align: center;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 12px 0 6px 0;
            padding: 6px 8px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.05);
            color: var(--level-1);
        }

        h3 {
            font-size: 15px;
            font-weight: 600;
            margin: 8px 0 4px 0;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 13px;
            font-weight: 600;
            margin: 6px 0 3px 0;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), white);
            border: 2px solid var(--chinese-gold);
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
        }

        .important-always-visible h2 {
            color: var(--chinese-red);
            margin-top: 0;
            border: none;
            background: none;
            padding: 0;
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 8px 0;
        }

        .diagram-container {
            background: white;
            border: 2px solid rgba(139, 0, 0, 0.2);
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .diagram-title {
            font-weight: 700;
            color: var(--chinese-red);
            margin-bottom: 8px;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid var(--chinese-gold);
            padding-bottom: 4px;
        }

        .mermaid {
            text-align: center;
            background: rgba(245, 245, 220, 0.2);
            padding: 8px;
            border-radius: 3px;
        }

        .collapsible {
            margin: 6px 0;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.06), rgba(255, 215, 0, 0.03));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 14px;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.12), rgba(255, 215, 0, 0.06));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 12px;
            margin-right: 8px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 8000px;
            padding: 12px;
        }

        .collapsible.critical .collapsible-header {
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.1);
            font-weight: 700;
        }

        pre {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.4), rgba(255, 255, 255, 0.6));
            border: 1px solid rgba(139, 0, 0, 0.15);
            padding: 8px;
            margin: 6px 0;
            overflow-x: auto;
            border-radius: 3px;
            font-size: 12px;
            line-height: 1.4;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
        }

        code {
            background: rgba(245, 245, 220, 0.3);
            padding: 2px 5px;
            border-radius: 2px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 8px 0;
            font-size: 12px;
            background: white;
        }

        .comparison-table th {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            padding: 6px 8px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 6px 8px;
            vertical-align: top;
        }

        .comparison-table tr:nth-child(even) {
            background: rgba(245, 245, 220, 0.2);
        }

        .key-point {
            background: rgba(255, 215, 0, 0.15);
            border-left: 3px solid var(--chinese-gold);
            padding: 8px;
            margin: 6px 0;
            font-size: 13px;
        }

        .key-point strong {
            color: var(--chinese-red);
        }

        ul, ol {
            margin-left: 20px;
            margin-top: 4px;
            margin-bottom: 8px;
        }

        li {
            margin: 3px 0;
            line-height: 1.4;
        }

        .warning {
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.1), rgba(255, 215, 0, 0.1));
            border: 2px solid #FF6347;
            padding: 8px;
            margin: 8px 0;
            border-radius: 3px;
            font-size: 13px;
        }

        .warning strong {
            color: #DC143C;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 8px 0;
        }

        .method-card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 3px;
            padding: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .method-card h4 {
            margin: 0 0 4px 0;
            color: var(--chinese-red);
            border-bottom: 1px solid var(--chinese-gold);
            padding-bottom: 3px;
        }

        .nav-buttons {
            position: fixed;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .nav-buttons button {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .nav-buttons button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(139, 0, 0, 0.3);
            border-color: var(--chinese-gold);
        }
    </style>
</head>
<body>
    <div class="nav-buttons">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
    </div>

    <h1>Web Worker Communication Patterns</h1>

    <div class="important-always-visible">
        <h2>Quick Reference: Worker Types & Communication</h2>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Worker Type</th>
                    <th>Relationship</th>
                    <th>Primary API</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Dedicated Worker</strong></td>
                    <td>1:1 pipe (single creator)</td>
                    <td><code>postMessage()</code> / <code>onmessage</code></td>
                    <td>Heavy computation, isolated tasks</td>
                </tr>
                <tr>
                    <td><strong>Shared Worker</strong></td>
                    <td>N:1 hub (multiple pages)</td>
                    <td><code>port.postMessage()</code> / MessagePort</td>
                    <td>Cross-tab state, shared connections</td>
                </tr>
                <tr>
                    <td><strong>Service Worker</strong></td>
                    <td>Proxy (all pages in origin)</td>
                    <td>Client API, Broadcast, MessageChannel</td>
                    <td>Network interception, caching, push</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2>1. Dedicated Worker Communication</h2>

    <div class="diagram-container">
        <div class="diagram-title">Dedicated Worker: Bidirectional Pipe</div>
        <div class="mermaid">
graph LR
    A[Main Thread<br/>main.js] -->|worker.postMessage| B[Dedicated Worker<br/>worker.js]
    B -->|self.postMessage| A
    A -->|worker.terminate| B
    B -->|onerror| A

    style A fill:#FFD700,stroke:#8B0000,stroke-width:2px
    style B fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
        </div>
    </div>

    <div class="collapsible critical">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Basic postMessage Pattern</span>
        </div>
        <div class="collapsible-content">
            <div class="two-column-layout">
                <div>
                    <h4>Main Thread (Creator)</h4>
                    <pre><code>// Create worker
const worker = new Worker('compute.js');

// Send message to worker
worker.postMessage({
    task: 'calculate',
    data: [1, 2, 3, 4, 5]
});

// Receive messages from worker
worker.onmessage = (event) => {
    console.log('Result:', event.data);
    // Result: { result: 15 }
};

// Handle errors
worker.onerror = (error) => {
    console.error('Worker error:', error);
};

// Terminate when done
worker.terminate();</code></pre>
                </div>
                <div>
                    <h4>Worker Thread (compute.js)</h4>
                    <pre><code>// Receive messages from main
self.onmessage = (event) => {
    const { task, data } = event.data;

    if (task === 'calculate') {
        const result = data.reduce((a, b) => a + b);

        // Send result back to main
        self.postMessage({ result });
    }
};

// Handle errors in worker
self.onerror = (error) => {
    console.error('Error in worker:', error);
};</code></pre>
                </div>
            </div>

            <div class="key-point">
                <strong>Key Point:</strong> Data is <strong>cloned</strong>, not shared. Changes to <code>event.data</code> in worker don't affect original in main thread.
            </div>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Advanced: Transferable Objects (Zero-Copy)</span>
        </div>
        <div class="collapsible-content">
            <div class="diagram-container">
                <div class="diagram-title">Transferable Objects: Ownership Transfer</div>
                <div class="mermaid">
sequenceDiagram
    participant M as Main Thread
    participant W as Worker

    M->>M: Create ArrayBuffer (1MB)
    M->>W: postMessage(buffer, [buffer])<br/>[Transfer ownership]
    Note over M: buffer is now empty<br/>(neutered/detached)
    Note over W: Worker owns buffer
    W->>W: Process buffer
    W->>M: postMessage(result, [result])<br/>[Transfer back]
    Note over W: result is now empty
    Note over M: Main owns result
                </div>
            </div>

            <pre><code>// Main thread
const buffer = new ArrayBuffer(1024 * 1024); // 1MB
const view = new Uint8Array(buffer);
view[0] = 42;

// Transfer ownership (zero-copy, super fast)
worker.postMessage({ buffer }, [buffer]);

// buffer is now "neutered" - can't use it anymore
console.log(buffer.byteLength); // 0

// Worker (worker.js)
self.onmessage = (e) => {
    const buffer = e.data.buffer;
    const view = new Uint8Array(buffer);

    // Process data...
    view[0] = view[0] * 2;

    // Transfer back
    self.postMessage({ buffer }, [buffer]);
};</code></pre>

            <div class="key-point">
                <strong>Transferable Types:</strong> ArrayBuffer, MessagePort, ImageBitmap, OffscreenCanvas, ReadableStream, WritableStream, TransformStream
            </div>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Event Listener Alternative to onmessage</span>
        </div>
        <div class="collapsible-content">
            <div class="two-column-layout">
                <div>
                    <h4>Property-based (onmessage)</h4>
                    <pre><code>worker.onmessage = (e) => {
    console.log(e.data);
};

// Only ONE handler allowed
worker.onmessage = (e) => {
    // This replaces the previous handler
};</code></pre>
                </div>
                <div>
                    <h4>addEventListener (preferred)</h4>
                    <pre><code>worker.addEventListener('message', (e) => {
    console.log(e.data);
});

// Multiple handlers allowed
worker.addEventListener('message', (e) => {
    // Both handlers will fire
});</code></pre>
                </div>
            </div>
        </div>
    </div>

    <h2>2. Shared Worker Communication</h2>

    <div class="diagram-container">
        <div class="diagram-title">Shared Worker: Multi-Port Hub</div>
        <div class="mermaid">
graph TB
    SW[Shared Worker<br/>shared.js]

    T1[Tab 1<br/>page.html] -->|port.postMessage| SW
    T2[Tab 2<br/>page.html] -->|port.postMessage| SW
    T3[Tab 3<br/>other.html] -->|port.postMessage| SW

    SW -->|port.postMessage| T1
    SW -->|port.postMessage| T2
    SW -->|port.postMessage| T3

    style SW fill:#FFD700,stroke:#8B0000,stroke-width:3px
    style T1 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style T2 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style T3 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
        </div>
    </div>

    <div class="collapsible critical">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Shared Worker: Port-based Communication</span>
        </div>
        <div class="collapsible-content">
            <div class="two-column-layout">
                <div>
                    <h4>Page/Tab (Multiple Instances)</h4>
                    <pre><code>// Each tab creates connection
const worker = new SharedWorker('shared.js');

// MUST call start() on port
worker.port.start();

// Send via port
worker.port.postMessage({
    type: 'subscribe',
    channel: 'updates'
});

// Receive via port
worker.port.onmessage = (e) => {
    console.log('Broadcast:', e.data);
};

// Each tab has its own port
// but all connect to SAME worker instance</code></pre>
                </div>
                <div>
                    <h4>Shared Worker (shared.js)</h4>
                    <pre><code>const connections = [];

// Fired when new tab connects
self.onconnect = (e) => {
    const port = e.ports[0];
    connections.push(port);

    port.onmessage = (event) => {
        const msg = event.data;

        // Broadcast to all connections
        connections.forEach(p => {
            p.postMessage({
                from: 'worker',
                data: msg
            });
        });
    };

    port.start();
};</code></pre>
                </div>
            </div>

            <div class="warning">
                <strong>Critical Difference:</strong> Shared Workers use <code>port.postMessage()</code> and <code>port.onmessage</code>, not direct <code>worker.postMessage()</code>. You MUST call <code>port.start()</code>!
            </div>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Shared Worker Use Cases</span>
        </div>
        <div class="collapsible-content">
            <div class="grid-3">
                <div class="method-card">
                    <h4>Cross-Tab State</h4>
                    <ul>
                        <li>Shared authentication token</li>
                        <li>Synchronized user preferences</li>
                        <li>Multi-tab shopping cart</li>
                    </ul>
                </div>
                <div class="method-card">
                    <h4>Shared Connections</h4>
                    <ul>
                        <li>Single WebSocket for all tabs</li>
                        <li>Shared database connection</li>
                        <li>Pooled API requests</li>
                    </ul>
                </div>
                <div class="method-card">
                    <h4>Cross-Tab Messaging</h4>
                    <ul>
                        <li>Broadcast updates to all tabs</li>
                        <li>Tab coordination</li>
                        <li>Logout all tabs simultaneously</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <h2>3. Service Worker Communication</h2>

    <div class="diagram-container">
        <div class="diagram-title">Service Worker: Network Proxy & Client Communication</div>
        <div class="mermaid">
graph TB
    subgraph Browser
        P1[Page 1]
        P2[Page 2]
        P3[Page 3]
        SW[Service Worker<br/>sw.js]
    end

    N[Network]

    P1 <-->|Client API<br/>MessageChannel| SW
    P2 <-->|postMessage<br/>BroadcastChannel| SW
    P3 <-->|clients.matchAll| SW

    SW <-->|fetch intercept| N

    style SW fill:#FFD700,stroke:#8B0000,stroke-width:3px
    style P1 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style P2 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style P3 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
        </div>
    </div>

    <div class="collapsible critical">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Method 1: navigator.serviceWorker.controller</span>
        </div>
        <div class="collapsible-content">
            <div class="two-column-layout">
                <div>
                    <h4>Page to Service Worker</h4>
                    <pre><code>// Check if SW is controlling this page
if (navigator.serviceWorker.controller) {
    // Send message to SW
    navigator.serviceWorker.controller.postMessage({
        type: 'CACHE_UPDATE',
        url: '/api/data'
    });
}

// Listen for messages from SW
navigator.serviceWorker.addEventListener(
    'message',
    (event) => {
        console.log('SW says:', event.data);
    }
);</code></pre>
                </div>
                <div>
                    <h4>Service Worker (sw.js)</h4>
                    <pre><code>// Listen for messages from pages
self.addEventListener('message', (event) => {
    const { type, url } = event.data;

    if (type === 'CACHE_UPDATE') {
        // Update cache
        caches.open('v1').then(cache => {
            cache.add(url);
        });

        // Send response back
        event.source.postMessage({
            type: 'CACHE_UPDATED',
            url: url
        });
    }
});</code></pre>
                </div>
            </div>
        </div>
    </div>

    <div class="collapsible critical">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Method 2: Clients API (SW → Pages)</span>
        </div>
        <div class="collapsible-content">
            <pre><code>// Service Worker: Send to ALL controlled pages
self.addEventListener('push', (event) => {
    const data = event.data.json();

    // Get all clients (pages)
    event.waitUntil(
        self.clients.matchAll().then(clients => {
            // Broadcast to every page
            clients.forEach(client => {
                client.postMessage({
                    type: 'PUSH_NOTIFICATION',
                    data: data
                });
            });
        })
    );
});

// Send to specific client by ID
self.addEventListener('message', async (event) => {
    const clientId = event.source.id;
    const client = await self.clients.get(clientId);

    client.postMessage({ reply: 'Just for you!' });
});</code></pre>

            <div class="key-point">
                <strong>Clients API Methods:</strong>
                <ul>
                    <li><code>clients.matchAll()</code> - Get all controlled pages</li>
                    <li><code>clients.get(id)</code> - Get specific page</li>
                    <li><code>clients.claim()</code> - Take control of uncontrolled pages</li>
                    <li><code>clients.openWindow(url)</code> - Open new window/tab</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Method 3: MessageChannel (Two-way Pipe)</span>
        </div>
        <div class="collapsible-content">
            <div class="diagram-container">
                <div class="diagram-title">MessageChannel: Dedicated Communication Channel</div>
                <div class="mermaid">
sequenceDiagram
    participant Page
    participant MC as MessageChannel
    participant SW as Service Worker

    Page->>MC: Create channel
    MC->>MC: port1, port2
    Page->>SW: postMessage({}, [port2])
    Note over SW: Receives port2
    Page->>MC: port1.postMessage("Hello")
    MC->>SW: port2.onmessage
    SW->>MC: port2.postMessage("Reply")
    MC->>Page: port1.onmessage
                </div>
            </div>

            <div class="two-column-layout">
                <div>
                    <h4>Page Creates Channel</h4>
                    <pre><code>// Create two-way channel
const channel = new MessageChannel();

// Keep port1, send port2 to SW
navigator.serviceWorker.controller.postMessage(
    { type: 'INIT_CHANNEL' },
    [channel.port2]  // Transfer port
);

// Listen on port1
channel.port1.onmessage = (e) => {
    console.log('SW reply:', e.data);
};

// Send via port1
channel.port1.postMessage('Hello from page');</code></pre>
                </div>
                <div>
                    <h4>Service Worker Uses Channel</h4>
                    <pre><code>self.addEventListener('message', (event) => {
    if (event.data.type === 'INIT_CHANNEL') {
        // Get transferred port2
        const port = event.ports[0];

        // Listen on port2
        port.onmessage = (e) => {
            console.log('Page says:', e.data);

            // Reply via same port
            port.postMessage('ACK: ' + e.data);
        };
    }
});</code></pre>
                </div>
            </div>

            <div class="key-point">
                <strong>Why MessageChannel?</strong> Creates a dedicated, private communication channel. Useful for request-response patterns or when you need isolated communication streams.
            </div>
        </div>
    </div>

    <h2>4. Cross-Context Communication</h2>

    <div class="collapsible critical">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>BroadcastChannel API (Any to Any)</span>
        </div>
        <div class="collapsible-content">
            <div class="diagram-container">
                <div class="diagram-title">BroadcastChannel: Named Broadcast Bus</div>
                <div class="mermaid">
graph TB
    BC[BroadcastChannel<br/>'my-channel']

    T1[Tab 1] <-->|subscribe/publish| BC
    T2[Tab 2] <-->|subscribe/publish| BC
    W[Worker] <-->|subscribe/publish| BC
    SW[Service Worker] <-->|subscribe/publish| BC

    style BC fill:#FFD700,stroke:#8B0000,stroke-width:3px
    style T1 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style T2 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style W fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style SW fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
                </div>
            </div>

            <div class="grid-3">
                <div>
                    <h4>Page 1</h4>
                    <pre><code>const bc = new BroadcastChannel('updates');

bc.onmessage = (e) => {
    console.log('Received:', e.data);
};

bc.postMessage({
    user: 'Alice',
    action: 'login'
});</code></pre>
                </div>
                <div>
                    <h4>Page 2 (Different Tab)</h4>
                    <pre><code>const bc = new BroadcastChannel('updates');

bc.onmessage = (e) => {
    // Receives message from Page 1!
    console.log('Received:', e.data);
};

bc.postMessage({
    user: 'Bob',
    action: 'logout'
});</code></pre>
                </div>
                <div>
                    <h4>Worker</h4>
                    <pre><code>const bc = new BroadcastChannel('updates');

bc.onmessage = (e) => {
    // Worker also receives!
    console.log('Received:', e.data);
};

bc.postMessage({
    from: 'worker',
    status: 'ready'
});</code></pre>
                </div>
            </div>

            <div class="key-point">
                <strong>Key Features:</strong>
                <ul>
                    <li><strong>Same-origin only</strong> - All subscribers must be from same origin</li>
                    <li><strong>Named channels</strong> - Multiple channels can coexist</li>
                    <li><strong>Any context</strong> - Works in pages, workers, service workers</li>
                    <li><strong>Simple API</strong> - Just postMessage and onmessage</li>
                    <li><strong>No sender echo</strong> - Sender doesn't receive own messages</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>SharedArrayBuffer + Atomics (Shared Memory)</span>
        </div>
        <div class="collapsible-content">
            <div class="warning">
                <strong>Security Requirement:</strong> SharedArrayBuffer requires <code>Cross-Origin-Opener-Policy: same-origin</code> and <code>Cross-Origin-Embedder-Policy: require-corp</code> headers due to Spectre vulnerabilities.
            </div>

            <div class="two-column-layout">
                <div>
                    <h4>Main Thread (Create Buffer)</h4>
                    <pre><code>// Create shared memory
const buffer = new SharedArrayBuffer(1024);
const view = new Int32Array(buffer);

// Share with worker (NOT transferred!)
worker.postMessage({ buffer });

// Write to shared memory
Atomics.store(view, 0, 42);

// Wait for worker to modify
Atomics.wait(view, 1, 0);
console.log(Atomics.load(view, 1)); // 84</code></pre>
                </div>
                <div>
                    <h4>Worker (Access Same Memory)</h4>
                    <pre><code>self.onmessage = (e) => {
    const view = new Int32Array(e.data.buffer);

    // Read shared memory
    const value = Atomics.load(view, 0);
    console.log(value); // 42

    // Write to shared memory
    Atomics.store(view, 1, value * 2);

    // Wake up waiting thread
    Atomics.notify(view, 1);
};</code></pre>
                </div>
            </div>

            <div class="key-point">
                <strong>Atomics Operations:</strong>
                <ul>
                    <li><code>Atomics.store()</code> / <code>Atomics.load()</code> - Thread-safe read/write</li>
                    <li><code>Atomics.add()</code>, <code>Atomics.sub()</code> - Atomic arithmetic</li>
                    <li><code>Atomics.wait()</code> / <code>Atomics.notify()</code> - Thread synchronization</li>
                    <li><code>Atomics.compareExchange()</code> - Compare-and-swap</li>
                </ul>
            </div>
        </div>
    </div>

    <h2>5. Advanced Patterns</h2>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Request-Response Pattern (Promises)</span>
        </div>
        <div class="collapsible-content">
            <div class="two-column-layout">
                <div>
                    <h4>Main Thread (Promise-based API)</h4>
                    <pre><code>class WorkerPool {
    constructor(workerPath) {
        this.worker = new Worker(workerPath);
        this.callbacks = new Map();
        this.messageId = 0;

        this.worker.onmessage = (e) => {
            const { id, result, error } = e.data;
            const { resolve, reject } = this.callbacks.get(id);

            if (error) reject(error);
            else resolve(result);

            this.callbacks.delete(id);
        };
    }

    execute(task, data) {
        return new Promise((resolve, reject) => {
            const id = this.messageId++;
            this.callbacks.set(id, { resolve, reject });

            this.worker.postMessage({ id, task, data });
        });
    }
}

// Usage
const pool = new WorkerPool('compute.js');
const result = await pool.execute('add', [1, 2, 3]);
console.log(result); // 6</code></pre>
                </div>
                <div>
                    <h4>Worker (Handle with ID)</h4>
                    <pre><code>const tasks = {
    add: (data) => data.reduce((a, b) => a + b),
    multiply: (data) => data.reduce((a, b) => a * b),
    power: (data) => Math.pow(...data)
};

self.onmessage = async (e) => {
    const { id, task, data } = e.data;

    try {
        const fn = tasks[task];
        const result = await fn(data);

        self.postMessage({ id, result });
    } catch (error) {
        self.postMessage({
            id,
            error: error.message
        });
    }
};</code></pre>
                </div>
            </div>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Worker Pool Pattern (Load Balancing)</span>
        </div>
        <div class="collapsible-content">
            <pre><code>class WorkerPool {
    constructor(workerPath, size = navigator.hardwareConcurrency || 4) {
        this.workers = Array.from(
            { length: size },
            () => new Worker(workerPath)
        );
        this.currentIndex = 0;
        this.queue = [];
    }

    execute(task) {
        return new Promise((resolve, reject) => {
            // Round-robin selection
            const worker = this.workers[this.currentIndex];
            this.currentIndex = (this.currentIndex + 1) % this.workers.length;

            worker.onmessage = (e) => resolve(e.data);
            worker.onerror = (e) => reject(e);
            worker.postMessage(task);
        });
    }

    terminate() {
        this.workers.forEach(w => w.terminate());
    }
}

// Usage
const pool = new WorkerPool('heavy-compute.js', 4);

// Distribute work across 4 workers
const tasks = [1, 2, 3, 4, 5, 6, 7, 8].map(n =>
    pool.execute({ compute: n })
);

const results = await Promise.all(tasks);</code></pre>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Streaming Pattern (Progressive Results)</span>
        </div>
        <div class="collapsible-content">
            <div class="two-column-layout">
                <div>
                    <h4>Main Thread (Stream Handler)</h4>
                    <pre><code>const worker = new Worker('streamer.js');

// Handle progressive updates
worker.onmessage = (e) => {
    const { type, progress, chunk, done } = e.data;

    if (type === 'progress') {
        updateProgressBar(progress);
    } else if (type === 'chunk') {
        appendResult(chunk);
    } else if (type === 'done') {
        console.log('Complete!');
    }
};

worker.postMessage({
    file: largeFile,
    chunkSize: 1024 * 1024  // 1MB chunks
});</code></pre>
                </div>
                <div>
                    <h4>Worker (Stream Sender)</h4>
                    <pre><code>self.onmessage = async (e) => {
    const { file, chunkSize } = e.data;
    const total = file.size;

    for (let i = 0; i < total; i += chunkSize) {
        const chunk = file.slice(i, i + chunkSize);
        const processed = await processChunk(chunk);

        // Send progress
        self.postMessage({
            type: 'progress',
            progress: (i / total) * 100
        });

        // Send chunk result
        self.postMessage({
            type: 'chunk',
            chunk: processed
        });
    }

    // Signal completion
    self.postMessage({ type: 'done' });
};</code></pre>
                </div>
            </div>
        </div>
    </div>

    <h2>6. Communication Comparison Matrix</h2>

    <div class="diagram-container">
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Method</th>
                    <th>Works With</th>
                    <th>Direction</th>
                    <th>Same Origin?</th>
                    <th>Best For</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>postMessage</code></td>
                    <td>Dedicated Workers</td>
                    <td>Bidirectional</td>
                    <td>N/A</td>
                    <td>Basic worker communication</td>
                </tr>
                <tr>
                    <td><code>port.postMessage</code></td>
                    <td>Shared Workers</td>
                    <td>Bidirectional</td>
                    <td>Yes</td>
                    <td>Cross-tab shared state</td>
                </tr>
                <tr>
                    <td><code>navigator.serviceWorker</code></td>
                    <td>Service Workers</td>
                    <td>Bidirectional</td>
                    <td>Yes</td>
                    <td>Page ↔ Service Worker</td>
                </tr>
                <tr>
                    <td><code>clients API</code></td>
                    <td>Service Workers</td>
                    <td>SW → Pages</td>
                    <td>Yes</td>
                    <td>Broadcast from SW</td>
                </tr>
                <tr>
                    <td><code>MessageChannel</code></td>
                    <td>All contexts</td>
                    <td>Bidirectional</td>
                    <td>N/A</td>
                    <td>Dedicated channels</td>
                </tr>
                <tr>
                    <td><code>BroadcastChannel</code></td>
                    <td>All contexts</td>
                    <td>Many-to-many</td>
                    <td>Yes</td>
                    <td>Cross-context pub/sub</td>
                </tr>
                <tr>
                    <td><code>SharedArrayBuffer</code></td>
                    <td>Workers</td>
                    <td>Shared memory</td>
                    <td>Yes (requires headers)</td>
                    <td>High-performance data sharing</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2>7. Complete Example: Multi-Worker Architecture</h2>

    <div class="collapsible critical">
        <div class="collapsible-header">
            <span><span class="arrow">▶</span>Real-World: Image Processing Pipeline</span>
        </div>
        <div class="collapsible-content">
            <div class="diagram-container">
                <div class="diagram-title">Multi-Worker Image Processing Architecture</div>
                <div class="mermaid">
graph TB
    UI[UI Thread<br/>main.js]
    BC[BroadcastChannel<br/>'progress']

    W1[Decode Worker<br/>decode.js]
    W2[Filter Worker<br/>filter.js]
    W3[Compress Worker<br/>compress.js]

    UI -->|ImageBitmap| W1
    W1 -->|ImageData| W2
    W2 -->|ImageData| W3
    W3 -->|Blob| UI

    W1 -.->|progress| BC
    W2 -.->|progress| BC
    W3 -.->|progress| BC
    BC -.->|subscribe| UI

    style UI fill:#FFD700,stroke:#8B0000,stroke-width:2px
    style BC fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style W1 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style W2 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
    style W3 fill:#F5F5DC,stroke:#8B0000,stroke-width:2px
                </div>
            </div>

            <pre><code>// main.js - Orchestrator
const decodeWorker = new Worker('decode.js');
const filterWorker = new Worker('filter.js');
const compressWorker = new Worker('compress.js');
const progress = new BroadcastChannel('progress');

progress.onmessage = (e) => {
    updateProgressBar(e.data.stage, e.data.percent);
};

async function processImage(file) {
    // 1. Decode in worker 1
    const decoded = await new Promise((resolve) => {
        decodeWorker.onmessage = (e) => resolve(e.data);
        decodeWorker.postMessage({ file });
    });

    // 2. Apply filter in worker 2
    const filtered = await new Promise((resolve) => {
        filterWorker.onmessage = (e) => resolve(e.data);
        filterWorker.postMessage(decoded, [decoded.buffer]);
    });

    // 3. Compress in worker 3
    const compressed = await new Promise((resolve) => {
        compressWorker.onmessage = (e) => resolve(e.data);
        compressWorker.postMessage(filtered, [filtered.buffer]);
    });

    return compressed;
}

// decode.js - Worker 1
const progress = new BroadcastChannel('progress');

self.onmessage = async (e) => {
    const bitmap = await createImageBitmap(e.data.file);
    const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(bitmap, 0, 0);

    const imageData = ctx.getImageData(0, 0, bitmap.width, bitmap.height);

    progress.postMessage({ stage: 'decode', percent: 100 });
    self.postMessage(imageData, [imageData.data.buffer]);
};</code></pre>
        </div>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#FFD700',
                primaryTextColor: '#1a1a1a',
                primaryBorderColor: '#8B0000',
                lineColor: '#8B0000',
                secondaryColor: '#F5F5DC',
                tertiaryColor: '#fff'
            }
        });

        // Collapsible functionality
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                const collapsible = header.parentElement;
                collapsible.classList.toggle('open');
            });
        });

        // Expand/Collapse all
        function expandAll() {
            document.querySelectorAll('.collapsible').forEach(c => c.classList.add('open'));
        }

        function collapseAll() {
            document.querySelectorAll('.collapsible').forEach(c => c.classList.remove('open'));
        }
    </script>
</body>
</html>