<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turn-Based Interaction in Nabokov Cards</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFF8DC;
            --ink-black: #2C2C2C;
            --level-1: #8B0000;
            --level-2: #B71C1C;
            --level-3: #666;
            --level-4: #888;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.2;
            font-size: 14px;
            width: 100vw;
            max-width: 100%;
        }

        .container {
            width: 100%;
            padding: 0;
            margin: 0;
        }

        h1 {
            font-size: 24px;
            font-weight: 900;
            margin: 4px 0;
            padding: 6px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 8px 0 4px 0;
            padding: 4px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 4px 0 2px 8px;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 12px;
            font-weight: 500;
            margin: 2px 0 1px 16px;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 8px;
            margin: 8px 0;
            border-radius: 3px;
        }

        .important-always-visible h2 {
            color: var(--chinese-red);
            margin-top: 0;
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 8px 0;
        }

        .collapsible {
            margin: 4px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 6px 8px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 8px;
            margin-left: 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 5000px;
            padding: 8px;
        }

        .collapsible.critical .collapsible-header {
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.08);
            font-weight: 700;
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.1);
            padding: 2px 4px;
            margin: 1px 0;
            font-size: 12px;
            line-height: 1.1;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        pre {
            padding: 4px 6px;
            margin: 2px 0;
            overflow-x: auto;
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin-left: 8px;
        }

        .dense-list li {
            padding: 2px 0 2px 12px;
            border-left: 2px solid transparent;
            position: relative;
        }

        .dense-list li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 2px;
            padding: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 8px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 4px 0;
            font-size: 12px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 2px 4px;
            text-align: left;
            line-height: 1.1;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Turn-Based Interaction in Nabokov Cards</h1>

        <div class="important-always-visible">
            <h2>Current Implementation Status</h2>
            <p><strong>‚úì Already Implemented:</strong> Nabokov already has a full turn-based interaction system with persistent conversation history, streaming responses, and dual UI modes (modal and floating window).</p>
        </div>

        <div class="divider"></div>

        <h2>Existing Architecture</h2>

        <div class="two-column-layout">
            <div class="collapsible critical open">
                <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                    <strong>Data Layer</strong>
                    <span class="arrow">‚ñ∏</span>
                </div>
                <div class="collapsible-content">
                    <h4>Card Type Definition</h4>
                    <pre><code>interface Card {
  conversation?: Message[];
  // ... other fields
}

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  streaming?: boolean;
  parentId?: string;  // Thread support
}</code></pre>
                    <p><strong>Storage:</strong> Conversations persist to <code>chrome.storage.local</code> as part of card data.</p>
                </div>
            </div>

            <div class="collapsible critical open">
                <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                    <strong>Service Layer</strong>
                    <span class="arrow">‚ñ∏</span>
                </div>
                <div class="collapsible-content">
                    <h4>ChatService (src/services/chatService.ts)</h4>
                    <ul class="dense-list">
                        <li><strong>sendMessage()</strong>: AsyncGenerator for streaming</li>
                        <li><strong>stopStreaming()</strong>: Abort ongoing requests</li>
                        <li><strong>getConversation()</strong>: Retrieve history</li>
                        <li><strong>clearConversation()</strong>: Reset thread</li>
                        <li><strong>Auto-save</strong>: Persists to card after each turn</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>UI Components</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <div class="two-column-layout">
                    <div class="card">
                        <h4>ChatModal</h4>
                        <p><strong>Location:</strong> src/canvas/ChatModal.tsx</p>
                        <ul class="dense-list">
                            <li>Full-screen modal dialog</li>
                            <li>Chinese aesthetic styling</li>
                            <li>Streaming with typing indicator</li>
                            <li>Keyboard shortcuts (Enter, Esc)</li>
                            <li>Empty state guidance</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h4>FloatingWindowChat</h4>
                        <p><strong>Location:</strong> src/components/FloatingWindowChat.tsx</p>
                        <ul class="dense-list">
                            <li>Compact chat interface</li>
                            <li>Embedded in floating windows</li>
                            <li>Stop/Clear controls</li>
                            <li>Auto-scroll to latest</li>
                            <li>Disabled state during streaming</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Relevance Feedback Analogy (IR ‚Üí Nabokov)</h2>

        <div class="card priority">
            <p><strong>Your Question:</strong> "IR literature shows relevance feedback is powerful‚Äîasking users to judge returned objects and revising queries. How can Nabokov provide turn-based interaction?"</p>
            <p><strong>Answer:</strong> Nabokov's conversation system <em>already implements</em> relevance feedback patterns, where each turn refines understanding through iterative dialogue.</p>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Mapping IR Concepts to Nabokov</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <table>
                    <thead>
                        <tr>
                            <th>IR Concept</th>
                            <th>Nabokov Implementation</th>
                            <th>Files</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Initial Query</strong></td>
                            <td>First user message in conversation</td>
                            <td>ChatService.sendMessage()</td>
                        </tr>
                        <tr>
                            <td><strong>Retrieved Objects</strong></td>
                            <td>Card content + conversation history</td>
                            <td>Card.content, Card.conversation</td>
                        </tr>
                        <tr>
                            <td><strong>Relevance Judgments</strong></td>
                            <td>User follow-up questions/corrections</td>
                            <td>Message.role='user'</td>
                        </tr>
                        <tr>
                            <td><strong>Query Revision</strong></td>
                            <td>LLM adjusts response based on context</td>
                            <td>mockClaudeAPI streaming</td>
                        </tr>
                        <tr>
                            <td><strong>Iteration</strong></td>
                            <td>Multi-turn conversation with parentId links</td>
                            <td>Message.parentId threading</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="divider"></div>

        <h2>How Users Invoke Turn-Based Interaction</h2>

        <div class="two-column-layout">
            <div class="collapsible open">
                <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                    <strong>Method 1: Chat Modal</strong>
                    <span class="arrow">‚ñ∏</span>
                </div>
                <div class="collapsible-content">
                    <ul class="dense-list">
                        <li>User clicks card on canvas</li>
                        <li>Opens ChatModal dialog</li>
                        <li>Full conversation history displayed</li>
                        <li>Type message ‚Üí Enter to send</li>
                        <li>Streaming response appears live</li>
                        <li>Auto-saved to card.conversation</li>
                    </ul>
                </div>
            </div>

            <div class="collapsible open">
                <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                    <strong>Method 2: Floating Window</strong>
                    <span class="arrow">‚ñ∏</span>
                </div>
                <div class="collapsible-content">
                    <ul class="dense-list">
                        <li>Card opens in floating window</li>
                        <li>Chat UI embedded at bottom</li>
                        <li>Side-by-side: content + conversation</li>
                        <li>Stop button during streaming</li>
                        <li>Clear conversation option</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Enhancement Opportunities (Future Work)</h2>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>1. Explicit Relevance Feedback Buttons</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Concept:</strong> Add üëç üëé buttons to each assistant message.</p>
                <pre><code>interface Message {
  relevanceFeedback?: 'positive' | 'negative' | null;
}

// UI: After each assistant message
&lt;MessageContent&gt;
  {message.content}
  &lt;FeedbackButtons&gt;
    &lt;button onClick={() => provideFeedback(message.id, 'positive')}&gt;üëç&lt;/button&gt;
    &lt;button onClick={() => provideFeedback(message.id, 'negative')}&gt;üëé&lt;/button&gt;
  &lt;/FeedbackButtons&gt;
&lt;/MessageContent&gt;</code></pre>
                <p><strong>Benefit:</strong> Track which responses are useful for training/refinement.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>2. Multi-Card Context Queries</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Concept:</strong> Allow queries across multiple selected cards.</p>
                <pre><code>// User selects 3 cards ‚Üí Cmd+I (ask across cards)
const combinedContext = selectedCards
  .map(card => card.content)
  .join('\n\n---\n\n');

chatService.sendMessage(
  'combined-query-id',
  userQuestion,
  combinedContext
);</code></pre>
                <p><strong>Benefit:</strong> Relevance feedback across multiple information sources.</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>3. Suggested Follow-Up Questions</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Concept:</strong> LLM generates 3 suggested next questions after each response.</p>
                <pre><code>interface Message {
  suggestedFollowUps?: string[];
}

// After assistant response:
&lt;SuggestedQuestions&gt;
  {message.suggestedFollowUps?.map(q =>
    &lt;button onClick={() => askQuestion(q)}&gt;{q}&lt;/button&gt;
  )}
&lt;/SuggestedQuestions&gt;</code></pre>
                <p><strong>Benefit:</strong> Guides users toward productive refinement (like query expansion in IR).</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>4. Conversation Branching</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Concept:</strong> Allow users to revisit earlier messages and create alternate threads.</p>
                <pre><code>// UI: Click any message ‚Üí "Branch from here"
interface Message {
  parentId?: string;  // Already exists!
  childIds?: string[]; // Track branches
}

// Navigate between branches
const getBranches = (messageId: string) =>
  messages.filter(m => m.parentId === messageId);</code></pre>
                <p><strong>Benefit:</strong> Explore multiple relevance feedback paths (A/B test queries).</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>5. Card Generation from Conversation</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Status:</strong> <code>Card.generationContext</code> already exists!</p>
                <pre><code>// Already in Card type (CLAUDE.md shows this):
generationContext?: {
  sourceMessageId: string;
  userPrompt: string;
  timestamp: number;
}</code></pre>
                <p><strong>Enhancement:</strong> Add "Create card from this message" button to extract insights as new cards.</p>
                <pre><code>// After assistant response:
&lt;button onClick={() => createCardFromMessage(message)}&gt;
  Extract as Card
&lt;/button&gt;</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Implementation Checklist (If Adding New Features)</h2>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Minimal Turn-Based Enhancement</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <ul class="dense-list">
                    <li><strong>Step 1:</strong> Add feedback buttons to FloatingWindowChat/ChatModal</li>
                    <li><strong>Step 2:</strong> Extend Message type: <code>relevanceFeedback?: 'positive' | 'negative'</code></li>
                    <li><strong>Step 3:</strong> Update ChatService.addMessage() to store feedback</li>
                    <li><strong>Step 4:</strong> Pass feedback context to LLM in next turn</li>
                    <li><strong>Step 5:</strong> Visualize feedback in UI (highlight positive/negative messages)</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Code Reference Map</h2>

        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>File</th>
                    <th>Line Reference</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Message Type Definition</td>
                    <td>src/types/card.ts</td>
                    <td>9-16</td>
                </tr>
                <tr>
                    <td>ChatService Implementation</td>
                    <td>src/services/chatService.ts</td>
                    <td>29-166</td>
                </tr>
                <tr>
                    <td>Streaming Response Logic</td>
                    <td>src/services/chatService.ts</td>
                    <td>40-96</td>
                </tr>
                <tr>
                    <td>Conversation Persistence</td>
                    <td>src/services/chatService.ts</td>
                    <td>154-165</td>
                </tr>
                <tr>
                    <td>Modal Chat UI</td>
                    <td>src/canvas/ChatModal.tsx</td>
                    <td>407-648</td>
                </tr>
                <tr>
                    <td>Floating Window Chat UI</td>
                    <td>src/components/FloatingWindowChat.tsx</td>
                    <td>25-115</td>
                </tr>
                <tr>
                    <td>Message Rendering</td>
                    <td>src/canvas/ChatModal.tsx</td>
                    <td>598-607</td>
                </tr>
                <tr>
                    <td>Input Handling</td>
                    <td>src/canvas/ChatModal.tsx</td>
                    <td>456-537</td>
                </tr>
            </tbody>
        </table>

        <div class="divider"></div>

        <div class="card priority">
            <h3>Summary</h3>
            <p><strong>Current State:</strong> Nabokov has a complete turn-based interaction system with persistent conversations, streaming responses, and dual UI modes.</p>
            <p><strong>IR Analogy:</strong> The conversation system implements relevance feedback through iterative dialogue, where user follow-ups refine the LLM's understanding (analogous to query revision).</p>
            <p><strong>Next Steps:</strong> Consider adding explicit feedback buttons (üëçüëé), multi-card queries, suggested follow-ups, or conversation branching to enhance the relevance feedback loop.</p>
        </div>
    </div>

    <script>
        // Auto-open all collapsibles on load for full information visibility
        document.addEventListener('DOMContentLoaded', () => {
            const critical = document.querySelectorAll('.collapsible.critical');
            critical.forEach(el => el.classList.add('open'));
        });
    </script>
</body>
</html>