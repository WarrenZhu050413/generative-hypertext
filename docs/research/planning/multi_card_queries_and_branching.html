<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Card Context Queries & Conversation Branching in Nabokov</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFF8DC;
            --ink-black: #2C2C2C;
            --level-1: #8B0000;
            --level-2: #B71C1C;
            --level-3: #666;
            --level-4: #888;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.2;
            font-size: 14px;
            width: 100vw;
            max-width: 100%;
        }

        .container {
            width: 100%;
            padding: 0;
            margin: 0;
        }

        h1 {
            font-size: 24px;
            font-weight: 900;
            margin: 4px 0;
            padding: 6px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 8px 0 4px 0;
            padding: 4px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 4px 0 2px 8px;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 12px;
            font-weight: 500;
            margin: 2px 0 1px 16px;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 8px;
            margin: 8px 0;
            border-radius: 3px;
        }

        .important-always-visible h2 {
            color: var(--chinese-red);
            margin-top: 0;
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 8px 0;
        }

        .collapsible {
            margin: 4px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 6px 8px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 8px;
            margin-left: 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 8000px;
            padding: 8px;
        }

        .collapsible.critical .collapsible-header {
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.08);
            font-weight: 700;
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.1);
            padding: 2px 4px;
            margin: 1px 0;
            font-size: 12px;
            line-height: 1.1;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        pre {
            padding: 4px 6px;
            margin: 2px 0;
            overflow-x: auto;
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin-left: 8px;
        }

        .dense-list li {
            padding: 2px 0 2px 12px;
            border-left: 2px solid transparent;
            position: relative;
        }

        .dense-list li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 2px;
            padding: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 8px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 4px 0;
            font-size: 12px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 2px 4px;
            text-align: left;
            line-height: 1.1;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }

        .workflow {
            background: rgba(255, 215, 0, 0.05);
            border-left: 3px solid var(--chinese-gold);
            padding: 8px;
            margin: 4px 0;
        }

        .workflow-step {
            margin: 4px 0;
            padding-left: 16px;
            position: relative;
        }

        .workflow-step:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Card Context Queries & Conversation Branching</h1>

        <div class="important-always-visible">
            <h2>Quick Summary</h2>
            <p><strong>Multi-Card Context Queries:</strong> Ask questions across multiple selected cards to synthesize information from different sources.</p>
            <p><strong>Conversation Branching:</strong> Explore alternate conversation paths by forking from any message in the chat history.</p>
            <p><strong>Status:</strong> React Flow already provides selection handling. Implementation requires: selection tracking, context merging, and UI updates.</p>
        </div>

        <div class="divider"></div>

        <h2>Feature 1: Multi-Card Context Queries</h2>

        <div class="card priority">
            <h3>Core Concept</h3>
            <p>Enable users to select 2+ cards on the canvas and ask questions that span all their content, allowing synthesis across multiple information sources.</p>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Current Foundation</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <h4>React Flow Selection (Already Available)</h4>
                <pre><code>// React Flow provides built-in selection via:
// 1. Click + drag box selection
// 2. Cmd/Ctrl + click for multi-select
// 3. onSelectionChange callback

// Current Canvas.tsx doesn't track this yet
// Need to add:
const [selectedNodes, setSelectedNodes] = useState&lt;Node[]&gt;([]);

&lt;ReactFlow
  onSelectionChange={(params) => {
    setSelectedNodes(params.nodes);
  }}
  // ... other props
/&gt;</code></pre>
            </div>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Implementation Steps</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <div class="workflow">
                    <div class="workflow-step"><strong>Step 1:</strong> Track selected nodes in Canvas.tsx</div>
                    <div class="workflow-step"><strong>Step 2:</strong> Show "Ask across N cards" button when multiple selected</div>
                    <div class="workflow-step"><strong>Step 3:</strong> Merge card contents into combined context</div>
                    <div class="workflow-step"><strong>Step 4:</strong> Create multi-card chat session</div>
                    <div class="workflow-step"><strong>Step 5:</strong> Display which cards are in context</div>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Code Implementation: Multi-Card Queries</h2>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 1: Add Selection Tracking to Canvas.tsx</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// In Canvas.tsx, add state and handler

function CanvasInner() {
  // ... existing state
  const [selectedNodes, setSelectedNodes] = useState&lt;Node[]&gt;([]);
  const [showMultiCardChat, setShowMultiCardChat] = useState(false);

  // Handle selection changes
  const handleSelectionChange = useCallback((params: {
    nodes: Node[];
    edges: Edge[];
  }) => {
    setSelectedNodes(params.nodes);
    console.log('[Canvas] Selected nodes:', params.nodes.length);
  }, []);

  return (
    &lt;ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onSelectionChange={handleSelectionChange}
      // Enable multi-selection
      multiSelectionKeyCode="Control"
      // ... other props
    &gt;
      {/* ... existing children */}
    &lt;/ReactFlow&gt;
  );
}</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 2: Multi-Card Query Button Component</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// New component: MultiCardQueryButton.tsx
interface MultiCardQueryButtonProps {
  selectedCards: Card[];
  onOpenChat: (cards: Card[]) => void;
}

export const MultiCardQueryButton: React.FC&lt;MultiCardQueryButtonProps&gt; = ({
  selectedCards,
  onOpenChat,
}) => {
  if (selectedCards.length < 2) return null;

  return (
    &lt;div style={{
      position: 'fixed',
      bottom: 20,
      right: 20,
      zIndex: 1000,
    }}&gt;
      &lt;button
        onClick={() => onOpenChat(selectedCards)}
        style={{
          background: 'linear-gradient(135deg, #8B0000, #CD5C5C)',
          color: '#FFF8DC',
          border: '2px solid #FFD700',
          padding: '12px 20px',
          borderRadius: '8px',
          fontSize: '14px',
          fontWeight: 600,
          cursor: 'pointer',
          boxShadow: '0 4px 12px rgba(139, 0, 0, 0.3)',
        }}
      &gt;
        üí¨ Ask across {selectedCards.length} cards
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 3: Merge Card Contexts</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// Utils: multiCardContext.ts

/**
 * Merge multiple cards into a single context string
 */
export function mergeCardContexts(cards: Card[]): string {
  return cards
    .map((card, index) => {
      const header = `[Card ${index + 1}: ${card.metadata.title}]`;
      const source = `Source: ${card.metadata.url}`;
      const content = card.content || '[No content]';
      const tags = card.tags.length > 0
        ? `Tags: ${card.tags.join(', ')}`
        : '';

      return [header, source, tags, content, '---'].join('\n');
    })
    .join('\n\n');
}

/**
 * Create metadata summary for multi-card context
 */
export function createMultiCardSummary(cards: Card[]): string {
  const domains = [...new Set(cards.map(c => c.metadata.domain))];
  const tags = [...new Set(cards.flatMap(c => c.tags))];

  return [
    `Analyzing ${cards.length} cards:`,
    `Domains: ${domains.join(', ')}`,
    `Tags: ${tags.join(', ')}`,
    '',
  ].join('\n');
}</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 4: Multi-Card Chat Modal</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// Extend ChatModal to support multi-card mode

interface MultiCardChatModalProps {
  cards: Card[];  // Array instead of single card
  isOpen: boolean;
  onClose: () => void;
}

export const MultiCardChatModal: React.FC&lt;MultiCardChatModalProps&gt; = ({
  cards,
  isOpen,
  onClose,
}) => {
  const [messages, setMessages] = useState&lt;Message[]&gt;([]);
  const [input, setInput] = useState('');

  // Merge contexts on mount
  const combinedContext = useMemo(() =>
    mergeCardContexts(cards),
    [cards]
  );

  const handleSend = async () => {
    // Send with combined context
    const userMessage: Message = {
      id: generateId(),
      role: 'user',
      content: input.trim(),
      timestamp: Date.now(),
    };

    setMessages(prev => [...prev, userMessage]);

    // Stream response with multi-card context
    const stream = chatService.sendMessage(
      'multi-card-session',
      input.trim(),
      combinedContext
    );

    // ... handle streaming
  };

  return (
    &lt;ModalDialog&gt;
      &lt;Header&gt;
        &lt;div&gt;
          üí¨ Multi-Card Query ({cards.length} cards)
        &lt;/div&gt;
        &lt;CardList&gt;
          {cards.map(card => (
            &lt;CardChip key={card.id}&gt;
              {card.metadata.title}
            &lt;/CardChip&gt;
          ))}
        &lt;/CardList&gt;
      &lt;/Header&gt;
      {/* ... rest of modal */}
    &lt;/ModalDialog&gt;
  );
};</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 5: Integration in Canvas.tsx</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// In Canvas.tsx

function CanvasInner() {
  const [selectedNodes, setSelectedNodes] = useState&lt;Node[]&gt;([]);
  const [multiCardChatOpen, setMultiCardChatOpen] = useState(false);
  const [multiCardSelection, setMultiCardSelection] = useState&lt;Card[]&gt;([]);

  const handleOpenMultiCardChat = useCallback((cards: Card[]) => {
    setMultiCardSelection(cards);
    setMultiCardChatOpen(true);
  }, []);

  // Extract cards from selected nodes
  const selectedCards = useMemo(() =>
    selectedNodes.map(node => node.data.card as Card),
    [selectedNodes]
  );

  return (
    &lt;&gt;
      &lt;ReactFlow
        onSelectionChange={(params) => setSelectedNodes(params.nodes)}
        // ... other props
      /&gt;

      {/* Multi-card query button */}
      &lt;MultiCardQueryButton
        selectedCards={selectedCards}
        onOpenChat={handleOpenMultiCardChat}
      /&gt;

      {/* Multi-card chat modal */}
      &lt;MultiCardChatModal
        cards={multiCardSelection}
        isOpen={multiCardChatOpen}
        onClose={() => setMultiCardChatOpen(false)}
      /&gt;
    &lt;/&gt;
  );
}</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Feature 2: Conversation Branching</h2>

        <div class="card priority">
            <h3>Core Concept</h3>
            <p>Allow users to click any message in a conversation and create an alternate thread from that point, enabling exploration of different reasoning paths.</p>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Current Foundation</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <h4>Message Structure Already Supports Branching!</h4>
                <pre><code>// From src/types/card.ts
interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  streaming?: boolean;
  parentId?: string;  // ‚Üê ALREADY EXISTS for threading!
}

// Card.conversation is Message[]
// parentId links messages together
// Just need to track branches and UI to navigate them</code></pre>
            </div>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Branching Data Model</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// Extend Message type to track branches

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  streaming?: boolean;
  parentId?: string;     // Existing: parent message
  childIds?: string[];   // NEW: child messages (branches)
  branchMetadata?: {     // NEW: branch info
    branchName?: string;
    branchedFrom: string;  // Original parent message ID
    branchTimestamp: number;
  };
}

// Conversation tree structure
interface ConversationTree {
  messages: Map&lt;string, Message&gt;;  // All messages by ID
  roots: string[];                 // Root message IDs
  currentBranch: string[];         // Active branch path (message IDs)
  branches: Map&lt;string, string[]&gt;; // Parent ID ‚Üí child IDs
}</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Code Implementation: Conversation Branching</h2>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 1: Conversation Tree Manager</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// New service: conversationTree.ts

export class ConversationTree {
  private messages: Map&lt;string, Message&gt; = new Map();
  private branches: Map&lt;string, string[]&gt; = new Map();
  private currentPath: string[] = [];

  constructor(messages: Message[]) {
    this.loadMessages(messages);
  }

  private loadMessages(messages: Message[]) {
    messages.forEach(msg => {
      this.messages.set(msg.id, msg);

      if (msg.parentId) {
        const siblings = this.branches.get(msg.parentId) || [];
        siblings.push(msg.id);
        this.branches.set(msg.parentId, siblings);
      }
    });
  }

  /**
   * Get all branches from a given message
   */
  getBranches(messageId: string): Message[] {
    const childIds = this.branches.get(messageId) || [];
    return childIds
      .map(id => this.messages.get(id))
      .filter(Boolean) as Message[];
  }

  /**
   * Get the active conversation path
   */
  getCurrentBranch(): Message[] {
    return this.currentPath
      .map(id => this.messages.get(id))
      .filter(Boolean) as Message[];
  }

  /**
   * Switch to a different branch
   */
  switchToBranch(messageId: string): Message[] {
    const path: string[] = [];
    let current = this.messages.get(messageId);

    while (current) {
      path.unshift(current.id);
      current = current.parentId
        ? this.messages.get(current.parentId)
        : undefined;
    }

    this.currentPath = path;
    return this.getCurrentBranch();
  }

  /**
   * Create a new branch from a message
   */
  createBranch(
    fromMessageId: string,
    newUserMessage: string
  ): Message {
    const userMsg: Message = {
      id: generateId(),
      role: 'user',
      content: newUserMessage,
      timestamp: Date.now(),
      parentId: fromMessageId,
      branchMetadata: {
        branchedFrom: fromMessageId,
        branchTimestamp: Date.now(),
      },
    };

    this.messages.set(userMsg.id, userMsg);

    const siblings = this.branches.get(fromMessageId) || [];
    siblings.push(userMsg.id);
    this.branches.set(fromMessageId, siblings);

    return userMsg;
  }

  /**
   * Flatten tree back to array for storage
   */
  toArray(): Message[] {
    return Array.from(this.messages.values());
  }
}</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 2: Branch Navigation UI</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// New component: BranchNavigator.tsx

interface BranchNavigatorProps {
  message: Message;
  branches: Message[];
  currentBranchId: string;
  onSwitchBranch: (messageId: string) => void;
  onCreateBranch: (fromMessageId: string) => void;
}

export const BranchNavigator: React.FC&lt;BranchNavigatorProps&gt; = ({
  message,
  branches,
  currentBranchId,
  onSwitchBranch,
  onCreateBranch,
}) => {
  if (branches.length === 0) {
    return (
      &lt;button
        onClick={() => onCreateBranch(message.id)}
        style={{
          fontSize: '11px',
          padding: '2px 6px',
          background: 'rgba(139, 0, 0, 0.1)',
          border: '1px solid #8B0000',
          borderRadius: '4px',
          cursor: 'pointer',
          marginTop: '4px',
        }}
      &gt;
        üîÄ Branch from here
      &lt;/button&gt;
    );
  }

  return (
    &lt;div style={{ marginTop: '6px' }}&gt;
      &lt;div style={{ fontSize: '11px', color: '#666', marginBottom: '4px' }}&gt;
        {branches.length} branch{branches.length > 1 ? 'es' : ''}:
      &lt;/div&gt;
      {branches.map((branch, idx) => (
        &lt;button
          key={branch.id}
          onClick={() => onSwitchBranch(branch.id)}
          style={{
            fontSize: '11px',
            padding: '3px 8px',
            background: branch.id === currentBranchId
              ? 'linear-gradient(135deg, #8B0000, #CD5C5C)'
              : 'rgba(255, 215, 0, 0.1)',
            color: branch.id === currentBranchId ? 'white' : '#333',
            border: `1px solid ${branch.id === currentBranchId ? '#FFD700' : '#ddd'}`,
            borderRadius: '4px',
            cursor: 'pointer',
            marginRight: '4px',
          }}
        &gt;
          Branch {idx + 1}
        &lt;/button&gt;
      ))}
      &lt;button
        onClick={() => onCreateBranch(message.id)}
        style={{
          fontSize: '11px',
          padding: '3px 8px',
          background: 'white',
          border: '1px dashed #8B0000',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      &gt;
        + New branch
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Step 3: Update ChatModal with Branching</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// Update ChatModal.tsx to support branching

export const ChatModal: React.FC&lt;ChatModalProps&gt; = ({
  card,
  isOpen,
  onClose,
  onUpdateCard,
}) => {
  const [conversationTree, setConversationTree] =
    useState&lt;ConversationTree | null&gt;(null);
  const [currentBranch, setCurrentBranch] = useState&lt;Message[]&gt;([]);
  const [branchingFrom, setBranchingFrom] = useState&lt;string | null&gt;(null);

  // Initialize tree from card conversation
  useEffect(() => {
    if (card?.conversation) {
      const tree = new ConversationTree(card.conversation);
      setConversationTree(tree);
      setCurrentBranch(tree.getCurrentBranch());
    }
  }, [card]);

  const handleSwitchBranch = useCallback((messageId: string) => {
    if (!conversationTree) return;

    const newBranch = conversationTree.switchToBranch(messageId);
    setCurrentBranch(newBranch);
  }, [conversationTree]);

  const handleCreateBranch = useCallback((fromMessageId: string) => {
    setBranchingFrom(fromMessageId);
    // Show input prompt for new branch
  }, []);

  const handleSendBranchMessage = useCallback(async (
    fromMessageId: string,
    message: string
  ) => {
    if (!conversationTree || !card) return;

    // Create branch
    const userMsg = conversationTree.createBranch(fromMessageId, message);

    // Get context up to branch point
    const branchContext = conversationTree
      .getCurrentBranch()
      .map(m => `${m.role}: ${m.content}`)
      .join('\n\n');

    // Stream response
    // ... (similar to existing handleSend)

    // Save updated tree
    onUpdateCard(card.id, {
      conversation: conversationTree.toArray(),
    });

    setBranchingFrom(null);
  }, [conversationTree, card, onUpdateCard]);

  return (
    &lt;ModalDialog&gt;
      &lt;MessageList&gt;
        {currentBranch.map(message => {
          const branches = conversationTree?.getBranches(message.id) || [];

          return (
            &lt;div key={message.id}&gt;
              &lt;MessageBubble role={message.role}&gt;
                &lt;MessageContent role={message.role}&gt;
                  {message.content}
                &lt;/MessageContent&gt;
              &lt;/MessageBubble&gt;

              {/* Branch navigator */}
              &lt;BranchNavigator
                message={message}
                branches={branches}
                currentBranchId={currentBranch[currentBranch.length - 1]?.id}
                onSwitchBranch={handleSwitchBranch}
                onCreateBranch={handleCreateBranch}
              /&gt;
            &lt;/div&gt;
          );
        })}
      &lt;/MessageList&gt;

      {/* Branch input prompt */}
      {branchingFrom && (
        &lt;BranchInputPrompt
          onSubmit={(msg) => handleSendBranchMessage(branchingFrom, msg)}
          onCancel={() => setBranchingFrom(null)}
        /&gt;
      )}
    &lt;/ModalDialog&gt;
  );
};</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>User Experience Workflows</h2>

        <div class="two-column-layout">
            <div class="collapsible open">
                <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                    <strong>Multi-Card Query Workflow</strong>
                    <span class="arrow">‚ñ∏</span>
                </div>
                <div class="collapsible-content">
                    <div class="workflow">
                        <div class="workflow-step">User researches topic, clips 5 articles to canvas</div>
                        <div class="workflow-step">Selects all 5 cards (Cmd+drag box selection)</div>
                        <div class="workflow-step">Clicks "Ask across 5 cards" button</div>
                        <div class="workflow-step">Types: "What are the common themes?"</div>
                        <div class="workflow-step">LLM analyzes all 5 articles, synthesizes response</div>
                        <div class="workflow-step">User follows up: "Which source disagrees?"</div>
                        <div class="workflow-step">LLM references specific cards in answer</div>
                    </div>
                </div>
            </div>

            <div class="collapsible open">
                <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                    <strong>Conversation Branching Workflow</strong>
                    <span class="arrow">‚ñ∏</span>
                </div>
                <div class="collapsible-content">
                    <div class="workflow">
                        <div class="workflow-step">User asks card: "Explain this concept"</div>
                        <div class="workflow-step">LLM provides technical explanation</div>
                        <div class="workflow-step">User clicks message ‚Üí "Branch from here"</div>
                        <div class="workflow-step">Branch 1: "Explain with analogies instead"</div>
                        <div class="workflow-step">Branch 2: "Show me the code implementation"</div>
                        <div class="workflow-step">User switches between branches to compare</div>
                        <div class="workflow-step">Each branch builds on original context</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Advanced Features</h2>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Branch Visualization Tree</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// Visual tree diagram showing all branches
// Use D3.js or React Flow for rendering

&lt;ConversationTreeView&gt;
  Root
   ‚îú‚îÄ User: "Explain X"
   ‚îú‚îÄ Assistant: "X is..."
   ‚îÇ   ‚îú‚îÄ [Branch 1] User: "More detail?"
   ‚îÇ   ‚îÇ   ‚îî‚îÄ Assistant: "Here's detail..."
   ‚îÇ   ‚îî‚îÄ [Branch 2] User: "Show examples?"
   ‚îÇ       ‚îî‚îÄ Assistant: "Example 1..."
&lt;/ConversationTreeView&gt;</code></pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Multi-Card + Branching Combined</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Use Case:</strong> Start with multi-card query, then branch to explore different synthesis angles.</p>
                <div class="workflow">
                    <div class="workflow-step">Select 3 research papers on same topic</div>
                    <div class="workflow-step">Ask: "Compare methodologies"</div>
                    <div class="workflow-step">Branch 1: "Which has better results?"</div>
                    <div class="workflow-step">Branch 2: "What are limitations of each?"</div>
                    <div class="workflow-step">Branch 3: "How could they be combined?"</div>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Branch Merging & Export</strong>
                <span class="arrow">‚ñ∏</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// After exploring branches, merge insights

const mergeBranches = (branchIds: string[]): Message => {
  const branches = branchIds.map(id => tree.getBranch(id));

  return {
    id: generateId(),
    role: 'user',
    content: `Synthesize insights from these ${branches.length} branches`,
    // Attach all branch contents as context
  };
};

// Or export branch as new card
const exportBranchAsCard = async (branchId: string) => {
  const branch = tree.getBranch(branchId);
  const content = branch.map(m => m.content).join('\n\n');

  const newCard: Card = {
    id: generateId(),
    content,
    cardType: 'generated',
    parentCardId: originalCard.id,
    // ...
  };

  await saveCard(newCard);
};</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Implementation Checklist</h2>

        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Component</th>
                    <th>Priority</th>
                    <th>Complexity</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Selection tracking</td>
                    <td>Canvas.tsx</td>
                    <td>üî¥ Critical</td>
                    <td>Low</td>
                </tr>
                <tr>
                    <td>Multi-card button</td>
                    <td>MultiCardQueryButton.tsx</td>
                    <td>üî¥ Critical</td>
                    <td>Low</td>
                </tr>
                <tr>
                    <td>Context merging</td>
                    <td>multiCardContext.ts</td>
                    <td>üî¥ Critical</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Multi-card chat modal</td>
                    <td>MultiCardChatModal.tsx</td>
                    <td>üü° High</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Conversation tree manager</td>
                    <td>conversationTree.ts</td>
                    <td>üî¥ Critical</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Branch navigator UI</td>
                    <td>BranchNavigator.tsx</td>
                    <td>üü° High</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Update ChatModal</td>
                    <td>ChatModal.tsx</td>
                    <td>üî¥ Critical</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Tree visualization</td>
                    <td>ConversationTreeView.tsx</td>
                    <td>üü¢ Nice-to-have</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Branch export as card</td>
                    <td>branchExport.ts</td>
                    <td>üü¢ Nice-to-have</td>
                    <td>Low</td>
                </tr>
            </tbody>
        </table>

        <div class="divider"></div>

        <div class="card priority">
            <h3>Key Insights</h3>
            <ul class="dense-list">
                <li><strong>React Flow already provides selection:</strong> Just need to hook into onSelectionChange</li>
                <li><strong>Message.parentId already exists:</strong> Foundation for branching is there</li>
                <li><strong>Both features are IR relevance feedback:</strong> Multi-card = cross-source feedback, Branching = iterative refinement</li>
                <li><strong>Combine them:</strong> Start with multi-card synthesis, branch to explore different angles</li>
                <li><strong>Storage is simple:</strong> Just flatten conversation tree back to Message[] array</li>
            </ul>
        </div>
    </div>

    <script>
        // Auto-open critical collapsibles
        document.addEventListener('DOMContentLoaded', () => {
            const critical = document.querySelectorAll('.collapsible.critical');
            critical.forEach(el => el.classList.add('open'));
        });
    </script>
</body>
</html>