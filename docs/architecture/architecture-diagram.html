<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nabokov's Web - Architecture Diagram</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
            background: #fafafa;
        }
        h1 {
            color: #8B0000;
            border-bottom: 3px solid #FFD700;
            padding-bottom: 10px;
        }
        h2 {
            color: #333;
            margin-top: 40px;
            border-left: 4px solid #8B0000;
            padding-left: 12px;
        }
        .diagram {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .clean {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 16px;
            margin: 16px 0;
            border-radius: 4px;
        }
        .not-clean {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 16px;
            margin: 16px 0;
            border-radius: 4px;
        }
        .legend {
            background: #f5f5f5;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .legend h3 {
            margin-top: 0;
        }
        code {
            background: rgba(0,0,0,0.05);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
    </style>
</head>
<body>
    <h1>üï∏Ô∏è Nabokov's Web - Architecture Overview</h1>
    <p><strong>Chrome Extension for Web Clipping + Visual Canvas + AI Conversations</strong></p>

    <div class="legend">
        <h3>Legend</h3>
        <ul>
            <li><strong>Blue boxes</strong> = Chrome Extension contexts (separate execution environments)</li>
            <li><strong>Green boxes</strong> = Core services (singletons)</li>
            <li><strong>Yellow boxes</strong> = React components</li>
            <li><strong>Pink boxes</strong> = Storage layers</li>
            <li><strong>Solid lines</strong> = Direct function calls</li>
            <li><strong>Dashed lines</strong> = Message passing / events</li>
        </ul>
    </div>

    <h2>1. Overall System Architecture</h2>
    <div class="diagram">
        <pre class="mermaid">
graph TB
    subgraph "Chrome Extension Contexts"
        BG[Background Worker<br/>Service Worker]
        CS[Content Script<br/>Shadow DOM]
        CV[Canvas Page<br/>React App]
    end

    subgraph "Storage Layer"
        CLS[chrome.storage.local<br/>Cards, WindowStates]
        IDB[(IndexedDB<br/>Screenshots)]
    end

    subgraph "External"
        WEB[User's Webpage]
        USER((User))
    end

    USER -->|Cmd+Shift+E| BG
    USER -->|clicks element| CS
    USER -->|opens canvas| CV

    BG -.->|ACTIVATE_SELECTOR| CS
    BG -->|captureVisibleTab| WEB
    CS -->|saves Card| CLS
    CS -->|saves Screenshot| IDB
    CV -->|loads Cards| CLS
    CV -->|loads Screenshots| IDB

    CS -->|mounted in| WEB

    style BG fill:#bbdefb
    style CS fill:#bbdefb
    style CV fill:#bbdefb
    style CLS fill:#f8bbd0
    style IDB fill:#f8bbd0
    style WEB fill:#e0e0e0
    style USER fill:#fff9c4
        </pre>
    </div>

    <h2>2. Canvas Page Architecture (Detailed)</h2>
    <div class="diagram">
        <pre class="mermaid">
graph TB
    subgraph "Canvas.tsx (Root)"
        CANVAS[Canvas Component]
        RF[ReactFlow Canvas]
        TOOLBAR[Toolbar Component]
        FWC[Floating Windows Container]
    end

    subgraph "Core Services (Singletons)"
        WM[WindowManager<br/>manages all windows]
        CHAT[ChatService<br/>conversation history]
        MOCK[MockContentGenerator<br/>fake AI responses]
    end

    subgraph "Storage Utils"
        STOR[storage.ts<br/>getCards, saveCard]
        WSTORE[windowStorage.ts<br/>save/load WindowStates]
    end

    subgraph "Node Components"
        CN[CardNode.tsx<br/>card in canvas]
        FW[FloatingWindow.tsx<br/>draggable window]
        FWChat[FloatingWindowChat.tsx<br/>chat UI]
    end

    CANVAS --> RF
    CANVAS --> TOOLBAR
    CANVAS --> FWC

    RF --> CN
    FWC --> FW
    FW --> FWChat

    CN -->|openWindow| WM
    FW -->|sendMessage| CHAT
    FWChat -->|onSendMessage| FW

    CHAT -->|generate| MOCK
    CHAT -->|saveCard| STOR
    WM -->|debouncedSave| WSTORE

    CANVAS -->|subscribe| WM

    style CANVAS fill:#fff9c4
    style RF fill:#fff9c4
    style TOOLBAR fill:#fff9c4
    style CN fill:#fff9c4
    style FW fill:#fff9c4
    style FWChat fill:#fff9c4

    style WM fill:#c8e6c9
    style CHAT fill:#c8e6c9
    style MOCK fill:#c8e6c9

    style STOR fill:#f8bbd0
    style WSTORE fill:#f8bbd0
        </pre>
    </div>

    <h2>3. Data Flow: Element Capture</h2>
    <div class="diagram">
        <pre class="mermaid">
sequenceDiagram
    participant User
    participant BG as Background Worker
    participant CS as Content Script
    participant ES as ElementSelector
    participant Storage as chrome.storage.local
    participant IDB as IndexedDB

    User->>BG: Cmd+Shift+E
    BG->>CS: ACTIVATE_SELECTOR message
    CS->>ES: Mount in Shadow DOM
    ES->>User: Show hover overlay
    User->>ES: Click element
    ES->>ES: Extract HTML + sanitize
    ES->>BG: Request screenshot
    BG->>BG: captureVisibleTab()
    BG-->>ES: Screenshot dataURL
    ES->>ES: Compress screenshot
    ES->>ES: Create Card object
    ES->>Storage: saveCard(card)
    ES->>IDB: saveScreenshot(screenshot)
    ES->>User: Success feedback
    ES->>CS: Unmount
        </pre>
    </div>

    <h2>4. Data Flow: Floating Window Chat</h2>
    <div class="diagram">
        <pre class="mermaid">
sequenceDiagram
    participant User
    participant CN as CardNode
    participant WM as WindowManager
    participant CS as ChatService
    participant Mock as MockContentGenerator
    participant FW as FloatingWindow
    participant FWC as FloatingWindowChat

    User->>CN: Click "üóñ Open as Window"
    CN->>WM: openWindow(card)
    WM->>CS: loadConversation(cardId)
    CS->>Storage: getCardById(cardId)
    Storage-->>CS: Card with conversation
    WM->>WM: Create WindowState
    WM->>Canvas: notifyListeners()
    Canvas->>FW: Render with windowState
    FW->>FWC: Pass messages, callbacks

    User->>FWC: Type message + send
    FWC->>FW: onSendMessage(message)
    FW->>CS: sendMessage(cardId, message, cardContent)
    CS->>CS: Add user Message
    CS->>CS: Create assistant Message
    CS->>Mock: generate(message, content)

    loop Stream chunks
        Mock-->>CS: yield chunk
        CS->>CS: Append to assistant.content
        CS-->>FW: yield chunk
        FW->>WM: updateConversationMessages()
        WM->>Canvas: notifyListeners()
        Canvas->>FWC: Re-render with new messages
    end

    CS->>Storage: saveCard() with updated conversation
        </pre>
    </div>

    <h2>5. Type Hierarchy</h2>
    <div class="diagram">
        <pre class="mermaid">
classDiagram
    class Card {
        +string id
        +string content
        +ClipMetadata metadata
        +CardPosition position
        +CardSize size
        +boolean starred
        +string[] tags
        +Message[] conversation
        +string screenshotId
    }

    class Message {
        +string id
        +role: 'user'|'assistant'
        +string content
        +number timestamp
        +boolean streaming
        +string parentId
    }

    class WindowState {
        +string cardId
        +WindowPosition position
        +WindowSize size
        +boolean minimized
        +number zIndex
        +string chatInput
        +Message[] conversationMessages
        +number scrollPosition
        +boolean isStreaming
    }

    class SerializedWindowState {
        +string cardId
        +WindowPosition position
        +WindowSize size
        +boolean minimized
        +string chatInput
        +number scrollPosition
    }

    Card "1" --> "*" Message: conversation
    WindowState "1" --> "*" Message: conversationMessages
    WindowState ..> SerializedWindowState: serializes to
    WindowState --> Card: references by cardId

    style Card fill:#fff9c4
    style Message fill:#c8e6c9
    style WindowState fill:#bbdefb
    style SerializedWindowState fill:#f8bbd0
        </pre>
    </div>

    <h2>‚úÖ Clean Interfaces</h2>

    <div class="clean">
        <h3>1. Singleton Service Pattern (WindowManager, ChatService)</h3>
        <p><strong>Why it's clean:</strong></p>
        <ul>
            <li>Single source of truth for window states and conversations</li>
            <li>Subscriber pattern allows React components to react to state changes without prop drilling</li>
            <li>Clear separation: WindowManager handles UI state, ChatService handles conversation logic</li>
        </ul>
        <p><strong>Example:</strong></p>
        <code>windowManager.subscribe(() => setWindows(windowManager.getWindows()))</code>
    </div>

    <div class="clean">
        <h3>2. Type Safety (TypeScript interfaces)</h3>
        <p><strong>Why it's clean:</strong></p>
        <ul>
            <li>Central type definitions in <code>src/types/card.ts</code> and <code>src/types/window.ts</code></li>
            <li>No <code>any</code> types in critical paths (we just fixed the last one!)</li>
            <li>Clear contracts between components via typed props interfaces</li>
        </ul>
    </div>

    <div class="clean">
        <h3>3. Storage Abstraction (storage.ts, windowStorage.ts)</h3>
        <p><strong>Why it's clean:</strong></p>
        <ul>
            <li>Components don't directly call <code>chrome.storage.local</code> or IndexedDB</li>
            <li>Utility functions handle serialization, error handling, migration</li>
            <li>Easy to mock for testing</li>
        </ul>
    </div>

    <div class="clean">
        <h3>4. Shadow DOM Isolation (Content Script)</h3>
        <p><strong>Why it's clean:</strong></p>
        <ul>
            <li>ElementSelector styles can't be affected by host page CSS</li>
            <li>Extension doesn't pollute page's global namespace</li>
            <li>Clear boundary between extension and page content</li>
        </ul>
    </div>

    <h2>‚ö†Ô∏è Areas That Could Be Cleaner</h2>

    <div class="not-clean">
        <h3>1. WindowState vs SerializedWindowState Duplication</h3>
        <p><strong>Issue:</strong></p>
        <ul>
            <li>Two similar interfaces for the same conceptual entity</li>
            <li><code>conversationMessages</code> lives in WindowState at runtime but is saved separately in Card.conversation</li>
            <li>Risk of desynchronization between window messages and card conversation</li>
        </ul>
        <p><strong>Potential improvement:</strong></p>
        <ul>
            <li>Make WindowState always derive <code>conversationMessages</code> from Card.conversation (single source of truth)</li>
            <li>Or: Simplify to single interface with optional fields</li>
        </ul>
        <p><strong>Location:</strong> <code>src/types/window.ts:27-52</code></p>
    </div>

    <div class="not-clean">
        <h3>2. Multiple Type Definition Files</h3>
        <p><strong>Issue:</strong></p>
        <ul>
            <li><code>src/types/index.ts</code> has 300+ lines mixing storage, UI props, and old types</li>
            <li>Some component prop interfaces defined in components, others in types file</li>
            <li>Example: <code>FloatingWindowChatProps</code> is in component file, but <code>ChatModalProps</code> is in types/index.ts</li>
        </ul>
        <p><strong>Potential improvement:</strong></p>
        <ul>
            <li>Co-locate component prop types with components (React best practice)</li>
            <li>Keep only domain types (Card, Message, WindowState) in types/ folder</li>
            <li>Consider splitting types/index.ts into smaller files by domain</li>
        </ul>
        <p><strong>Location:</strong> <code>src/types/index.ts</code></p>
    </div>

    <div class="not-clean">
        <h3>3. Canvas Component Responsibility Overload</h3>
        <p><strong>Issue:</strong></p>
        <ul>
            <li>Canvas.tsx handles: keyboard shortcuts, window management, filters, ReactFlow state, feedback toasts</li>
            <li>562 lines with multiple concerns mixed together</li>
            <li>Keyboard shortcut handlers defined inline with component logic</li>
        </ul>
        <p><strong>Potential improvement:</strong></p>
        <ul>
            <li>Extract keyboard shortcuts to custom hook: <code>useKeyboardShortcuts()</code></li>
            <li>Extract window management to custom hook: <code>useFloatingWindows()</code></li>
            <li>Extract feedback toast to separate component</li>
        </ul>
        <p><strong>Location:</strong> <code>src/canvas/Canvas.tsx:33-403</code></p>
    </div>

    <div class="not-clean">
        <h3>4. Message Passing Between Extension Contexts</h3>
        <p><strong>Issue:</strong></p>
        <ul>
            <li>Background worker, content script, and canvas use <code>chrome.runtime.sendMessage()</code></li>
            <li>Message types defined as string union type, but no runtime validation</li>
            <li>Easy to send wrong payload type for a given message type</li>
        </ul>
        <p><strong>Potential improvement:</strong></p>
        <ul>
            <li>Create typed message helper functions: <code>sendActivateSelector()</code>, <code>sendScreenshotRequest()</code></li>
            <li>Runtime validation with Zod or similar</li>
            <li>Centralize message type definitions in single file</li>
        </ul>
        <p><strong>Location:</strong> <code>src/types/index.ts:238-261</code></p>
    </div>

    <div class="not-clean">
        <h3>5. MockContentGenerator Hardcoded Templates</h3>
        <p><strong>Issue:</strong></p>
        <ul>
            <li>Responses are template strings with hardcoded examples</li>
            <li>Doesn't actually use the <code>query</code> or <code>cardContent</code> parameters meaningfully</li>
            <li>Will be replaced anyway in Phase 5, but makes current testing less realistic</li>
        </ul>
        <p><strong>Potential improvement:</strong></p>
        <ul>
            <li>Use simple keyword matching on query to select different templates</li>
            <li>Extract snippets from cardContent and reference them in response</li>
            <li>Or: Accept this as temporary and focus on real Claude integration</li>
        </ul>
        <p><strong>Location:</strong> <code>src/services/mockContentGenerator.ts:20-116</code></p>
    </div>

    <h2>Summary</h2>
    <p>The codebase has a <strong>clean service architecture</strong> with good separation of concerns at the high level (WindowManager, ChatService, storage utils). The main areas for improvement are:</p>
    <ol>
        <li><strong>Consolidate type definitions</strong> - reduce duplication and clarify single source of truth</li>
        <li><strong>Extract hooks from Canvas component</strong> - reduce file size and improve testability</li>
        <li><strong>Type-safe message passing</strong> - prevent runtime errors from wrong message payloads</li>
    </ol>
    <p>Overall, the architecture is <strong>maintainable and extensible</strong>, with clear boundaries between Chrome extension contexts and well-defined service layers.</p>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                curve: 'basis',
                padding: 20
            }
        });
    </script>
</body>
</html>
