<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nabokov Web Clipper - Architecture Documentation</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #FAF7F2;
            --light-cream: #F5F0E8;
            --ink-black: #2C2C2C;
            --level-1: #8B0000;
            --level-2: #A0522D;
            --level-3: #696969;
            --level-4: #999999;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', 'Roboto', 'Arial', sans-serif;
            line-height: 1.3;
            font-size: 14px;
            width: 100vw;
            max-width: 100%;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            padding: 12px;
        }

        h1 {
            font-size: 28px;
            font-weight: 900;
            margin: 8px 0;
            padding: 12px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(139, 0, 0, 0.3);
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 12px 0 6px 0;
            padding: 6px 8px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.05);
            color: var(--level-1);
        }

        h3 {
            font-size: 15px;
            font-weight: 600;
            margin: 8px 0 4px 0;
            padding: 4px 6px;
            color: var(--level-2);
            border-left: 3px solid var(--chinese-gold);
            background: rgba(255, 215, 0, 0.08);
        }

        h4 {
            font-size: 13px;
            font-weight: 600;
            margin: 6px 0 3px 12px;
            color: var(--level-3);
        }

        .important-box {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), white);
            border: 2px solid var(--chinese-gold);
            border-radius: 4px;
            padding: 12px;
            margin: 12px 0;
            box-shadow: 0 2px 8px rgba(139, 0, 0, 0.1);
        }

        .important-box h2 {
            color: var(--chinese-red);
            margin-top: 0;
            border: none;
            background: transparent;
            padding-left: 0;
        }

        .collapsible {
            margin: 8px 0;
            border: 1px solid rgba(139, 0, 0, 0.15);
            border-radius: 3px;
            overflow: hidden;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.06), rgba(255, 215, 0, 0.03));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            color: var(--level-2);
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 12px;
            font-weight: bold;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
            padding: 0 12px;
            background: white;
        }

        .collapsible.open .collapsible-content {
            max-height: 8000px;
            padding: 12px;
        }

        .mermaid {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.15);
            border-radius: 4px;
            padding: 16px;
            margin: 12px 0;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 12px 0;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .card.priority {
            border: 2px solid var(--chinese-red);
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.03), white);
        }

        code {
            background: rgba(245, 245, 220, 0.4);
            border: 1px solid rgba(139, 0, 0, 0.15);
            padding: 2px 5px;
            border-radius: 2px;
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: #333;
        }

        pre {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.15);
            border-radius: 4px;
            padding: 10px;
            margin: 8px 0;
            overflow-x: auto;
            font-size: 12px;
            line-height: 1.4;
        }

        pre code {
            background: transparent;
            border: none;
            padding: 0;
        }

        ul, ol {
            margin: 6px 0 6px 24px;
            line-height: 1.6;
        }

        li {
            margin: 4px 0;
        }

        strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin: 0 4px;
            vertical-align: middle;
        }

        .badge.red {
            background: var(--chinese-red);
            color: white;
        }

        .badge.gold {
            background: var(--chinese-gold);
            color: #333;
        }

        .badge.gray {
            background: #999;
            color: white;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 8px 0;
            font-size: 13px;
            background: white;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
            color: var(--level-2);
        }

        .flow-step {
            background: white;
            border-left: 3px solid var(--chinese-gold);
            padding: 8px;
            margin: 6px 0;
        }

        .flow-step strong {
            color: var(--chinese-red);
        }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 16px 0;
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
        }

        .tech-item {
            background: white;
            border: 1px solid var(--chinese-gold);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ Nabokov Web Clipper - Architecture Documentation</h1>

        <div class="important-box">
            <h2>ğŸ“‹ Project Overview</h2>
            <p><strong>Nabokov Web Clipper</strong> is a Chrome extension (Manifest V3) that enables users to capture web content visually and organize it on an infinite canvas. Built with React, TypeScript, Vite, and React Flow.</p>
            <p style="margin-top: 8px;"><strong>Research Citation:</strong> Zhu, F. W., Agrawala, M., & Mysore, G. J. (2024). Nabokov: Organize Web Content with LLM-Powered Visual Canvas. <em>UIST '24 Companion</em>, Article 42, 1-3.</p>

            <h3 style="margin-top: 12px;">Key Features</h3>
            <ul>
                <li><strong>Visual Element Selection:</strong> Click any element on any webpage to capture it (Cmd+Shift+E)</li>
                <li><strong>Canvas Organization:</strong> Infinite canvas with React Flow for organizing captured content</li>
                <li><strong>Screenshot Capture:</strong> Automatic screenshot capture with compression</li>
                <li><strong>Dual Storage:</strong> Chrome storage for metadata, IndexedDB for screenshots</li>
                <li><strong>Search & Filter:</strong> Full-text search, tag filtering, domain filtering</li>
                <li><strong>Chinese Aesthetic:</strong> Red/gold color scheme inspired by traditional Chinese design</li>
            </ul>
        </div>

        <h2>ğŸ—ï¸ System Architecture Overview</h2>
        <div class="mermaid">
graph TB
    subgraph "User Interaction Layer"
        User[ğŸ‘¤ User]
        WebPage[ğŸŒ Web Page]
        Toolbar[ğŸ”§ Extension Icon]
    end

    subgraph "Chrome Extension (Manifest V3)"
        Background[âš™ï¸ Background Service Worker<br/>src/background/index.ts]
        Content[ğŸ“„ Content Script<br/>src/content/index.tsx]
        Canvas[ğŸ¨ Canvas App<br/>src/canvas/index.html]
    end

    subgraph "React Components (Shadow DOM)"
        ElementSelector[ğŸ¯ ElementSelector<br/>Visual overlay for selection]
        CardNode[ğŸƒ CardNode<br/>Canvas card display]
        Toolbar2[ğŸ” Toolbar<br/>Search & filters]
    end

    subgraph "Storage Layer"
        ChromeStorage[(ğŸ’¾ chrome.storage.local<br/>Card metadata)]
        IndexedDB[(ğŸ—„ï¸ IndexedDB<br/>Screenshots)]
    end

    subgraph "Utilities"
        Screenshot[ğŸ“¸ Screenshot Capture<br/>+ Compression]
        Sanitize[ğŸ§¹ HTML Sanitization<br/>DOMPurify]
        Storage[ğŸ’¿ Storage Utils<br/>Save/Load]
    end

    User -->|"1. Presses Cmd+Shift+E"| Background
    Background -->|"2. ACTIVATE_SELECTOR"| Content
    Content -->|"3. Mounts in Shadow DOM"| ElementSelector
    User -->|"4. Clicks element"| ElementSelector
    ElementSelector -->|"5. Extract HTML"| Sanitize
    ElementSelector -->|"6. Request screenshot"| Background
    Background -->|"7. captureVisibleTab"| Screenshot
    Screenshot -->|"8. Compress"| Screenshot
    ElementSelector -->|"9. Save Card"| Storage
    Storage -->|"10a. Metadata"| ChromeStorage
    Storage -->|"10b. Screenshot"| IndexedDB
    User -->|"11. Click toolbar icon"| Toolbar
    Toolbar -->|"12. Open canvas"| Canvas
    Canvas -->|"13. Load cards"| ChromeStorage
    Canvas -->|"14. Load screenshots"| IndexedDB
    Canvas -->|"15. Render"| CardNode

    style Background fill:#8B0000,color:#fff
    style Content fill:#A0522D,color:#fff
    style Canvas fill:#FFD700,color:#333
    style ElementSelector fill:#87CEEB
    style ChromeStorage fill:#90EE90
    style IndexedDB fill:#90EE90
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>âš™ï¸ Three Execution Contexts</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <div class="two-column">
                    <div class="card priority">
                        <h4>ğŸ”´ 1. Background Service Worker</h4>
                        <p><strong>File:</strong> <code>src/background/index.ts</code></p>
                        <p><strong>Type:</strong> Manifest V3 service worker</p>
                        <p><strong>Responsibilities:</strong></p>
                        <ul>
                            <li>Listens for keyboard commands (Cmd+Shift+E)</li>
                            <li>Manages context menu ("Clip to Canvas")</li>
                            <li>Captures screenshots via <code>chrome.tabs.captureVisibleTab()</code></li>
                            <li>Opens Canvas page on toolbar icon click</li>
                            <li>Routes messages between content scripts and Canvas</li>
                        </ul>
                        <p><strong>Lifetime:</strong> Event-driven, can terminate when idle</p>
                    </div>

                    <div class="card priority">
                        <h4>ğŸŸ¡ 2. Content Script</h4>
                        <p><strong>File:</strong> <code>src/content/index.tsx</code></p>
                        <p><strong>Injection:</strong> All pages (<code>&lt;all_urls&gt;</code>)</p>
                        <p><strong>Responsibilities:</strong></p>
                        <ul>
                            <li>Listens for ACTIVATE_SELECTOR messages</li>
                            <li>Mounts ElementSelector in Shadow DOM</li>
                            <li>Provides isolated React rendering context</li>
                            <li>Handles element capture coordination</li>
                        </ul>
                        <p><strong>Isolation:</strong> Shadow DOM prevents CSS conflicts</p>
                    </div>

                    <div class="card priority" style="grid-column: span 2;">
                        <h4>ğŸ¨ 3. Canvas Page (Standalone React App)</h4>
                        <p><strong>File:</strong> <code>src/canvas/index.html</code></p>
                        <p><strong>URL:</strong> <code>chrome-extension://&lt;id&gt;/src/canvas/index.html</code></p>
                        <p><strong>Responsibilities:</strong></p>
                        <ul>
                            <li>React Flow canvas for infinite workspace</li>
                            <li>Loads cards from chrome.storage.local</li>
                            <li>Renders captured elements as draggable nodes</li>
                            <li>Search, filter, and tag management</li>
                            <li>Keyboard shortcuts system</li>
                            <li>Auto-saves position/size changes (debounced 2s)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <h2>ğŸ”„ Data Flow: Element Capture Pipeline</h2>
        <div class="mermaid">
sequenceDiagram
    participant U as ğŸ‘¤ User
    participant BG as âš™ï¸ Background Worker
    participant CS as ğŸ“„ Content Script
    participant ES as ğŸ¯ ElementSelector
    participant San as ğŸ§¹ Sanitizer
    participant SC as ğŸ“¸ Screenshot
    participant St as ğŸ’¿ Storage
    participant Ch as ğŸ’¾ chrome.storage
    participant IDB as ğŸ—„ï¸ IndexedDB

    U->>BG: Press Cmd+Shift+E
    BG->>CS: ACTIVATE_SELECTOR message
    CS->>ES: Mount in Shadow DOM
    ES->>U: Show visual overlay
    U->>ES: Click element

    rect rgb(255, 245, 220)
        Note over ES,San: Capture Phase
        ES->>San: Extract innerHTML
        San->>ES: Sanitized HTML + styles
        ES->>BG: Request screenshot
        BG->>SC: captureVisibleTab()
        SC->>BG: Screenshot dataURL
        BG->>ES: Screenshot data
        ES->>SC: Compress screenshot
        SC->>ES: Compressed dataURL
    end

    rect rgb(220, 255, 220)
        Note over ES,IDB: Storage Phase
        ES->>St: Save Card object
        St->>Ch: Save card metadata
        St->>IDB: Save screenshot (screenshotId)
        St->>ES: Success
        ES->>U: Visual feedback
    end

    U->>BG: Click toolbar icon
    BG->>U: Open Canvas page
        </div>

        <div class="flow-step">
            <strong>Step 1:</strong> User presses Cmd+Shift+E â†’ Background worker receives keyboard command
        </div>
        <div class="flow-step">
            <strong>Step 2:</strong> Background sends ACTIVATE_SELECTOR message to active tab's content script
        </div>
        <div class="flow-step">
            <strong>Step 3:</strong> Content script mounts ElementSelector component in Shadow DOM with isolated styles
        </div>
        <div class="flow-step">
            <strong>Step 4:</strong> User hovers and clicks desired element â†’ ElementSelector captures it
        </div>
        <div class="flow-step">
            <strong>Step 5:</strong> HTML extraction + sanitization via DOMPurify (removes scripts, dangerous attributes)
        </div>
        <div class="flow-step">
            <strong>Step 6-8:</strong> Screenshot capture via background worker â†’ Canvas compression â†’ Quality 0.8, max 800px
        </div>
        <div class="flow-step">
            <strong>Step 9-10:</strong> Generate unique ID â†’ Save Card to chrome.storage.local + Screenshot to IndexedDB
        </div>
        <div class="flow-step">
            <strong>Step 11:</strong> Canvas auto-refreshes via storage listener â†’ Displays new card
        </div>

        <div class="divider"></div>

        <h2>ğŸ’¾ Storage Architecture</h2>
        <div class="mermaid">
graph LR
    subgraph "Card Data Structure"
        Card[Card Object]
        Card --> Meta[metadata: ClipMetadata]
        Card --> Content[content: string HTML]
        Card --> Screenshot[screenshotId?: string]
        Card --> Tags[tags: string[]]
        Card --> Conv[conversation?: Message[]]
        Card --> Pos[position?: x,y]
    end

    subgraph "chrome.storage.local (5MB limit)"
        CardsKey["'cards' â†’ Card[]"]
        StateKey["'nabokov_canvas_state' â†’ CanvasState"]
        FilterKey["'nabokov_filters' â†’ FilterState"]
    end

    subgraph "IndexedDB (Large capacity)"
        DB[Database: 'nabokov-clipper']
        Store[Store: 'screenshots']
        Store --> SS1[screenshotId â†’ dataURL]
        Store --> SS2[screenshotId â†’ dataURL]
    end

    Card -->|Metadata only| CardsKey
    Screenshot -->|Reference| Store

    style CardsKey fill:#FFD700
    style Store fill:#90EE90
    style Card fill:#87CEEB
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>ğŸ“Š Storage Strategy Details</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <h3>Why Dual Storage?</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Storage Type</th>
                            <th>chrome.storage.local</th>
                            <th>IndexedDB</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Capacity</strong></td>
                            <td>~5MB (QUOTA_BYTES_PER_ITEM)</td>
                            <td>Much larger (browser-dependent, 50MB+)</td>
                        </tr>
                        <tr>
                            <td><strong>API</strong></td>
                            <td>Simple async key-value</td>
                            <td>Complex IndexedDB API (wrapped by idb)</td>
                        </tr>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Fast for small data</td>
                            <td>Optimized for large blobs</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>Card metadata (text)</td>
                            <td>Screenshots (base64 images)</td>
                        </tr>
                        <tr>
                            <td><strong>Sync</strong></td>
                            <td>Can sync with chrome.storage.sync</td>
                            <td>Local only</td>
                        </tr>
                    </tbody>
                </table>

                <h3 style="margin-top: 16px;">Card Object Structure</h3>
                <pre><code>interface Card {
  id: string;                    // Generated: timestamp-random
  content: string;               // Sanitized HTML
  metadata: ClipMetadata;        // url, title, domain, favicon, etc.
  position?: { x, y };          // Canvas position (React Flow)
  size?: { width, height };     // Canvas size
  starred: boolean;
  tags: string[];               // User-assigned tags
  createdAt: number;            // Timestamp
  updatedAt: number;            // Timestamp
  conversation?: Message[];      // AI chat history (future)
  screenshotId?: string;        // Reference to IndexedDB
  styles?: RelevantStyles;      // Computed CSS for rendering
  context?: string;             // Parent element HTML snippet
}</code></pre>

                <h3 style="margin-top: 16px;">Storage Keys</h3>
                <ul>
                    <li><code>'cards'</code> â†’ <code>Card[]</code> - All captured cards</li>
                    <li><code>'nabokov_canvas_state'</code> â†’ <code>CanvasState</code> - Viewport position, zoom level</li>
                    <li><code>'nabokov_filters'</code> â†’ <code>FilterState</code> - Active search/filter state</li>
                </ul>

                <h3 style="margin-top: 16px;">IndexedDB Schema</h3>
                <pre><code>Database: 'nabokov-clipper' (version 1)
Store: 'screenshots'
  - keyPath: 'id'
  - value: { id: string, dataUrl: string, timestamp: number }</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>ğŸ§© Component Architecture</h2>
        <div class="mermaid">
graph TB
    subgraph "Content Script Context"
        Mount[Content Script Mount<br/>src/content/mount.tsx]
        Mount --> Shadow[Shadow DOM Root]
        Shadow --> ES[ElementSelector Component]
        ES --> Overlay[Visual Overlay]
        ES --> Tooltip[Element Info Tooltip]
        ES --> FC[FloatingChat<br/>placeholder for AI]
    end

    subgraph "Canvas Context"
        CanvasApp[Canvas.tsx<br/>ReactFlowProvider]
        CanvasApp --> RFCanvas[React Flow Canvas]
        CanvasApp --> TB[Toolbar<br/>Search & Filters]
        CanvasApp --> KH[KeyboardHelp<br/>Shortcuts overlay]
        CanvasApp --> Settings[SettingsPanel]
        RFCanvas --> CN[CardNodeÃ—N<br/>Custom node type]
        RFCanvas --> MM[MiniMap]
        RFCanvas --> Controls[Zoom Controls]
    end

    subgraph "Shared Utilities"
        San[sanitization.ts<br/>DOMPurify wrapper]
        SCap[screenshotChrome.ts<br/>Chrome API capture]
        SComp[screenshot.ts<br/>Canvas compression]
        Stor[storage.ts<br/>Save/load helpers]
    end

    ES --> San
    ES --> SCap
    ES --> SComp
    ES --> Stor
    CN --> San
    TB --> Stor

    style ES fill:#87CEEB
    style CanvasApp fill:#FFD700
    style CN fill:#90EE90
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>ğŸ¯ ElementSelector Component</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <p><strong>Location:</strong> <code>src/components/ElementSelector.tsx</code></p>
                <p><strong>Rendering Context:</strong> Shadow DOM (CSS isolation)</p>

                <h4>Features</h4>
                <ul>
                    <li><strong>Visual Overlay:</strong> Red/gold border highlighting hoverable elements</li>
                    <li><strong>Element Info Tooltip:</strong> Shows tag name, classes, dimensions</li>
                    <li><strong>Click to Capture:</strong> Extracts HTML, styles, and context</li>
                    <li><strong>Screenshot Capture:</strong> Optional and non-blocking (fails silently on CORS)</li>
                    <li><strong>Keyboard Shortcuts:</strong> ESC to deactivate</li>
                </ul>

                <h4>Critical Implementation: Non-blocking Screenshots</h4>
                <pre><code>// Screenshot capture can fail due to CORS/canvas tainting
let compressionResult: { dataUrl: string; metadata: any } | null = null;
try {
  const screenshotDataUrl = await captureElementScreenshot(target);
  compressionResult = await compressScreenshot(screenshotDataUrl, {
    quality: 0.8,
    maxWidth: 800,
  });
  console.log('Screenshot captured successfully');
} catch (screenshotError) {
  console.warn('Screenshot capture failed (non-blocking):', screenshotError);
  // Continue without screenshot - it's optional
}

const card: Card = {
  // ...
  screenshotId: compressionResult ? screenshotId : undefined,
};</code></pre>

                <h4>State Management</h4>
                <ul>
                    <li><code>isActive</code> - Selector is mounted and listening</li>
                    <li><code>hoveredElement</code> - Currently highlighted element</li>
                    <li><code>selectedElement</code> - Element clicked for capture</li>
                    <li><code>isCapturing</code> - Capture pipeline in progress</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>ğŸ¨ Canvas & CardNode Components</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <h3>Canvas.tsx</h3>
                <p><strong>Location:</strong> <code>src/canvas/Canvas.tsx</code></p>
                <p><strong>Purpose:</strong> Main canvas application using React Flow</p>

                <h4>Key Features</h4>
                <ul>
                    <li><strong>React Flow Integration:</strong> Infinite canvas with pan/zoom</li>
                    <li><strong>Custom Node Type:</strong> <code>cardNode</code> â†’ CardNode component</li>
                    <li><strong>Keyboard Shortcuts:</strong> Global shortcut manager (Cmd+F, Cmd+K, etc.)</li>
                    <li><strong>Search & Filter:</strong> Real-time filtering via Toolbar</li>
                    <li><strong>Auto-save:</strong> Debounced position/size changes (2 seconds)</li>
                    <li><strong>Empty States:</strong> Guidance when no cards or no results</li>
                </ul>

                <h4>useCanvasState Hook</h4>
                <pre><code>// Custom hook managing canvas state
const {
  nodes,              // React Flow nodes (generated from cards)
  edges,              // Connections (empty for now)
  onNodesChange,      // Handler for drag/resize
  cards,              // All cards from storage
  filteredCards,      // After search/filter
  isLoading,          // Initial load state
  error,              // Error state
  stats,              // Storage statistics
  filters,            // Current filter state
  setFilters,         // Update filters
  availableDomains,   // Unique domains for filter
  availableTags,      // Unique tags for filter
} = useCanvasState();</code></pre>

                <div class="divider"></div>

                <h3>CardNode.tsx</h3>
                <p><strong>Location:</strong> <code>src/canvas/CardNode.tsx</code></p>
                <p><strong>Purpose:</strong> Custom React Flow node displaying captured content</p>

                <h4>Display Elements</h4>
                <ul>
                    <li><strong>Header:</strong> Favicon + domain + star icon</li>
                    <li><strong>Title:</strong> Page title (truncated to 80 chars)</li>
                    <li><strong>Content Preview:</strong> Sanitized HTML text (200 chars)</li>
                    <li><strong>Footer:</strong> Timestamp + tags (first 3, with +N indicator)</li>
                    <li><strong>Handles:</strong> Hidden React Flow connection points</li>
                </ul>

                <h4>âš ï¸ Critical Bug Fix</h4>
                <pre><code>// ALWAYS check if tags exist before accessing .length
{card.tags && card.tags.length > 0 && (
  &lt;div style={styles.tags}&gt;
    {card.tags.slice(0, 3).map((tag: string, i: number) =&gt; (
      &lt;span key={i} style={styles.tag}&gt;{tag}&lt;/span&gt;
    ))}
  &lt;/div&gt;
)}

// Without this check, old cards without tags cause:
// TypeError: Cannot read properties of undefined (reading 'length')</code></pre>

                <h4>Styling</h4>
                <p>Chinese aesthetic with red/gold gradient, beige background, shadow effects</p>
            </div>
        </div>

        <div class="divider"></div>

        <h2>ğŸ› ï¸ Build & Deployment</h2>
        <div class="mermaid">
graph LR
    subgraph "Development"
        TS[TypeScript Files<br/>src/**/*.ts(x)]
        Manifest[src/manifest.json]
        Vite[Vite Build<br/>+ @crxjs/vite-plugin]
    end

    subgraph "Build Output (dist/)"
        JS[Compiled JS Bundles]
        HTML[Canvas HTML]
        ManifestOut[manifest.json]
        Assets[Icons, CSS]
    end

    subgraph "Chrome"
        Load[Load Unpacked Extension]
        Run[Extension Running]
    end

    TS --> Vite
    Manifest --> Vite
    Vite --> JS
    Vite --> HTML
    Vite --> ManifestOut
    Vite --> Assets

    JS --> Load
    HTML --> Load
    ManifestOut --> Load
    Assets --> Load
    Load --> Run

    Run -.->|Reload Required| Vite

    style Vite fill:#FFD700
    style Load fill:#90EE90
        </div>

        <div class="two-column">
            <div class="card">
                <h4>ğŸ“¦ Build Commands</h4>
                <pre><code># Full build (TypeScript + Vite)
npm run build

# Watch mode (auto-rebuild)
npm run watch:extension

# Type checking only
npm run type-check

# Development server
npm run dev</code></pre>
            </div>

            <div class="card">
                <h4>ğŸ”„ Development Workflow</h4>
                <ol>
                    <li>Edit source files</li>
                    <li>Run <code>npm run build</code></li>
                    <li>Go to <code>chrome://extensions</code></li>
                    <li>Click reload icon (ğŸ”„) on extension</li>
                    <li>Test changes</li>
                </ol>
                <p><strong>Note:</strong> Chrome caches extension code. Must manually reload!</p>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>âš™ï¸ Vite Configuration Details</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <h4>vite.config.ts</h4>
                <pre><code>export default defineConfig({
  plugins: [
    react({
      jsxImportSource: '@emotion/react',  // CSS-in-JS
      babel: {
        plugins: ['@emotion/babel-plugin'],
      },
    }),
    crx({ manifest }),  // Chrome extension support
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@utils': path.resolve(__dirname, './src/utils'),
      '@types': path.resolve(__dirname, './src/types'),
    },
  },
  build: {
    outDir: 'dist',
    emptyOutDir: true,
    rollupOptions: {
      input: {
        canvas: path.resolve(__dirname, 'src/canvas/index.html'),
      },
    },
  },
});</code></pre>

                <h4>Key Build Features</h4>
                <ul>
                    <li><strong>@crxjs/vite-plugin:</strong> Handles Manifest V3 service worker, content scripts</li>
                    <li><strong>Path aliases:</strong> <code>@/</code> imports instead of relative paths</li>
                    <li><strong>Emotion CSS-in-JS:</strong> Styled components with JSX pragma</li>
                    <li><strong>Separate entry points:</strong> Background, content, canvas compiled independently</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <h2>ğŸ§ª Testing Strategy</h2>
        <div class="two-column">
            <div class="card priority">
                <h4>Unit Tests (Vitest)</h4>
                <p><strong>Framework:</strong> Vitest + jsdom + Testing Library</p>
                <p><strong>Location:</strong> <code>tests/unit/</code></p>
                <p><strong>Coverage:</strong></p>
                <ul>
                    <li>Storage utilities</li>
                    <li>Sanitization (DOMPurify wrapper)</li>
                    <li>Screenshot compression</li>
                    <li>Keyboard shortcuts</li>
                </ul>
                <pre><code># Run tests
npm test

# Watch mode
npm run test:watch

# Coverage report
npm run test:coverage</code></pre>
            </div>

            <div class="card priority">
                <h4>E2E Tests (Playwright)</h4>
                <p><strong>Framework:</strong> Playwright with extension loading</p>
                <p><strong>Location:</strong> <code>tests/e2e/</code> + <code>test-scripts/</code></p>
                <p><strong>Coverage:</strong></p>
                <ul>
                    <li>Extension loading</li>
                    <li>Element capture flow</li>
                    <li>Canvas rendering</li>
                    <li>Screenshot capture</li>
                </ul>
                <pre><code># Run E2E tests
npm run test:e2e

# Manual test (bypasses chrome://extensions)
node test-scripts/test-canvas-direct.mjs</code></pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>ğŸ­ Playwright Extension Testing</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <h4>Why Special Setup?</h4>
                <p>Standard Playwright cannot load Chrome extensions. Must use <code>launchPersistentContext</code> with extension flags.</p>

                <h4>Test Script Pattern</h4>
                <pre><code>import { chromium } from 'playwright';
import path from 'path';

const ext = path.join(__dirname, '..', 'dist');
const ctx = await chromium.launchPersistentContext('', {
  headless: false,  // Extensions require headed mode
  args: [
    '--disable-extensions-except=' + ext,
    '--load-extension=' + ext
  ]
});

// Get extension ID from service worker
const serviceWorkers = ctx.serviceWorkers();
const extId = serviceWorkers[0].url().match(/chrome-extension:\/\/([a-z]+)\//)?.[1];

// Navigate to canvas page
const page = await ctx.newPage();
await page.goto(`chrome-extension://${extId}/src/canvas/index.html`);</code></pre>

                <h4>Test Scripts Location</h4>
                <ul>
                    <li><code>test-scripts/test-canvas-direct.mjs</code> - Canvas loading & rendering</li>
                    <li><code>test-scripts/test-capture.mjs</code> - Element capture flow</li>
                    <li><code>test-scripts/test-extension.mjs</code> - Basic extension loading</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <h2>ğŸ“š Technology Stack</h2>
        <div class="tech-stack">
            <div class="tech-item">React 18.3.1</div>
            <div class="tech-item">TypeScript 5.3</div>
            <div class="tech-item">Vite 5.0</div>
            <div class="tech-item">@xyflow/react 12.3.2</div>
            <div class="tech-item">IndexedDB (idb 8.0.0)</div>
            <div class="tech-item">Emotion CSS-in-JS</div>
            <div class="tech-item">DOMPurify (isomorphic)</div>
            <div class="tech-item">Vitest</div>
            <div class="tech-item">Playwright</div>
            <div class="tech-item">@crxjs/vite-plugin</div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span>ğŸ” Dependency Details</span>
                <span class="arrow">â–¶</span>
            </div>
            <div class="collapsible-content">
                <table>
                    <thead>
                        <tr>
                            <th>Package</th>
                            <th>Purpose</th>
                            <th>Why This Choice</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>@xyflow/react</strong></td>
                            <td>Canvas visualization</td>
                            <td>Best-in-class React Flow library for node-based UIs</td>
                        </tr>
                        <tr>
                            <td><strong>idb</strong></td>
                            <td>IndexedDB wrapper</td>
                            <td>Promise-based API for IndexedDB (much simpler)</td>
                        </tr>
                        <tr>
                            <td><strong>isomorphic-dompurify</strong></td>
                            <td>HTML sanitization</td>
                            <td>Works in both browser and Node.js environments</td>
                        </tr>
                        <tr>
                            <td><strong>@emotion/react</strong></td>
                            <td>CSS-in-JS</td>
                            <td>Shadow DOM requires scoped styles</td>
                        </tr>
                        <tr>
                            <td><strong>@crxjs/vite-plugin</strong></td>
                            <td>Chrome extension build</td>
                            <td>Best Vite plugin for Manifest V3 support</td>
                        </tr>
                        <tr>
                            <td><strong>Vitest</strong></td>
                            <td>Unit testing</td>
                            <td>Fast, Vite-native test runner</td>
                        </tr>
                        <tr>
                            <td><strong>Playwright</strong></td>
                            <td>E2E testing</td>
                            <td>Only framework supporting extension loading</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="divider"></div>

        <h2>âš ï¸ Known Issues & Solutions</h2>
        <div class="two-column">
            <div class="card">
                <h4>ğŸ› Issue: "Cannot read properties of undefined (reading 'length')"</h4>
                <p><strong>Cause:</strong> Old cards may not have <code>tags</code> array</p>
                <p><strong>Solution:</strong></p>
                <pre><code>// Always check before accessing
{card.tags && card.tags.length > 0 && (
  // render tags
)}</code></pre>
            </div>

            <div class="card">
                <h4>ğŸ› Issue: "Tainted canvases may not be exported"</h4>
                <p><strong>Cause:</strong> CORS restrictions on screenshot capture</p>
                <p><strong>Solution:</strong> Already handled with try-catch wrapper (non-blocking)</p>
            </div>

            <div class="card">
                <h4>ğŸ› Issue: Extension not updating after build</h4>
                <p><strong>Cause:</strong> Chrome caches extension code</p>
                <p><strong>Solution:</strong></p>
                <ol>
                    <li>Go to <code>chrome://extensions</code></li>
                    <li>Click reload icon (ğŸ”„)</li>
                    <li>Refresh Canvas pages</li>
                </ol>
            </div>

            <div class="card">
                <h4>ğŸ› Issue: Content script not responding</h4>
                <p><strong>Cause:</strong> Timing issue on page load</p>
                <p><strong>Solution:</strong></p>
                <ul>
                    <li>Check <code>run_at: "document_idle"</code> in manifest</li>
                    <li>Check <code>matches: ["&lt;all_urls&gt;"]</code></li>
                    <li>Background worker timing is expected (non-critical)</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <h2>ğŸ“ File Organization</h2>
        <pre><code>NabokovsWeb/
â”œâ”€â”€ src/                        # Source code
â”‚   â”œâ”€â”€ background/             # Service worker
â”‚   â”‚   â””â”€â”€ index.ts           # Main background script
â”‚   â”œâ”€â”€ content/                # Content script injection
â”‚   â”‚   â”œâ”€â”€ index.tsx          # Content script entry
â”‚   â”‚   â””â”€â”€ mount.tsx          # Shadow DOM mounting
â”‚   â”œâ”€â”€ components/             # React components
â”‚   â”‚   â”œâ”€â”€ ElementSelector.tsx  # Element selection UI
â”‚   â”‚   â”œâ”€â”€ FloatingChat.tsx     # AI chat (placeholder)
â”‚   â”‚   â””â”€â”€ KeyboardHelp.tsx     # Shortcuts overlay
â”‚   â”œâ”€â”€ canvas/                 # Canvas app (separate React app)
â”‚   â”‚   â”œâ”€â”€ index.html         # Canvas page
â”‚   â”‚   â”œâ”€â”€ Canvas.tsx         # Main canvas component
â”‚   â”‚   â”œâ”€â”€ CardNode.tsx       # Custom React Flow node
â”‚   â”‚   â”œâ”€â”€ Toolbar.tsx        # Search & filters
â”‚   â”‚   â””â”€â”€ useCanvasState.ts  # Canvas state hook
â”‚   â”œâ”€â”€ utils/                  # Utility functions
â”‚   â”‚   â”œâ”€â”€ storage.ts         # chrome.storage + IndexedDB
â”‚   â”‚   â”œâ”€â”€ screenshot.ts      # Canvas compression
â”‚   â”‚   â”œâ”€â”€ screenshotChrome.ts # Chrome API capture
â”‚   â”‚   â”œâ”€â”€ sanitization.ts    # DOMPurify wrapper
â”‚   â”‚   â””â”€â”€ keyboardShortcuts.ts # Shortcut manager
â”‚   â”œâ”€â”€ types/                  # TypeScript types
â”‚   â”‚   â”œâ”€â”€ card.ts            # Card type (source of truth)
â”‚   â”‚   â””â”€â”€ index.ts           # Type exports
â”‚   â””â”€â”€ manifest.json           # Extension manifest
â”œâ”€â”€ public/                     # Static assets
â”‚   â””â”€â”€ icons/                  # Extension icons
â”œâ”€â”€ tests/                      # Tests
â”‚   â”œâ”€â”€ unit/                  # Vitest unit tests
â”‚   â”œâ”€â”€ e2e/                   # Playwright E2E tests
â”‚   â””â”€â”€ fixtures/              # Test fixtures
â”œâ”€â”€ test-scripts/               # Manual test scripts
â”‚   â”œâ”€â”€ test-canvas-direct.mjs # Canvas testing
â”‚   â””â”€â”€ test-capture.mjs       # Capture flow testing
â”œâ”€â”€ docs/                       # Documentation
â”œâ”€â”€ archive/                    # Old implementations
â”œâ”€â”€ dist/                       # Build output (gitignored)
â””â”€â”€ coverage/                   # Test coverage (gitignored)</code></pre>

        <div class="divider"></div>

        <h2>ğŸš€ Future Enhancements</h2>
        <div class="two-column">
            <div class="card">
                <h4>ğŸ¤– AI Chat Integration</h4>
                <p>Complete the FloatingChat component with Claude API integration for analyzing captured content</p>
            </div>
            <div class="card">
                <h4>ğŸ”— Card Connections</h4>
                <p>Enable linking related cards with React Flow edges</p>
            </div>
            <div class="card">
                <h4>ğŸ“¤ Export/Import</h4>
                <p>Export canvas as JSON, PDF, or image. Import from other tools</p>
            </div>
            <div class="card">
                <h4>ğŸ”„ Cloud Sync</h4>
                <p>Use chrome.storage.sync for cross-device synchronization</p>
            </div>
        </div>

        <div style="margin-top: 24px; padding: 16px; background: white; border: 2px solid var(--chinese-gold); border-radius: 4px; text-align: center;">
            <p style="margin: 0; color: var(--level-2); font-weight: 600;">
                Generated by Claude Code Â· <a href="https://github.com/WarrenZhu050413/nabokovs-web" style="color: var(--chinese-red);">GitHub Repository</a>
            </p>
        </div>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#FFD700',
                primaryTextColor: '#333',
                primaryBorderColor: '#8B0000',
                lineColor: '#8B0000',
                secondaryColor: '#F5F0E8',
                tertiaryColor: '#FAF7F2'
            }
        });

        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('open');
        }

        // Open first few collapsibles by default
        document.addEventListener('DOMContentLoaded', function() {
            const collapsibles = document.querySelectorAll('.collapsible');
            if (collapsibles.length > 0) {
                collapsibles[0].classList.add('open'); // Three execution contexts
            }
        });
    </script>
</body>
</html>