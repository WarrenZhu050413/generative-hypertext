<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nabokov Web Clipper - React Architecture Analysis</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --ink-black: #1a1a1a;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #555;
            --level-4: #777;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.3;
            font-size: 14px;
            margin: 0;
            padding: 8px;
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 0;
        }

        h1 {
            font-size: 26px;
            font-weight: 900;
            margin: 6px 0 12px 0;
            padding: 8px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
            text-align: center;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 12px 0 6px 0;
            padding: 6px 8px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 15px;
            font-weight: 600;
            margin: 8px 0 4px 0;
            padding: 4px 0 4px 12px;
            color: var(--level-2);
            border-left: 3px solid var(--chinese-gold);
        }

        h4 {
            font-size: 13px;
            font-weight: 600;
            margin: 6px 0 3px 16px;
            color: var(--level-3);
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 8px 0;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.15);
            border-radius: 3px;
            padding: 8px;
            margin: 6px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .card.critical {
            border: 2px solid var(--chinese-red);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .card h4 {
            margin: 0 0 4px 0;
            color: var(--chinese-red);
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.4), rgba(255, 255, 255, 0.6));
            border: 1px solid rgba(139, 0, 0, 0.1);
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.3;
        }

        code {
            padding: 2px 5px;
            border-radius: 2px;
        }

        pre {
            padding: 8px;
            margin: 6px 0;
            overflow-x: auto;
            border-radius: 3px;
        }

        pre code {
            background: none;
            border: none;
            padding: 0;
        }

        ul, ol {
            margin: 6px 0 6px 20px;
            padding: 0;
        }

        li {
            margin: 3px 0;
            padding-left: 4px;
        }

        .dense-list {
            list-style: none;
            margin-left: 12px;
        }

        .dense-list li {
            padding: 3px 0 3px 14px;
            position: relative;
            border-left: 2px solid transparent;
        }

        .dense-list li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 8px 0;
            font-size: 13px;
            background: white;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.08), rgba(255, 215, 0, 0.05));
            font-weight: 600;
            color: var(--level-1);
        }

        .collapsible {
            margin: 6px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 6px 10px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.04), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 14px;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.08), rgba(255, 215, 0, 0.04));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 11px;
            margin-right: 6px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 10px;
            margin-left: 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 8000px;
            padding: 10px;
        }

        .highlight-box {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05));
            border: 2px solid var(--chinese-gold);
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 10px 0;
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 12px 0;
        }

        .indent-1 { margin-left: 16px; }
        .indent-2 { margin-left: 32px; }
        .indent-3 { margin-left: 48px; }

        .flow-diagram {
            background: white;
            border: 2px solid var(--chinese-gold);
            padding: 12px;
            margin: 10px 0;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
        }

        .tech-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin: 2px 4px 2px 0;
        }

        .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔬 Nabokov Web Clipper: React Architecture Analysis</h1>

        <div class="highlight-box">
            <strong style="color: var(--chinese-red); font-size: 15px;">Core Vision:</strong> Chrome extension for selecting webpage elements + floating chat → Export to local canvas for spatial organization and re-engagement with Claude
        </div>

        <h2>📊 Existing Web Clipper Analysis</h2>

        <div class="comparison-grid">
            <div class="card">
                <h4>Obsidian Official Clipper</h4>
                <span class="tech-badge">TypeScript</span>
                <span class="tech-badge">Webpack</span>
                <ul class="dense-list">
                    <li><strong>No React</strong> - Pure TS/vanilla JS</li>
                    <li>Manifest V3 compliant</li>
                    <li>Floating iframe for UI</li>
                    <li>Content script injection pattern</li>
                    <li>Side panel + popup architecture</li>
                </ul>
            </div>

            <div class="card">
                <h4>mvavassori Web Clipper</h4>
                <span class="tech-badge">React 18</span>
                <span class="tech-badge">Webpack</span>
                <ul class="dense-list">
                    <li><strong>React-based popup</strong></li>
                    <li>React hooks (useState, useEffect)</li>
                    <li>Chrome storage API integration</li>
                    <li>Obsidian URL protocol for export</li>
                    <li>Simple, clean architecture</li>
                </ul>
            </div>

            <div class="card">
                <h4>webclipper/web-clipper</h4>
                <span class="tech-badge">React 17</span>
                <span class="tech-badge">DVA</span>
                <span class="tech-badge">Ant Design</span>
                <ul class="dense-list">
                    <li>Complex state management (DVA/Redux)</li>
                    <li>Multiple backend integrations</li>
                    <li>TypeScript + DI pattern (TypeDI)</li>
                    <li>Over-engineered for your needs</li>
                </ul>
            </div>
        </div>

        <h2>✅ Key Technical Findings</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Element Selection & Capture Patterns</span>
            </div>
            <div class="collapsible-content">
                <h4>From Obsidian Official Clipper (content.ts:15-76)</h4>
                <pre><code>// Floating iframe injection pattern
async function toggleIframe() {
  const container = document.createElement('div');
  container.id = 'obsidian-clipper-container';

  const iframe = document.createElement('iframe');
  iframe.src = browser.runtime.getURL('side-panel.html');
  container.appendChild(iframe);

  // Resizable handles
  const handle = document.createElement('div');
  handle.className = 'obsidian-clipper-resize-handle';
  addResizeListener(container, handle, 'w');

  document.body.appendChild(container);
}</code></pre>

                <ul class="dense-list">
                    <li><strong>Pattern:</strong> Inject styled container + iframe into page</li>
                    <li><strong>Why iframe:</strong> Style isolation from host page</li>
                    <li><strong>Communication:</strong> postMessage between content script & iframe</li>
                    <li><strong>Positioning:</strong> Fixed position (top-right or floating)</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>React Component Injection via Content Script</span>
            </div>
            <div class="collapsible-content">
                <h4>From mvavassori Clipper (App.js:1-150)</h4>
                <pre><code>// React popup component structure
function App() {
  const [pageInfo, setPageInfo] = useState({ title: "", url: "" });
  const [content, setContent] = useState("");

  useEffect(() => {
    // Get current tab info
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const tab = tabs[0];
      setPageInfo({ title: tab.title, url: tab.url });
    });
  }, []);

  useEffect(() => {
    // Load settings from chrome.storage
    chrome.storage.sync.get(['obsidianVault', 'folderPath'], (result) => {
      setObsidianVault(result.obsidianVault);
    });
  }, []);

  const saveNote = async () => {
    // Export via Obsidian URL protocol
    const uri = `obsidian://new?vault=${vault}&file=${title}&content=${content}`;
    window.open(uri);
  };

  return (
    &lt;textarea value={content} onChange={(e) => setContent(e.target.value)} /&gt;
  );
}</code></pre>

                <ul class="dense-list">
                    <li><strong>Approach:</strong> React for popup UI, vanilla JS for content script</li>
                    <li><strong>State management:</strong> React hooks (useState, useEffect)</li>
                    <li><strong>Storage:</strong> chrome.storage.sync for persistence</li>
                    <li><strong>Export:</strong> URL protocol or local file write</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Webpack Build Configuration for React Extension</span>
            </div>
            <div class="collapsible-content">
                <h4>From mvavassori webpack.dev.js:1-80</h4>
                <pre><code>module.exports = (env) => {
  const browser = env.browser || "chromium";

  return {
    entry: {
      popup: `./src/${browser}/index.js`,
      background: `./src/${browser}/background.js`,
    },
    output: {
      filename: "[name].js",
      path: path.resolve(__dirname, `dist-${browser}`),
    },
    module: {
      rules: [
        {
          test: /\.jsx?$/,
          use: {
            loader: "babel-loader",
            options: {
              presets: [
                "@babel/preset-react",
                "@babel/preset-env"
              ]
            }
          }
        }
      ]
    },
    plugins: [
      new HtmlWebpackPlugin({
        template: "./public/index.html",
        filename: "popup.html",
        chunks: ["popup"]
      }),
      new CopyPlugin({
        patterns: [
          { from: `manifests/manifest_${browser}.json`, to: "manifest.json" }
        ]
      })
    ]
  };
};</code></pre>

                <ul class="dense-list">
                    <li><strong>Multi-entry:</strong> Separate bundles for popup, background, content script</li>
                    <li><strong>Babel:</strong> Transform JSX → vanilla JS</li>
                    <li><strong>HtmlWebpackPlugin:</strong> Generate popup.html with injected bundle</li>
                    <li><strong>CopyPlugin:</strong> Copy manifest and assets to dist folder</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <h2>🏗️ Recommended React Architecture for Nabokov Clipper</h2>

        <div class="card critical">
            <h3>Tech Stack Decision</h3>
            <span class="tech-badge">React 18</span>
            <span class="tech-badge">Vite</span>
            <span class="tech-badge">Floating-UI</span>
            <span class="tech-badge">IndexedDB</span>
            <span class="tech-badge">React Flow</span>

            <div class="indent-1" style="margin-top: 8px;">
                <strong style="color: var(--chinese-red);">Why Vite over Webpack?</strong>
                <ul class="dense-list">
                    <li>Faster dev server (instant HMR)</li>
                    <li>Simpler config for React</li>
                    <li>Better DX for iterative development</li>
                    <li>Plugin: <code>@crxjs/vite-plugin</code> for Chrome extensions</li>
                </ul>
            </div>
        </div>

        <h3>Project Structure</h3>

        <div class="two-column-layout">
            <pre><code>nabokov-clipper/
├── src/
│   ├── extension/          # Chrome extension code
│   │   ├── background.ts   # Service worker
│   │   ├── content/        # Content scripts
│   │   │   ├── index.tsx   # Entry point
│   │   │   ├── ElementSelector.tsx
│   │   │   ├── FloatingChat.tsx
│   │   │   └── styles.css
│   │   ├── popup/          # Extension popup
│   │   │   ├── Popup.tsx
│   │   │   └── index.tsx
│   │   └── manifest.json
│   ├── canvas/             # Canvas application
│   │   ├── App.tsx         # Main canvas app
│   │   ├── components/
│   │   │   ├── Card.tsx
│   │   │   ├── Canvas.tsx
│   │   │   └── ChatModal.tsx
│   │   ├── hooks/
│   │   │   ├── useIndexedDB.ts
│   │   │   └── useClaudeAPI.ts
│   │   └── index.tsx
│   └── shared/             # Shared utilities
│       ├── db.ts           # IndexedDB wrapper
│       ├── types.ts        # TypeScript types
│       └── claude.ts       # Claude API client</code></pre>

            <pre><code>├── public/
│   ├── icons/
│   └── canvas.html         # Canvas entry HTML
├── dist/                   # Build output
│   ├── extension/          # Chrome extension
│   └── canvas/             # Canvas webapp
├── package.json
├── vite.config.ts
└── tsconfig.json</code></pre>
        </div>

        <div class="divider"></div>

        <h2>💾 Data Architecture: IndexedDB Schema</h2>

        <pre><code>// Database: nabokov-cards
// Object Store: cards

interface ClippedCard {
  id: string;                    // UUID
  element: {
    html: string;                // Captured outerHTML
    selector: string;            // CSS selector for re-identification
    computedStyles: CSSStyleDeclaration;
    screenshot?: string;         // base64 PNG
  };
  source: {
    url: string;
    title: string;
    timestamp: number;
    domain: string;
    surrounding: string;         // Context text around element
  };
  conversation: Message[];       // Claude conversation history
  canvas: {
    position: { x: number; y: number };
    width: number;
    height: number;
    zIndex: number;
  };
  metadata: {
    created: number;
    lastModified: number;
    lastViewed: number;
    viewCount: number;
    tags?: string[];
  };
}

interface Message {
  role: "user" | "assistant";
  content: string;
  timestamp: number;
}</code></pre>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>IndexedDB Wrapper Implementation</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// src/shared/db.ts
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface NabokovDB extends DBSchema {
  cards: {
    key: string;
    value: ClippedCard;
    indexes: { 'by-created': number; 'by-url': string };
  };
}

class CardDatabase {
  private db: IDBPDatabase&lt;NabokovDB&gt; | null = null;

  async init() {
    this.db = await openDB&lt;NabokovDB&gt;('nabokov-cards', 1, {
      upgrade(db) {
        const store = db.createObjectStore('cards', { keyPath: 'id' });
        store.createIndex('by-created', 'metadata.created');
        store.createIndex('by-url', 'source.url');
      },
    });
  }

  async addCard(card: ClippedCard) {
    return this.db!.add('cards', card);
  }

  async getCard(id: string) {
    return this.db!.get('cards', id);
  }

  async getAllCards() {
    return this.db!.getAll('cards');
  }

  async updateCard(id: string, updates: Partial&lt;ClippedCard&gt;) {
    const card = await this.getCard(id);
    if (!card) throw new Error('Card not found');

    const updated = { ...card, ...updates };
    return this.db!.put('cards', updated);
  }

  async deleteCard(id: string) {
    return this.db!.delete('cards', id);
  }
}

export const cardDB = new CardDatabase();</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>🎯 Component Architecture: Extension Side</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>1. Content Script: Element Selector Component</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// src/extension/content/ElementSelector.tsx
import React, { useState, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';

interface ElementSelectorProps {
  onSelect: (element: HTMLElement) => void;
  active: boolean;
}

export function ElementSelector({ onSelect, active }: ElementSelectorProps) {
  const [hoveredElement, setHoveredElement] = useState&lt;HTMLElement | null&gt;(null);
  const overlayRef = useRef&lt;HTMLDivElement&gt;(null);

  useEffect(() => {
    if (!active) return;

    const handleMouseMove = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (target.closest('.nabokov-overlay')) return; // Ignore our own UI

      setHoveredElement(target);

      // Update overlay position to highlight element
      if (overlayRef.current) {
        const rect = target.getBoundingClientRect();
        Object.assign(overlayRef.current.style, {
          top: `${rect.top + window.scrollY}px`,
          left: `${rect.left + window.scrollX}px`,
          width: `${rect.width}px`,
          height: `${rect.height}px`,
          display: 'block',
        });
      }
    };

    const handleClick = (e: MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      if (hoveredElement) {
        onSelect(hoveredElement);
      }
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('click', handleClick, true);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('click', handleClick, true);
    };
  }, [active, hoveredElement, onSelect]);

  if (!active) return null;

  return (
    &lt;div
      ref={overlayRef}
      className="nabokov-overlay"
      style={{
        position: 'absolute',
        border: '2px solid #8B0000',
        backgroundColor: 'rgba(255, 215, 0, 0.1)',
        pointerEvents: 'none',
        zIndex: 999999,
        display: 'none',
      }}
    /&gt;
  );
}

// Inject selector when extension activated
chrome.runtime.onMessage.addListener((message) => {
  if (message.action === 'activateSelector') {
    const container = document.createElement('div');
    container.id = 'nabokov-selector-root';
    document.body.appendChild(container);

    const root = createRoot(container);
    root.render(
      &lt;ElementSelector
        active={true}
        onSelect={(element) => {
          // Capture element and open floating chat
          const captured = captureElement(element);
          openFloatingChat(captured);
        }}
      /&gt;
    );
  }
});</code></pre>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>2. Floating Chat Component (uses Floating-UI)</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// src/extension/content/FloatingChat.tsx
import React, { useState, useRef, useEffect } from 'react';
import { useFloating, offset, flip, shift } from '@floating-ui/react';
import { sendMessageToClaude } from '../../shared/claude';

interface FloatingChatProps {
  element: CapturedElement;
  onExport: (card: ClippedCard) => void;
  onClose: () => void;
}

export function FloatingChat({ element, onExport, onClose }: FloatingChatProps) {
  const [messages, setMessages] = useState&lt;Message[]&gt;([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const { refs, floatingStyles } = useFloating({
    placement: 'right-start',
    middleware: [offset(10), flip(), shift()],
  });

  const handleSend = async () => {
    if (!input.trim()) return;

    const userMsg: Message = {
      role: 'user',
      content: input,
      timestamp: Date.now(),
    };

    setMessages((prev) => [...prev, userMsg]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await sendMessageToClaude([
        {
          role: 'user',
          content: `Context: I selected this HTML element from ${element.source.url}:\n\n${element.html}\n\nQuestion: ${input}`,
        },
      ]);

      const assistantMsg: Message = {
        role: 'assistant',
        content: response,
        timestamp: Date.now(),
      };

      setMessages((prev) => [...prev, assistantMsg]);
    } catch (error) {
      console.error('Claude API error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleExport = () => {
    const card: ClippedCard = {
      id: crypto.randomUUID(),
      element,
      conversation: messages,
      canvas: {
        position: { x: 100, y: 100 },
        width: 400,
        height: 500,
        zIndex: 1,
      },
      metadata: {
        created: Date.now(),
        lastModified: Date.now(),
        lastViewed: Date.now(),
        viewCount: 0,
      },
    };

    onExport(card);
  };

  return (
    &lt;div
      ref={refs.setFloating}
      style={{
        ...floatingStyles,
        width: '400px',
        maxHeight: '600px',
        background: 'white',
        border: '2px solid #8B0000',
        borderRadius: '8px',
        boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
        display: 'flex',
        flexDirection: 'column',
        zIndex: 1000000,
      }}
    &gt;
      {/* Chat header */}
      &lt;div style={{ padding: '12px', borderBottom: '1px solid #ddd' }}&gt;
        &lt;h3 style={{ margin: 0, fontSize: '14px' }}&gt;Chat with Claude&lt;/h3&gt;
        &lt;button onClick={onClose} style={{ float: 'right' }}&gt;✕&lt;/button&gt;
      &lt;/div&gt;

      {/* Messages */}
      &lt;div style={{ flex: 1, overflowY: 'auto', padding: '12px' }}&gt;
        {messages.map((msg, i) => (
          &lt;div key={i} style={{ marginBottom: '12px' }}&gt;
            &lt;strong&gt;{msg.role === 'user' ? 'You' : 'Claude'}:&lt;/strong&gt;
            &lt;div&gt;{msg.content}&lt;/div&gt;
          &lt;/div&gt;
        ))}
        {isLoading && &lt;div&gt;Claude is typing...&lt;/div&gt;}
      &lt;/div&gt;

      {/* Input */}
      &lt;div style={{ padding: '12px', borderTop: '1px solid #ddd' }}&gt;
        &lt;textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleSend();
            }
          }}
          placeholder="Ask Claude about this element..."
          style={{ width: '100%', padding: '8px', minHeight: '60px' }}
        /&gt;
        &lt;div style={{ marginTop: '8px', display: 'flex', gap: '8px' }}&gt;
          &lt;button onClick={handleSend} disabled={isLoading}&gt;
            Send
          &lt;/button&gt;
          &lt;button onClick={handleExport} style={{ marginLeft: 'auto' }}&gt;
            Export to Canvas
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>🖼️ Component Architecture: Canvas Side</h2>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Canvas Application with React Flow</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// src/canvas/App.tsx
import React, { useState, useEffect, useCallback } from 'react';
import ReactFlow, {
  Node,
  Edge,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  NodeTypes,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { cardDB } from '../shared/db';
import { CardNode } from './components/CardNode';
import { ChatModal } from './components/ChatModal';

const nodeTypes: NodeTypes = {
  card: CardNode,
};

export function CanvasApp() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedCard, setSelectedCard] = useState&lt;ClippedCard | null&gt;(null);
  const [chatOpen, setChatOpen] = useState(false);

  // Load cards from IndexedDB
  useEffect(() => {
    const loadCards = async () => {
      await cardDB.init();
      const cards = await cardDB.getAllCards();

      const flowNodes: Node[] = cards.map((card) => ({
        id: card.id,
        type: 'card',
        position: card.canvas.position,
        data: { card },
      }));

      setNodes(flowNodes);
    };

    loadCards();
  }, []);

  // Save position changes to IndexedDB
  const handleNodeDragStop = useCallback(
    async (event: any, node: Node) => {
      await cardDB.updateCard(node.id, {
        canvas: {
          ...node.data.card.canvas,
          position: node.position,
        },
      });
    },
    []
  );

  const handleCardClick = useCallback((card: ClippedCard) => {
    setSelectedCard(card);
    setChatOpen(true);
  }, []);

  return (
    &lt;div style={{ width: '100vw', height: '100vh' }}&gt;
      &lt;ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onNodeDragStop={handleNodeDragStop}
        nodeTypes={nodeTypes}
        fitView
      &gt;
        &lt;Background /&gt;
        &lt;Controls /&gt;
      &lt;/ReactFlow&gt;

      {chatOpen && selectedCard && (
        &lt;ChatModal
          card={selectedCard}
          onClose={() => setChatOpen(false)}
          onUpdate={async (updated) => {
            await cardDB.updateCard(selectedCard.id, updated);
            // Refresh nodes
            const cards = await cardDB.getAllCards();
            setNodes(cards.map((card) => ({
              id: card.id,
              type: 'card',
              position: card.canvas.position,
              data: { card },
            })));
          }}
        /&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h4 style="margin-top: 12px;">Card Node Component</h4>
                <pre><code>// src/canvas/components/CardNode.tsx
import React from 'react';
import { Handle, Position, NodeProps } from 'reactflow';

export function CardNode({ data }: NodeProps&lt;{ card: ClippedCard }&gt;) {
  const { card } = data;

  return (
    &lt;div
      style={{
        width: card.canvas.width,
        minHeight: 200,
        background: 'white',
        border: '2px solid #8B0000',
        borderRadius: '6px',
        padding: '12px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
      }}
    &gt;
      {/* Preview of captured HTML */}
      &lt;div
        style={{ fontSize: '12px', maxHeight: '150px', overflow: 'hidden' }}
        dangerouslySetInnerHTML={{ __html: card.element.html }}
      /&gt;

      {/* Metadata */}
      &lt;div style={{ marginTop: '8px', fontSize: '11px', color: '#666' }}&gt;
        &lt;div&gt;{new URL(card.source.url).hostname}&lt;/div&gt;
        &lt;div&gt;{new Date(card.metadata.created).toLocaleDateString()}&lt;/div&gt;
        &lt;div&gt;{card.conversation.length} messages&lt;/div&gt;
      &lt;/div&gt;

      &lt;Handle type="source" position={Position.Right} /&gt;
      &lt;Handle type="target" position={Position.Left} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>🔄 Data Flow Diagram</h2>

        <div class="flow-diagram">
┌─────────────────────────────────────────────────────────────────┐
│                      USER WORKFLOW                              │
└─────────────────────────────────────────────────────────────────┘

1. BROWSE WEB
   │
   ├─▶ Cmd+Shift+N (keyboard shortcut)
   │
   ▼
2. ELEMENT SELECTION MODE ACTIVATED
   │   • Content script injected
   │   • ElementSelector component rendered
   │   • Hover highlights elements
   │
   ├─▶ Click element
   │
   ▼
3. FLOATING CHAT OPENS
   │   • FloatingChat component rendered next to element
   │   • Element HTML captured + screenshot
   │   • User chats with Claude about element
   │
   ├─▶ "Export to Canvas" button clicked
   │
   ▼
4. SAVE TO INDEXEDDB
   │   • Card object created: { element, conversation, metadata }
   │   • Saved to local IndexedDB
   │   • Notification: "Saved to canvas!"
   │
   ▼
5. OPEN CANVAS APPLICATION
   │   • Separate React app (localhost:3000 or file://)
   │   • Reads all cards from IndexedDB
   │   • Renders as draggable nodes via React Flow
   │
   ├─▶ Drag cards to arrange spatially
   │   • Positions saved to IndexedDB on drag end
   │
   ├─▶ Click card to re-engage
   │   • ChatModal opens with full conversation history
   │   • Continue conversation with Claude
   │   • Context includes original element + all past messages
   │
   └─▶ Multi-select cards (Shift+Click)
       • [CLARIFICATION NEEDED FROM USER]
       • Option A: Export bundle as JSON/Markdown
       • Option B: Start grouped conversation with all cards
       • Option C: Pass all to Claude as context for summary
        </div>

        <div class="divider"></div>

        <h2>🚀 Implementation Roadmap</h2>

        <div class="card">
            <h3>Phase 1: Chrome Extension MVP (Week 1)</h3>
            <ul class="dense-list">
                <li><strong>Setup:</strong> Vite + React + TypeScript + @crxjs/vite-plugin</li>
                <li><strong>Manifest V3:</strong> Define permissions, content scripts, background service worker</li>
                <li><strong>Content Script:</strong> ElementSelector component with hover/click</li>
                <li><strong>Floating Chat:</strong> Basic iframe with hardcoded chat UI (no Claude yet)</li>
                <li><strong>Export:</strong> Save to IndexedDB with dummy data</li>
            </ul>
        </div>

        <div class="card">
            <h3>Phase 2: Canvas Application (Week 2)</h3>
            <ul class="dense-list">
                <li><strong>Setup:</strong> Separate Vite + React app</li>
                <li><strong>IndexedDB:</strong> Read cards and display as list</li>
                <li><strong>React Flow:</strong> Integrate for spatial canvas</li>
                <li><strong>CardNode:</strong> Display element preview + metadata</li>
                <li><strong>Drag & drop:</strong> Save positions to IndexedDB</li>
            </ul>
        </div>

        <div class="card">
            <h3>Phase 3: Claude Integration (Week 3)</h3>
            <ul class="dense-list">
                <li><strong>API Client:</strong> Streaming Claude API integration</li>
                <li><strong>FloatingChat:</strong> Connect to real Claude API</li>
                <li><strong>ChatModal:</strong> Re-engagement with conversation history</li>
                <li><strong>Context:</strong> Pass element HTML + surrounding text + conversation</li>
                <li><strong>Streaming:</strong> Display responses as they arrive</li>
            </ul>
        </div>

        <div class="card">
            <h3>Phase 4: Polish & Multi-Select (Week 4)</h3>
            <ul class="dense-list">
                <li><strong>Multi-select:</strong> Implement Shift+Click selection</li>
                <li><strong>[CLARIFY]:</strong> What should multi-select do?</li>
                <li><strong>Search:</strong> Filter cards by URL, date, content</li>
                <li><strong>Export:</strong> JSON/Markdown export of selected cards</li>
                <li><strong>UI Polish:</strong> Chinese aesthetic styling</li>
            </ul>
        </div>

        <div class="divider"></div>

        <h2>❓ Open Questions for Warren</h2>

        <div class="highlight-box">
            <ol style="margin-left: 20px;">
                <li style="margin: 8px 0;"><strong>Multi-select behavior:</strong> When multiple cards are selected on canvas, what should happen? Export bundle? Grouped chat? Summary?</li>

                <li style="margin: 8px 0;"><strong>Canvas hosting:</strong> Local HTML file you open, or dev server (npm run dev)?</li>

                <li style="margin: 8px 0;"><strong>Claude API key:</strong> Stored in extension settings? Or integrate with claude.ai web somehow?</li>

                <li style="margin: 8px 0;"><strong>Element rendering on canvas:</strong> Full HTML (may break without styles), or screenshot thumbnail?</li>

                <li style="margin: 8px 0;"><strong>Conversation continuation:</strong> When re-engaging a card, continue full history or fresh context?</li>
            </ol>
        </div>

        <div class="divider"></div>

        <h2>📦 Package.json Dependencies</h2>

        <pre><code>{
  "name": "nabokov-clipper",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev:extension": "vite --config vite.extension.config.ts",
    "dev:canvas": "vite --config vite.canvas.config.ts",
    "build:extension": "vite build --config vite.extension.config.ts",
    "build:canvas": "vite build --config vite.canvas.config.ts"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "reactflow": "^11.11.4",
    "@floating-ui/react": "^0.26.0",
    "idb": "^8.0.0"
  },
  "devDependencies": {
    "@crxjs/vite-plugin": "^2.0.0-beta.23",
    "@types/chrome": "^0.0.270",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.0",
    "typescript": "^5.5.3",
    "vite": "^5.3.1"
  }
}</code></pre>

        <div class="divider"></div>

        <div style="text-align: center; margin-top: 24px; padding: 16px; background: rgba(139, 0, 0, 0.03); border-radius: 6px;">
            <p style="font-size: 13px; color: var(--level-3); margin: 0;">
                <strong>Next Step:</strong> Answer the 5 open questions above, then I'll create a starter codebase with full implementation
            </p>
        </div>

    </div>

    <script>
        // Collapsible functionality
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                const collapsible = header.parentElement;
                collapsible.classList.toggle('open');
            });
        });
    </script>
</body>
</html>