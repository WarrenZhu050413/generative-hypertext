<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nabokov Web Clipper - Comprehensive Testing Strategy</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --ink-black: #1a1a1a;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #555;
            --level-4: #777;
            --success: #2E7D32;
            --warning: #F57C00;
            --error: #C62828;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.3;
            font-size: 14px;
            padding: 8px;
        }

        h1 {
            font-size: 28px;
            font-weight: 900;
            margin: 8px 0 14px 0;
            padding: 10px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        h2 {
            font-size: 19px;
            font-weight: 700;
            margin: 14px 0 6px 0;
            padding: 7px 10px;
            border-left: 5px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.04);
            color: var(--level-1);
        }

        h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 10px 0 5px 0;
            padding: 5px 0 5px 14px;
            color: var(--level-2);
            border-left: 3px solid var(--chinese-gold);
        }

        h4 {
            font-size: 14px;
            font-weight: 600;
            margin: 7px 0 4px 18px;
            color: var(--level-3);
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            margin: 10px 0;
        }

        .three-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin: 10px 0;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.15);
            border-radius: 4px;
            padding: 10px;
            margin: 7px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .card.critical {
            border: 2px solid var(--chinese-red);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .card.success {
            border: 2px solid var(--success);
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.05), white);
        }

        .card h4 {
            margin: 0 0 6px 0;
            color: var(--chinese-red);
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.4), rgba(255, 255, 255, 0.6));
            border: 1px solid rgba(139, 0, 0, 0.1);
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        code {
            padding: 2px 6px;
            border-radius: 2px;
        }

        pre {
            padding: 10px;
            margin: 8px 0;
            overflow-x: auto;
            border-radius: 4px;
        }

        pre code {
            background: none;
            border: none;
            padding: 0;
        }

        ul, ol {
            margin: 7px 0 7px 22px;
            padding: 0;
        }

        li {
            margin: 4px 0;
            padding-left: 5px;
        }

        .dense-list {
            list-style: none;
            margin-left: 14px;
        }

        .dense-list li {
            padding: 4px 0 4px 16px;
            position: relative;
        }

        .dense-list li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 11px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 13px;
            background: white;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 7px 10px;
            text-align: left;
        }

        th {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.08), rgba(255, 215, 0, 0.05));
            font-weight: 600;
            color: var(--level-1);
        }

        .collapsible {
            margin: 7px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.04), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 14px;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.08), rgba(255, 215, 0, 0.04));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 12px;
            margin-right: 7px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 12px;
            margin-left: 14px;
        }

        .collapsible.open .collapsible-content {
            max-height: 10000px;
            padding: 12px;
        }

        .highlight-box {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05));
            border: 2px solid var(--chinese-gold);
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 14px 0;
        }

        .tech-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            padding: 3px 10px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin: 2px 5px 2px 0;
        }

        .tech-badge.playwright { background: linear-gradient(135deg, #2E7D32, #4CAF50); }
        .tech-badge.vitest { background: linear-gradient(135deg, #F57C00, #FF9800); }
        .tech-badge.manual { background: linear-gradient(135deg, #1976D2, #2196F3); }

        .test-status {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            text-align: center;
            line-height: 16px;
            font-weight: 700;
            font-size: 10px;
            margin-right: 6px;
        }

        .test-status.unit { background: #4CAF50; color: white; }
        .test-status.e2e { background: #2196F3; color: white; }
        .test-status.integration { background: #FF9800; color: white; }
        .test-status.manual { background: #9C27B0; color: white; }

        .test-pyramid {
            background: white;
            border: 2px solid var(--chinese-gold);
            padding: 20px;
            margin: 12px 0;
            text-align: center;
        }

        .pyramid-level {
            padding: 12px;
            margin: 8px auto;
            border: 2px solid;
            font-weight: 600;
        }

        .pyramid-level.unit {
            width: 80%;
            background: rgba(76, 175, 80, 0.1);
            border-color: #4CAF50;
        }

        .pyramid-level.integration {
            width: 60%;
            background: rgba(255, 152, 0, 0.1);
            border-color: #FF9800;
        }

        .pyramid-level.e2e {
            width: 40%;
            background: rgba(33, 150, 243, 0.1);
            border-color: #2196F3;
        }

        .indent-1 { margin-left: 18px; }
        .indent-2 { margin-left: 36px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧪 Nabokov Web Clipper: Comprehensive Testing Strategy</h1>

        <div class="highlight-box">
            <strong style="color: var(--chinese-red); font-size: 16px;">Testing Philosophy:</strong> Playwright for E2E browser automation + Vitest for unit tests + Manual exploratory testing for UX validation
        </div>

        <h2>📊 Testing Pyramid</h2>

        <div class="test-pyramid">
            <div class="pyramid-level e2e">
                E2E Tests (Playwright)<br>
                <small>~15 critical user journeys</small>
            </div>
            <div class="pyramid-level integration">
                Integration Tests (Vitest)<br>
                <small>~30 component interactions</small>
            </div>
            <div class="pyramid-level unit">
                Unit Tests (Vitest)<br>
                <small>~60 pure functions</small>
            </div>
        </div>

        <div class="card">
            <h4>Distribution Strategy</h4>
            <table>
                <tr>
                    <th>Test Type</th>
                    <th>Tool</th>
                    <th>Count</th>
                    <th>Coverage Target</th>
                    <th>Execution Time</th>
                </tr>
                <tr>
                    <td><span class="test-status unit">U</span>Unit Tests</td>
                    <td>Vitest</td>
                    <td>~60</td>
                    <td>90%+ for utils, db, mock API</td>
                    <td>&lt;10s</td>
                </tr>
                <tr>
                    <td><span class="test-status integration">I</span>Integration Tests</td>
                    <td>Vitest + Testing Library</td>
                    <td>~30</td>
                    <td>80%+ for components</td>
                    <td>&lt;30s</td>
                </tr>
                <tr>
                    <td><span class="test-status e2e">E</span>E2E Tests</td>
                    <td>Playwright</td>
                    <td>~15</td>
                    <td>Critical paths 100%</td>
                    <td>~5min</td>
                </tr>
                <tr>
                    <td><span class="test-status manual">M</span>Manual Tests</td>
                    <td>Human</td>
                    <td>~20 scenarios</td>
                    <td>UX/edge cases</td>
                    <td>~30min</td>
                </tr>
            </table>
        </div>

        <div class="divider"></div>

        <h2>🎭 Playwright E2E Tests (Critical Paths)</h2>

        <h3>Setup & Configuration</h3>

        <div class="collapsible open">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>playwright.config.ts</span>
            </div>
            <div class="collapsible-content">
                <pre><code>import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,

  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results.json' }]
  ],

  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },

  projects: [
    // Canvas application tests
    {
      name: 'canvas-chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    // Chrome extension tests (requires unpacked extension)
    {
      name: 'extension-chromium',
      use: {
        ...devices['Desktop Chrome'],
        contextOptions: {
          // Load unpacked extension
          permissions: ['clipboard-read', 'clipboard-write'],
          // Extension will be loaded via beforeAll hook
        }
      },
    },
  ],

  webServer: {
    command: 'npm run dev:canvas',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});</code></pre>
            </div>
        </div>

        <h3>E2E Test Scenarios</h3>

        <div class="three-column-layout">
            <div class="card">
                <h4><span class="tech-badge playwright">Playwright</span>Extension Flow</h4>
                <ul class="dense-list">
                    <li><strong>E01:</strong> Activate selector (Cmd+Shift+C)</li>
                    <li><strong>E02:</strong> Hover highlights element</li>
                    <li><strong>E03:</strong> Click captures element</li>
                    <li><strong>E04:</strong> Floating chat appears</li>
                    <li><strong>E05:</strong> Send message to mock Claude</li>
                    <li><strong>E06:</strong> Receive streamed response</li>
                    <li><strong>E07:</strong> Export to canvas (save to IndexedDB)</li>
                </ul>
            </div>

            <div class="card">
                <h4><span class="tech-badge playwright">Playwright</span>Canvas Flow</h4>
                <ul class="dense-list">
                    <li><strong>E08:</strong> Load cards from IndexedDB</li>
                    <li><strong>E09:</strong> Render cards on canvas</li>
                    <li><strong>E10:</strong> Drag card to new position</li>
                    <li><strong>E11:</strong> Position persists to DB</li>
                    <li><strong>E12:</strong> Click card opens ChatModal</li>
                    <li><strong>E13:</strong> Continue conversation</li>
                    <li><strong>E14:</strong> Search/filter cards</li>
                </ul>
            </div>

            <div class="card">
                <h4><span class="tech-badge playwright">Playwright</span>Edge Cases</h4>
                <ul class="dense-list">
                    <li><strong>E15:</strong> Handle iframe elements</li>
                    <li><strong>E16:</strong> Cross-origin content security</li>
                    <li><strong>E17:</strong> IndexedDB quota exceeded</li>
                    <li><strong>E18:</strong> Network timeout handling</li>
                    <li><strong>E19:</strong> Large screenshot (>5MB)</li>
                    <li><strong>E20:</strong> 1000+ cards performance</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <h2>📝 Detailed E2E Test Specifications</h2>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>E01-E07: Complete Extension User Journey</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// tests/e2e/extension-flow.spec.ts
import { test, expect, chromium, BrowserContext } from '@playwright/test';
import path from 'path';

let context: BrowserContext;
let extensionId: string;

test.beforeAll(async () => {
  // Load extension
  const pathToExtension = path.join(__dirname, '../../dist/extension');

  context = await chromium.launchPersistentContext('', {
    headless: false,
    args: [
      `--disable-extensions-except=${pathToExtension}`,
      `--load-extension=${pathToExtension}`,
    ],
  });

  // Get extension ID
  const background = context.serviceWorkers()[0];
  extensionId = background.url().split('/')[2];
});

test.afterAll(async () => {
  await context.close();
});

test('E01-E07: Complete element capture and chat flow', async () => {
  const page = await context.newPage();

  // Navigate to test page
  await page.goto('https://example.com');

  // E01: Activate selector with keyboard shortcut
  await page.keyboard.press('Meta+Shift+C');

  // E02: Verify overlay appears
  await expect(page.locator('.nabokov-overlay')).toBeVisible();

  // Hover over element
  const targetElement = page.locator('h1').first();
  await targetElement.hover();

  // E02: Verify highlight appears
  const overlay = page.locator('.nabokov-overlay');
  await expect(overlay).toHaveCSS('display', 'block');
  await expect(overlay).toHaveCSS('border', '2px solid rgb(139, 0, 0)');

  // E03: Click to capture element
  await targetElement.click();

  // E04: Verify floating chat appears
  const chat = page.locator('[data-testid="floating-chat"]');
  await expect(chat).toBeVisible();
  await expect(chat).toContainText('Chat with Claude');

  // E05: Type and send message
  const input = chat.locator('textarea');
  await input.fill('What is this element?');
  await input.press('Enter');

  // Verify message appears in chat
  await expect(chat.locator('.message-user')).toContainText('What is this element?');

  // E06: Wait for streamed response
  await page.waitForTimeout(1000); // Wait for mock API delay
  const assistantMessage = chat.locator('.message-assistant').last();
  await expect(assistantMessage).toBeVisible();
  await expect(assistantMessage).not.toBeEmpty();

  // E07: Click "Export to Canvas"
  const exportBtn = chat.locator('button:has-text("Export to Canvas")');
  await exportBtn.click();

  // Verify success notification
  await expect(page.locator('.notification-success')).toContainText('Saved to canvas');

  // Verify saved to IndexedDB
  const dbData = await page.evaluate(async () => {
    const db = await indexedDB.open('nabokov-cards', 1);
    return new Promise((resolve) => {
      const tx = db.transaction('cards', 'readonly');
      const store = tx.objectStore('cards');
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result);
    });
  });

  expect(dbData).toHaveLength(1);
  expect(dbData[0]).toHaveProperty('element.html');
  expect(dbData[0]).toHaveProperty('conversation');
  expect(dbData[0].conversation).toHaveLength(2); // user + assistant
});</code></pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>E08-E14: Canvas Application Journey</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// tests/e2e/canvas-flow.spec.ts
import { test, expect } from '@playwright/test';

test.beforeEach(async ({ page }) => {
  // Seed IndexedDB with test data
  await page.goto('http://localhost:3000');

  await page.evaluate(() => {
    const testCards = [
      {
        id: 'test-card-1',
        element: {
          html: '<h1>Test Heading</h1>',
          selector: 'h1:nth-child(1)',
          computedStyles: {},
          screenshot: 'data:image/png;base64,test'
        },
        source: {
          url: 'https://example.com',
          title: 'Example',
          domain: 'example.com',
          timestamp: Date.now(),
          surrounding: 'test context'
        },
        conversation: [
          { role: 'user', content: 'What is this?', timestamp: Date.now() },
          { role: 'assistant', content: 'This is a heading.', timestamp: Date.now() }
        ],
        canvas: {
          position: { x: 100, y: 100 },
          width: 300,
          height: 200,
          zIndex: 1
        },
        metadata: {
          created: Date.now(),
          lastModified: Date.now(),
          lastViewed: Date.now(),
          viewCount: 0
        }
      }
    ];

    return new Promise((resolve) => {
      const req = indexedDB.open('nabokov-cards', 1);
      req.onsuccess = () => {
        const db = req.result;
        const tx = db.transaction('cards', 'readwrite');
        const store = tx.objectStore('cards');
        testCards.forEach(card => store.put(card));
        tx.oncomplete = () => resolve(true);
      };
    });
  });
});

test('E08-E09: Load and render cards from IndexedDB', async ({ page }) => {
  await page.goto('http://localhost:3000');

  // E08: Wait for cards to load
  await page.waitForSelector('[data-testid="card-node"]');

  // E09: Verify card is rendered
  const card = page.locator('[data-testid="card-node"]').first();
  await expect(card).toBeVisible();
  await expect(card).toContainText('example.com');
  await expect(card).toContainText('2 messages');
});

test('E10-E11: Drag card and persist position', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.waitForSelector('[data-testid="card-node"]');

  const card = page.locator('[data-testid="card-node"]').first();

  // Get initial position
  const initialBox = await card.boundingBox();

  // E10: Drag card
  await card.hover();
  await page.mouse.down();
  await page.mouse.move(initialBox!.x + 200, initialBox!.y + 150);
  await page.mouse.up();

  // Wait for position save
  await page.waitForTimeout(500);

  // E11: Verify position persisted in IndexedDB
  const updatedPosition = await page.evaluate(async () => {
    const db = await indexedDB.open('nabokov-cards', 1);
    return new Promise((resolve) => {
      const tx = db.transaction('cards', 'readonly');
      const req = tx.objectStore('cards').get('test-card-1');
      req.onsuccess = () => resolve(req.result.canvas.position);
    });
  });

  expect(updatedPosition.x).toBeCloseTo(300, 0);
  expect(updatedPosition.y).toBeCloseTo(250, 0);
});

test('E12-E13: Re-engage with card via ChatModal', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.waitForSelector('[data-testid="card-node"]');

  // E12: Click card to open modal
  const card = page.locator('[data-testid="card-node"]').first();
  await card.click();

  const modal = page.locator('[data-testid="chat-modal"]');
  await expect(modal).toBeVisible();

  // Verify conversation history loaded
  await expect(modal.locator('.message-user')).toContainText('What is this?');
  await expect(modal.locator('.message-assistant')).toContainText('This is a heading');

  // E13: Continue conversation
  const input = modal.locator('textarea');
  await input.fill('Tell me more');
  await input.press('Enter');

  // Wait for mock response
  await page.waitForTimeout(1000);

  const messages = modal.locator('.message-assistant');
  await expect(messages).toHaveCount(2); // original + new response
});

test('E14: Search and filter cards', async ({ page }) => {
  // Seed multiple cards
  await page.evaluate(() => {
    const cards = [
      { id: '1', source: { domain: 'example.com', url: 'https://example.com' }, /* ... */ },
      { id: '2', source: { domain: 'github.com', url: 'https://github.com' }, /* ... */ },
      { id: '3', source: { domain: 'example.com', url: 'https://example.com/page2' }, /* ... */ }
    ];
    // ... seed logic
  });

  await page.goto('http://localhost:3000');

  // Open search
  const searchInput = page.locator('[data-testid="search-input"]');
  await searchInput.fill('example.com');

  // Verify filtered results
  await expect(page.locator('[data-testid="card-node"]')).toHaveCount(2);

  // Clear search
  await searchInput.clear();
  await expect(page.locator('[data-testid="card-node"]')).toHaveCount(3);
});</code></pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>E15-E20: Edge Cases & Error Handling</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// tests/e2e/edge-cases.spec.ts
import { test, expect } from '@playwright/test';

test('E15: Handle iframe elements gracefully', async ({ page, context }) => {
  // Create page with iframe
  await page.goto('data:text/html,<iframe src="https://example.com"></iframe>');

  await page.keyboard.press('Meta+Shift+C');

  const iframe = page.frameLocator('iframe');
  const iframeElement = iframe.locator('body');

  // Attempt to select element in iframe
  await iframeElement.click();

  // Should show warning
  await expect(page.locator('.warning-message')).toContainText('cross-origin');
});

test('E17: Handle IndexedDB quota exceeded', async ({ page }) => {
  // Mock IndexedDB to throw quota error
  await page.addInitScript(() => {
    const originalPut = IDBObjectStore.prototype.put;
    IDBObjectStore.prototype.put = function() {
      const error = new DOMException('QuotaExceededError');
      error.name = 'QuotaExceededError';
      throw error;
    };
  });

  await page.goto('http://localhost:3000');
  // Attempt to save card... should show error

  await expect(page.locator('.error-notification')).toContainText('storage limit');
});

test('E20: Performance with 1000+ cards', async ({ page }) => {
  // Seed 1000 cards
  await page.evaluate(() => {
    const cards = Array.from({ length: 1000 }, (_, i) => ({
      id: `card-${i}`,
      // ... minimal card data
    }));
    // ... seed to IndexedDB
  });

  // Measure initial render time
  const startTime = Date.now();
  await page.goto('http://localhost:3000');
  await page.waitForSelector('[data-testid="card-node"]');
  const loadTime = Date.now() - startTime;

  // Should load within 3 seconds
  expect(loadTime).toBeLessThan(3000);

  // Verify React Flow virtualization works
  const visibleCards = await page.locator('[data-testid="card-node"]:visible').count();
  expect(visibleCards).toBeLessThan(100); // Only visible viewport cards rendered
});</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>⚡ Vitest Unit & Integration Tests</h2>

        <h3>Setup & Configuration</h3>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>vitest.config.ts</span>
            </div>
            <div class="collapsible-content">
                <pre><code>import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.spec.ts',
        '**/*.test.ts'
      ]
    }
  }
});</code></pre>
            </div>
        </div>

        <h3>Unit Test Specifications</h3>

        <div class="two-column-layout">
            <div class="card">
                <h4><span class="tech-badge vitest">Vitest</span>Shared Layer Tests</h4>
                <ul class="dense-list">
                    <li><strong>U01:</strong> IndexedDB wrapper CRUD operations</li>
                    <li><strong>U02:</strong> IndexedDB error handling</li>
                    <li><strong>U03:</strong> Mock Claude API keyword matching</li>
                    <li><strong>U04:</strong> Mock Claude API streaming</li>
                    <li><strong>U05:</strong> Element type inference</li>
                    <li><strong>U06:</strong> CSS selector generation</li>
                    <li><strong>U07:</strong> Date formatting utilities</li>
                    <li><strong>U08:</strong> URL parsing utilities</li>
                </ul>
            </div>

            <div class="card">
                <h4><span class="tech-badge vitest">Vitest</span>Component Tests</h4>
                <ul class="dense-list">
                    <li><strong>U09:</strong> CardNode renders correctly</li>
                    <li><strong>U10:</strong> CardNode handles missing screenshot</li>
                    <li><strong>U11:</strong> ChatMessages scrolls to bottom</li>
                    <li><strong>U12:</strong> FloatingChat positioning</li>
                    <li><strong>U13:</strong> ElementSelector overlay updates</li>
                    <li><strong>U14:</strong> ChatModal conversation loading</li>
                    <li><strong>U15:</strong> SearchBar filtering logic</li>
                    <li><strong>U16:</strong> Toolbar button states</li>
                </ul>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Example Unit Tests: IndexedDB Wrapper</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// tests/unit/db.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { cardDB } from '@/shared/db';
import 'fake-indexeddb/auto';

describe('CardDatabase', () => {
  beforeEach(async () => {
    await cardDB.init();
  });

  afterEach(async () => {
    // Clean up
    const allCards = await cardDB.getAllCards();
    await Promise.all(allCards.map(card => cardDB.deleteCard(card.id)));
  });

  it('U01: should add a card to IndexedDB', async () => {
    const testCard = {
      id: 'test-1',
      element: { html: '<div>Test</div>', /* ... */ },
      // ... complete card structure
    };

    await cardDB.addCard(testCard);
    const retrieved = await cardDB.getCard('test-1');

    expect(retrieved).toEqual(testCard);
  });

  it('U01: should get all cards', async () => {
    const cards = [
      { id: '1', /* ... */ },
      { id: '2', /* ... */ }
    ];

    await Promise.all(cards.map(c => cardDB.addCard(c)));
    const allCards = await cardDB.getAllCards();

    expect(allCards).toHaveLength(2);
  });

  it('U01: should update a card', async () => {
    const card = { id: 'test-1', canvas: { position: { x: 0, y: 0 } }, /* ... */ };
    await cardDB.addCard(card);

    await cardDB.updateCard('test-1', {
      canvas: { position: { x: 100, y: 200 } }
    });

    const updated = await cardDB.getCard('test-1');
    expect(updated.canvas.position).toEqual({ x: 100, y: 200 });
  });

  it('U02: should throw error for non-existent card', async () => {
    await expect(cardDB.updateCard('non-existent', {}))
      .rejects.toThrow('Card not found');
  });

  it('U01: should delete a card', async () => {
    const card = { id: 'test-1', /* ... */ };
    await cardDB.addCard(card);
    await cardDB.deleteCard('test-1');

    const retrieved = await cardDB.getCard('test-1');
    expect(retrieved).toBeUndefined();
  });
});</code></pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Example Unit Tests: Mock Claude API</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// tests/unit/mockClaudeAPI.test.ts
import { describe, it, expect, vi } from 'vitest';
import { mockClaude } from '@/shared/mockClaudeAPI';

describe('MockClaudeAPI', () => {
  it('U03: should generate context-aware response', async () => {
    const messages = [
      { role: 'user', content: 'What is this button?' }
    ];

    const context = {
      element: '<button>Click me</button>',
      url: 'https://example.com'
    };

    const response = await mockClaude.sendMessage(messages, context);

    expect(response).toContain('button');
    expect(response.length).toBeGreaterThan(20);
  });

  it('U04: should stream response word by word', async () => {
    const messages = [{ role: 'user', content: 'Hello' }];
    const chunks: string[] = [];

    for await (const chunk of mockClaude.streamMessage(messages)) {
      chunks.push(chunk);
    }

    expect(chunks.length).toBeGreaterThan(5);
    expect(chunks.join('')).toBeTruthy();
  });

  it('U05: should infer element type from HTML', async () => {
    const testCases = [
      { html: '<button>Test</button>', expected: 'button' },
      { html: '<form><input /></form>', expected: 'form' },
      { html: '<nav><a>Link</a></nav>', expected: 'navigation menu' },
      { html: '<div>Content</div>', expected: 'content block' }
    ];

    for (const { html, expected } of testCases) {
      const response = await mockClaude.sendMessage(
        [{ role: 'user', content: 'What is this?' }],
        { element: html }
      );
      expect(response.toLowerCase()).toContain(expected);
    }
  });

  it('U03: should handle keyword matching', async () => {
    const queries = [
      { query: 'explain this code', keyword: 'code' },
      { query: 'what is the URL', keyword: 'url' },
      { query: 'analyze this HTML', keyword: 'html' }
    ];

    for (const { query, keyword } of queries) {
      const response = await mockClaude.sendMessage([
        { role: 'user', content: query }
      ]);
      expect(response.toLowerCase()).toContain(keyword);
    }
  });
});</code></pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Example Integration Tests: React Components</span>
            </div>
            <div class="collapsible-content">
                <pre><code>// tests/integration/CardNode.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { CardNode } from '@/canvas/components/CardNode';
import { ReactFlowProvider } from '@xyflow/react';

const mockCard = {
  id: 'test-1',
  element: {
    html: '<h1>Test Heading</h1>',
    selector: 'h1',
    screenshot: 'data:image/png;base64,test'
  },
  source: {
    url: 'https://example.com',
    domain: 'example.com',
    timestamp: Date.now()
  },
  conversation: [
    { role: 'user', content: 'Test question' },
    { role: 'assistant', content: 'Test answer' }
  ],
  canvas: { position: { x: 0, y: 0 }, width: 300, height: 200 }
};

describe('CardNode', () => {
  it('U09: should render card with metadata', () => {
    render(
      <ReactFlowProvider>
        <CardNode data={{ card: mockCard }} />
      </ReactFlowProvider>
    );

    expect(screen.getByText('example.com')).toBeInTheDocument();
    expect(screen.getByText(/2 messages/)).toBeInTheDocument();
  });

  it('U10: should show HTML preview when no screenshot', () => {
    const cardWithoutScreenshot = {
      ...mockCard,
      element: { ...mockCard.element, screenshot: undefined }
    };

    render(
      <ReactFlowProvider>
        <CardNode data={{ card: cardWithoutScreenshot }} />
      </ReactFlowProvider>
    );

    expect(screen.getByText('Test Heading')).toBeInTheDocument();
  });
});</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>👤 Manual Testing Checklist</h2>

        <div class="card">
            <h4><span class="tech-badge manual">Manual</span>UX & Exploratory Tests</h4>
            <table>
                <tr>
                    <th style="width: 10%;">ID</th>
                    <th style="width: 50%;">Test Scenario</th>
                    <th style="width: 40%;">Expected Behavior</th>
                </tr>
                <tr>
                    <td><strong>M01</strong></td>
                    <td>Chinese aesthetic visual inspection</td>
                    <td>Colors, fonts, gradients match design system</td>
                </tr>
                <tr>
                    <td><strong>M02</strong></td>
                    <td>Floating chat positioning on small screens (&lt;1024px)</td>
                    <td>Chat repositions to fit viewport, no overflow</td>
                </tr>
                <tr>
                    <td><strong>M03</strong></td>
                    <td>Capture element from complex SPA (React/Vue site)</td>
                    <td>Successfully captures dynamically rendered elements</td>
                </tr>
                <tr>
                    <td><strong>M04</strong></td>
                    <td>Capture from site with heavy CSS (animations, transforms)</td>
                    <td>Styles preserved in screenshot, no visual glitches</td>
                </tr>
                <tr>
                    <td><strong>M05</strong></td>
                    <td>Keyboard navigation in FloatingChat</td>
                    <td>Tab/Shift+Tab works, Enter sends, Esc closes</td>
                </tr>
                <tr>
                    <td><strong>M06</strong></td>
                    <td>Drag 50 cards rapidly on canvas</td>
                    <td>Smooth 60fps, no lag, all positions save</td>
                </tr>
                <tr>
                    <td><strong>M07</strong></td>
                    <td>Zoom in/out on canvas (pinch, mouse wheel)</td>
                    <td>Smooth zoom, cards remain crisp, UI responsive</td>
                </tr>
                <tr>
                    <td><strong>M08</strong></td>
                    <td>Open 10 ChatModals simultaneously</td>
                    <td>All modals render, no memory leak, smooth scrolling</td>
                </tr>
                <tr>
                    <td><strong>M09</strong></td>
                    <td>Mock Claude streaming with slow network (throttled 3G)</td>
                    <td>Words appear progressively, no timeout errors</td>
                </tr>
                <tr>
                    <td><strong>M10</strong></td>
                    <td>Screenshot capture of image-heavy element (&gt;10 images)</td>
                    <td>All images captured, file size reasonable (&lt;2MB)</td>
                </tr>
                <tr>
                    <td><strong>M11</strong></td>
                    <td>Search cards with special characters (!@#$%)</td>
                    <td>Search works correctly, no regex errors</td>
                </tr>
                <tr>
                    <td><strong>M12</strong></td>
                    <td>Delete card with active ChatModal open</td>
                    <td>Modal closes gracefully, card removed from canvas</td>
                </tr>
                <tr>
                    <td><strong>M13</strong></td>
                    <td>Browser back/forward navigation</td>
                    <td>Canvas state persists, no data loss</td>
                </tr>
                <tr>
                    <td><strong>M14</strong></td>
                    <td>Extension icon click from different tabs</td>
                    <td>Correct context, no cross-tab contamination</td>
                </tr>
                <tr>
                    <td><strong>M15</strong></td>
                    <td>IndexedDB inspection in DevTools</td>
                    <td>Schema correct, data structure matches types</td>
                </tr>
                <tr>
                    <td><strong>M16</strong></td>
                    <td>Canvas export to JSON Canvas format</td>
                    <td>Valid .canvas file, opens in Obsidian</td>
                </tr>
                <tr>
                    <td><strong>M17</strong></td>
                    <td>Long conversation (50+ messages)</td>
                    <td>Chat scrolls smoothly, no perf degradation</td>
                </tr>
                <tr>
                    <td><strong>M18</strong></td>
                    <td>Capture element while page is still loading</td>
                    <td>Graceful handling, waits for element to stabilize</td>
                </tr>
                <tr>
                    <td><strong>M19</strong></td>
                    <td>Accessibility: Screen reader navigation</td>
                    <td>All interactive elements announced, logical tab order</td>
                </tr>
                <tr>
                    <td><strong>M20</strong></td>
                    <td>Multiple browser windows, same extension</td>
                    <td>IndexedDB syncs correctly, no conflicts</td>
                </tr>
            </table>
        </div>

        <div class="divider"></div>

        <h2>🔧 Test Infrastructure</h2>

        <h3>Package.json Scripts</h3>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>Complete Test Commands</span>
            </div>
            <div class="collapsible-content">
                <pre><code>{
  "scripts": {
    // Development
    "dev:extension": "vite --config vite.extension.config.ts",
    "dev:canvas": "vite --config vite.canvas.config.ts",

    // Testing
    "test": "vitest",
    "test:unit": "vitest run tests/unit",
    "test:integration": "vitest run tests/integration",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",

    "test:e2e": "playwright test",
    "test:e2e:headed": "playwright test --headed",
    "test:e2e:debug": "playwright test --debug",
    "test:e2e:ui": "playwright test --ui",

    "test:all": "npm run test:unit && npm run test:integration && npm run test:e2e",

    // CI/CD
    "test:ci": "npm run test:coverage && npm run test:e2e",

    // Utilities
    "playwright:install": "playwright install chromium",
    "playwright:codegen": "playwright codegen",
    "playwright:report": "playwright show-report"
  }
}</code></pre>
            </div>
        </div>

        <h3>CI/CD Integration (GitHub Actions)</h3>

        <div class="collapsible">
            <div class="collapsible-header">
                <span><span class="arrow">▶</span>.github/workflows/test.yml</span>
            </div>
            <div class="collapsible-content">
                <pre><code>name: Test Suite

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright
        run: npx playwright install --with-deps chromium

      - name: Run unit tests with coverage
        run: npm run test:coverage

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        if: always()

      - name: Upload Playwright report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>📊 Testing Timeline & Effort</h2>

        <table>
            <tr>
                <th>Phase</th>
                <th>Tests Written</th>
                <th>Time Estimate</th>
                <th>When</th>
            </tr>
            <tr>
                <td><strong>Phase 1: Foundation</strong></td>
                <td>U01-U08 (Unit tests for shared layer)</td>
                <td>4 hours</td>
                <td>During implementation</td>
            </tr>
            <tr>
                <td><strong>Phase 2: Extension</strong></td>
                <td>E01-E07 (Extension E2E) + U09-U13 (Component tests)</td>
                <td>8 hours</td>
                <td>After extension MVP</td>
            </tr>
            <tr>
                <td><strong>Phase 3: Canvas</strong></td>
                <td>E08-E14 (Canvas E2E) + U14-U16 (Component tests)</td>
                <td>6 hours</td>
                <td>After canvas MVP</td>
            </tr>
            <tr>
                <td><strong>Phase 4: Polish</strong></td>
                <td>E15-E20 (Edge cases) + M01-M20 (Manual)</td>
                <td>10 hours</td>
                <td>Final week</td>
            </tr>
            <tr style="background: rgba(46, 125, 50, 0.1); font-weight: 700;">
                <td><strong>Total</strong></td>
                <td><strong>~105 tests</strong></td>
                <td><strong>28 hours</strong></td>
                <td><strong>Distributed across 4 phases</strong></td>
            </tr>
        </table>

        <div class="divider"></div>

        <div class="highlight-box" style="text-align: center;">
            <h3 style="margin-bottom: 8px;">✅ Test Strategy Complete</h3>
            <p style="font-size: 14px; color: var(--level-3); margin: 0;">
                <strong>105 total tests:</strong> 60 unit (Vitest) + 30 integration (Vitest + Testing Library) + 15 E2E (Playwright) + 20 manual scenarios
                <br>
                <strong>Coverage targets:</strong> 90%+ shared layer, 80%+ components, 100% critical paths
                <br>
                <strong>Execution time:</strong> &lt;10s unit + &lt;30s integration + ~5min E2E = &lt;6min full suite
            </p>
        </div>

    </div>

    <script>
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('open');
            });
        });
    </script>
</body>
</html>