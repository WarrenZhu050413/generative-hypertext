<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB & Screenshot CORS Deep Dive</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFAF0;
            --ink-black: #2C2C2C;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #B8860B;
            --level-4: #666;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            margin: 0;
            padding: 0;
            width: 100vw;
            max-width: 100%;
            line-height: 1.2;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro', Roboto, Arial, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            padding: 12px;
            margin: 0;
        }

        h1 {
            font-size: 24px;
            font-weight: 900;
            margin: 4px 0;
            padding: 6px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 8px 0 4px 0;
            padding: 4px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 4px 0 2px 8px;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 12px;
            font-weight: 500;
            margin: 2px 0 1px 16px;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 8px;
            margin: 8px 0;
            border-radius: 3px;
        }

        .important-always-visible h2 {
            color: var(--chinese-red);
            margin-top: 0;
        }

        .primary-section {
            border: 2px solid var(--chinese-red);
            background: white;
            margin: 6px 0;
            padding: 6px;
        }

        .secondary-section {
            border-left: 3px solid var(--chinese-gold);
            background: rgba(255, 215, 0, 0.05);
            margin: 4px 0 4px 8px;
            padding: 4px;
        }

        .tertiary-section {
            margin-left: 16px;
            padding-left: 8px;
            border-left: 1px dashed #ccc;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 2px;
            padding: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin-left: 8px;
        }

        .dense-list li {
            padding: 2px 0 2px 12px;
            border-left: 2px solid transparent;
            position: relative;
        }

        .dense-list li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.1);
            padding: 2px 4px;
            margin: 1px 0;
            font-size: 12px;
            line-height: 1.3;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Courier New', monospace;
        }

        pre {
            padding: 6px 8px;
            margin: 4px 0;
            overflow-x: auto;
            border-radius: 2px;
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 8px 0;
        }

        .full-width {
            grid-column: span 2;
        }

        .collapsible {
            margin: 4px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 6px 8px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 10px;
            margin-right: 6px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 8px;
            margin-left: 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 5000px;
            padding: 8px;
        }

        .collapsible.critical .collapsible-header {
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.08);
            font-weight: 700;
        }

        .collapsible.secondary .collapsible-header {
            border-left: 2px solid #999;
            background: rgba(0, 0, 0, 0.02);
            font-size: 13px;
        }

        .indent-1 { margin-left: 12px; }
        .indent-2 { margin-left: 24px; }
        .indent-3 { margin-left: 36px; }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 8px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 4px 0;
            font-size: 12px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 4px 6px;
            text-align: left;
            line-height: 1.2;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }

        .warning {
            background: rgba(255, 165, 0, 0.1);
            border-left: 3px solid orange;
            padding: 4px 8px;
            margin: 4px 0;
        }

        .error {
            background: rgba(255, 0, 0, 0.05);
            border-left: 3px solid red;
            padding: 4px 8px;
            margin: 4px 0;
        }

        .success {
            background: rgba(0, 128, 0, 0.05);
            border-left: 3px solid green;
            padding: 4px 8px;
            margin: 4px 0;
        }

        .info {
            background: rgba(0, 123, 255, 0.05);
            border-left: 3px solid #007bff;
            padding: 4px 8px;
            margin: 4px 0;
        }

        .example-box {
            background: rgba(138, 43, 226, 0.03);
            border: 1px solid rgba(138, 43, 226, 0.3);
            padding: 6px;
            margin: 6px 0;
            border-radius: 2px;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 8px;
            align-items: center;
            margin: 8px 0;
        }

        .vs {
            font-weight: 900;
            color: var(--chinese-red);
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç IndexedDB & Screenshot CORS Deep Dive</h1>

        <div class="important-always-visible">
            <h2>Key Misconceptions Clarified</h2>
            <ul class="dense-list">
                <li><strong>CORS Issue:</strong> Not YOUR code - it's about EXTERNAL images on the webpage you're capturing</li>
                <li><strong>Can't Bypass:</strong> Browser security prevents reading cross-origin images from canvas</li>
                <li><strong>captureVisibleTab:</strong> Captures ENTIRE viewport, not just the element (requires cropping)</li>
                <li><strong>IndexedDB:</strong> Browser-built W3C standard, not third-party</li>
            </ul>
        </div>

        <div class="divider"></div>

        <h2>1. What is IndexedDB?</h2>

        <div class="primary-section">
            <h3>Official Definition</h3>
            <p><strong>IndexedDB</strong> is a <strong>low-level API</strong> for client-side storage of structured data, including files/blobs. It's a <strong>W3C standard</strong> built into all modern browsers (Chrome, Firefox, Safari, Edge).</p>

            <div class="info" style="margin-top: 8px;">
                <strong>Built by:</strong> W3C specification, implemented by browser vendors (Google for Chrome, Mozilla for Firefox, etc.)
                <br><strong>Not a third-party dependency</strong> - it's a native browser API like <code>localStorage</code> or <code>fetch()</code>
            </div>
        </div>

        <div class="secondary-section">
            <h3>Why "Indexed" DB?</h3>
            <p class="indent-1">The name comes from its ability to create <strong>indexes</strong> on object stores for fast queries. Unlike localStorage which only has simple key-value access, IndexedDB lets you:</p>
            <ul class="dense-list indent-2">
                <li>Create multiple <strong>object stores</strong> (like tables in SQL)</li>
                <li>Define <strong>indexes</strong> on properties for fast lookups</li>
                <li>Query by index: "Find all cards where <code>domain === 'github.com'</code>"</li>
                <li>Perform range queries: "Get cards created between timestamps X and Y"</li>
            </ul>

            <div class="example-box">
                <h4>Example: Creating an Index</h4>
                <pre><code>// Create object store with indexes
const store = db.createObjectStore('cards', { keyPath: 'id' });
store.createIndex('byDomain', 'metadata.domain', { unique: false });
store.createIndex('byTimestamp', 'createdAt', { unique: false });

// Query by index (fast!)
const index = store.index('byDomain');
const results = index.getAll('github.com');  // All cards from github.com</code></pre>
                <p style="margin-top: 4px;"><strong>Result:</strong> O(log n) lookup instead of scanning all records</p>
            </div>
        </div>

        <div class="divider"></div>

        <h2>2. IndexedDB vs localStorage</h2>

        <div class="comparison">
            <div class="card priority">
                <h3>localStorage</h3>
                <ul class="dense-list">
                    <li><strong>Synchronous:</strong> Blocks UI thread</li>
                    <li><strong>Storage:</strong> ~5-10MB limit</li>
                    <li><strong>Data Types:</strong> Strings only (JSON.stringify required)</li>
                    <li><strong>API:</strong> Simple key-value</li>
                    <li><strong>Queries:</strong> Must load all data, filter manually</li>
                    <li><strong>Performance:</strong> Slow for large datasets</li>
                </ul>
                <pre><code>localStorage.setItem('key', 'value');
const val = localStorage.getItem('key');</code></pre>
            </div>

            <div class="vs">VS</div>

            <div class="card priority">
                <h3>IndexedDB</h3>
                <ul class="dense-list">
                    <li><strong>Asynchronous:</strong> Non-blocking (uses promises/callbacks)</li>
                    <li><strong>Storage:</strong> 50MB+ (browser-dependent, can be GBs)</li>
                    <li><strong>Data Types:</strong> Objects, arrays, blobs, files, typed arrays</li>
                    <li><strong>API:</strong> Object stores + indexes</li>
                    <li><strong>Queries:</strong> Index-based fast lookups</li>
                    <li><strong>Performance:</strong> Optimized for large data</li>
                </ul>
                <pre><code>const tx = db.transaction('store', 'readwrite');
await tx.objectStore('store').put(data);</code></pre>
            </div>
        </div>

        <div class="secondary-section">
            <h3>Why Nabokov Uses Both</h3>
            <table>
                <thead>
                    <tr>
                        <th>Storage</th>
                        <th>Used For</th>
                        <th>Reason</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>chrome.storage.local</code></td>
                        <td>Card metadata (HTML, tags, positions)</td>
                        <td>Simple, syncs with Chrome account, faster for small data</td>
                    </tr>
                    <tr>
                        <td><code>IndexedDB</code></td>
                        <td>Screenshots (binary image data)</td>
                        <td>Large file support, efficient blob storage</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="divider"></div>

        <h2>3. The CORS Problem (The Critical Misunderstanding)</h2>

        <div class="error">
            <h3>‚ùå Your Assumption: "I control the canvas and image code, so I can bypass CORS"</h3>
            <p><strong>Why this is wrong:</strong> The CORS restriction is NOT about YOUR extension code. It's about <strong>external images on the WEBPAGE you're trying to capture</strong>.</p>
        </div>

        <div class="primary-section">
            <h3>The Real Scenario</h3>

            <h4>What Actually Happens:</h4>
            <ol style="margin-left: 24px; line-height: 1.5; margin-top: 4px;">
                <li>User visits <code>https://example.com</code></li>
                <li>Page contains: <code>&lt;img src="https://cdn.otherdomain.com/photo.jpg"&gt;</code></li>
                <li>Your extension uses <code>captureVisibleTab()</code> ‚Üí Gets data URL of entire viewport</li>
                <li>To crop the element, you might draw the image to a canvas</li>
                <li><strong>üö® BOOM:</strong> Canvas is now "tainted" because the original webpage had cross-origin images</li>
                <li>Calling <code>canvas.toDataURL()</code> throws: <code>"Tainted canvases may not be exported"</code></li>
            </ol>

            <div class="warning" style="margin-top: 8px;">
                <strong>Key Point:</strong> Even though YOUR extension code is creating the canvas, the <strong>source image data</strong> came from a screenshot of a page with cross-origin content. The browser doesn't let you export that.
            </div>
        </div>

        <div class="collapsible critical">
            <div class="collapsible-header">
                <span><span class="arrow">‚ñ∂</span><strong>Tainted Canvas: Detailed Explanation</strong></span>
            </div>
            <div class="collapsible-content">
                <h4>What is Canvas Tainting?</h4>
                <p>A canvas becomes <strong>"tainted"</strong> when it draws content from a different origin without CORS headers. Once tainted:</p>
                <ul class="dense-list">
                    <li>‚úÖ Can still display the canvas visually</li>
                    <li>‚ùå Cannot call <code>toDataURL()</code></li>
                    <li>‚ùå Cannot call <code>toBlob()</code></li>
                    <li>‚ùå Cannot call <code>getImageData()</code></li>
                </ul>

                <h4 style="margin-top: 8px;">Example Code That Fails</h4>
                <pre><code>// This is YOUR extension code (you think you control it)
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Load screenshot from captureVisibleTab
const img = new Image();
img.src = screenshotDataUrl;  // Screenshot of page with cross-origin images

await img.decode();
ctx.drawImage(img, 0, 0);

// üö® ERROR: "Tainted canvases may not be exported"
const croppedDataUrl = canvas.toDataURL('image/png');</code></pre>

                <h4 style="margin-top: 8px;">Why You Can't Bypass It</h4>
                <div class="error">
                    <p><strong>Security Model:</strong> The browser prevents extensions from extracting pixel data that came from cross-origin resources. This stops malicious extensions from:</p>
                    <ul class="dense-list">
                        <li>Stealing images from private CDNs</li>
                        <li>Reading authentication QR codes from bank websites</li>
                        <li>Exfiltrating sensitive visual data</li>
                    </ul>
                    <p style="margin-top: 4px;"><strong>You cannot bypass this</strong> - it's a fundamental browser security feature.</p>
                </div>

                <h4 style="margin-top: 8px;">When Does It Work?</h4>
                <div class="success">
                    <p>Canvas remains untainted when:</p>
                    <ul class="dense-list">
                        <li>All images are from the same origin as the page</li>
                        <li>All cross-origin images have <code>crossorigin="anonymous"</code> attribute AND server sends CORS headers</li>
                        <li>No cross-origin content is drawn to the canvas</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <h2>4. captureVisibleTab API Behavior</h2>

        <div class="primary-section">
            <h3>What It Actually Captures</h3>
            <div class="info">
                <p><strong>Yes, you're correct:</strong> <code>chrome.tabs.captureVisibleTab()</code> captures the <strong>ENTIRE visible viewport</strong>, not just the element you clicked.</p>
            </div>

            <h4>Screenshot Dimensions</h4>
            <pre><code>// captureVisibleTab returns:
// - Width: Browser window width
// - Height: Visible viewport height (above fold)
// - Does NOT include: Scrolled content, elements outside viewport

const dataUrl = await chrome.tabs.captureVisibleTab(null, {
  format: 'png'  // Full viewport screenshot
});</code></pre>

            <h4 style="margin-top: 8px;">To Get Just the Element</h4>
            <p class="indent-1">You need to:</p>
            <ol class="dense-list indent-2">
                <li>Get element's bounding rect: <code>element.getBoundingClientRect()</code></li>
                <li>Capture full viewport with <code>captureVisibleTab()</code></li>
                <li><strong>Crop the image</strong> using canvas drawImage with source rectangle:
                    <pre style="margin-top: 4px;"><code>ctx.drawImage(img,
  rect.x, rect.y, rect.width, rect.height,  // Source crop area
  0, 0, rect.width, rect.height             // Destination
);</code></pre>
                </li>
                <li>Export cropped canvas ‚Üí This is where CORS issues happen!</li>
            </ol>

            <div class="warning" style="margin-top: 8px;">
                <strong>The Problem:</strong> Step 4 (exporting cropped canvas) fails if the original page had cross-origin images, even if those images weren't in the cropped area.
            </div>
        </div>

        <div class="divider"></div>

        <h2>5. Active Tab Permission</h2>

        <div class="card priority full-width">
            <h3>How to Grant activeTab Permission</h3>
            <p><strong>Location:</strong> <code>src/manifest.json</code></p>

            <h4>In Your Manifest</h4>
            <pre><code>{
  "manifest_version": 3,
  "name": "Nabokov Web Clipper",
  "permissions": [
    "activeTab",     // ‚Üê Grants temporary access to current tab
    "storage"
  ],
  // ...
}</code></pre>

            <h4 style="margin-top: 8px;">What activeTab Provides</h4>
            <ul class="dense-list">
                <li><strong>Temporary Access:</strong> Only when user invokes extension (clicks icon, uses keyboard shortcut)</li>
                <li><strong>Capabilities:</strong>
                    <ul class="dense-list indent-1">
                        <li>Inject content scripts</li>
                        <li>Capture visible tab (<code>captureVisibleTab</code>)</li>
                        <li>Access tab URL, title</li>
                    </ul>
                </li>
                <li><strong>Duration:</strong> Access expires when user navigates away or closes tab</li>
                <li><strong>Privacy:</strong> Better than <code>"tabs"</code> permission (doesn't require declaring host permissions)</li>
            </ul>

            <div class="info" style="margin-top: 8px;">
                <strong>Your Extension:</strong> Likely already has <code>"activeTab"</code> in manifest.json, which is why <code>captureVisibleTab()</code> works when triggered by <code>Cmd+Shift+E</code>
            </div>
        </div>

        <div class="collapsible secondary">
            <div class="collapsible-header">
                <span><span class="arrow">‚ñ∂</span>Alternative: Host Permissions (More Invasive)</span>
            </div>
            <div class="collapsible-content">
                <pre><code>{
  "permissions": ["tabs"],
  "host_permissions": [
    "https://*/*",  // Access all HTTPS sites
    "http://*/*"    // Access all HTTP sites
  ]
}</code></pre>
                <p><strong>Difference:</strong> <code>activeTab</code> = temporary, user-triggered. <code>host_permissions</code> = permanent, always active (requires more user trust).</p>
            </div>
        </div>

        <div class="divider"></div>

        <h2>6. How Nabokov Handles This</h2>

        <div class="primary-section">
            <h3>Current Strategy: Optional Screenshot</h3>

            <div class="success">
                <p><strong>Smart Approach:</strong> Make screenshot capture optional and fail gracefully</p>
            </div>

            <pre><code>async function captureElement(element: HTMLElement): Promise&lt;Card&gt; {
  // 1. Always capture HTML (works reliably)
  const html = sanitizeHTML(element.outerHTML);

  // 2. Try screenshot (may fail due to CORS)
  let screenshotId = undefined;
  try {
    const screenshot = await chrome.tabs.captureVisibleTab(null, { format: 'png' });
    const rect = element.getBoundingClientRect();

    // Crop to element (THIS is where it might fail)
    const cropped = await cropImage(screenshot, rect);

    // Compress and save
    screenshotId = await saveToIndexedDB(cropped);
  } catch (error) {
    console.warn('Screenshot failed (CORS or other issue):', error);
    // Continue without screenshot - card still has HTML content!
  }

  return {
    id: generateId(),
    content: html,
    screenshotId,  // undefined if failed
    // ... other fields
  };
}</code></pre>

            <h4 style="margin-top: 8px;">Why This Works</h4>
            <ul class="dense-list">
                <li>‚úÖ HTML capture always succeeds (no CORS issues with DOM)</li>
                <li>‚úÖ Screenshot is a nice-to-have enhancement</li>
                <li>‚úÖ Cards work perfectly even without screenshots</li>
                <li>‚úÖ User doesn't see errors - just missing image</li>
            </ul>
        </div>

        <div class="collapsible secondary">
            <div class="collapsible-header">
                <span><span class="arrow">‚ñ∂</span>Alternative: Use Full Screenshot (No Cropping)</span>
            </div>
            <div class="collapsible-content">
                <div class="info">
                    <p><strong>Workaround:</strong> Save the FULL viewport screenshot without cropping</p>
                </div>
                <pre><code>// Don't crop - save full screenshot + element rect
const screenshot = await chrome.tabs.captureVisibleTab(null, { format: 'png' });
const rect = element.getBoundingClientRect();

await saveToIndexedDB({
  fullScreenshot: screenshot,  // Full viewport
  cropRect: rect,              // Element position
});

// Later, crop on display (not for export)
// Show only the element area in UI using CSS clip-path or cropping during render</code></pre>
                <p><strong>Benefit:</strong> No canvas export needed (avoids CORS entirely)</p>
                <p><strong>Drawback:</strong> Larger file size (storing full screenshots)</p>
            </div>
        </div>

        <div class="divider"></div>

        <h2>7. Summary Table</h2>

        <table>
            <thead>
                <tr>
                    <th>Topic</th>
                    <th>Key Facts</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>IndexedDB</strong></td>
                    <td>
                        ‚Ä¢ W3C standard, browser-built (not third-party)<br>
                        ‚Ä¢ "Indexed" = supports indexes for fast queries<br>
                        ‚Ä¢ Async, 50MB+, stores objects/blobs<br>
                        ‚Ä¢ vs localStorage: sync, 5-10MB, strings only
                    </td>
                </tr>
                <tr>
                    <td><strong>CORS Issue</strong></td>
                    <td>
                        ‚Ä¢ Caused by cross-origin images on TARGET webpage<br>
                        ‚Ä¢ Not about YOUR extension code<br>
                        ‚Ä¢ Cannot bypass (browser security feature)<br>
                        ‚Ä¢ Taints canvas when drawing cross-origin content
                    </td>
                </tr>
                <tr>
                    <td><strong>Tainted Canvas</strong></td>
                    <td>
                        ‚Ä¢ Canvas that drew cross-origin content<br>
                        ‚Ä¢ Can display, but cannot export (toDataURL/toBlob)<br>
                        ‚Ä¢ Security: prevents pixel data extraction
                    </td>
                </tr>
                <tr>
                    <td><strong>activeTab Permission</strong></td>
                    <td>
                        ‚Ä¢ Declared in manifest.json<br>
                        ‚Ä¢ Temporary access on user interaction<br>
                        ‚Ä¢ Enables captureVisibleTab, content script injection<br>
                        ‚Ä¢ More privacy-friendly than host_permissions
                    </td>
                </tr>
                <tr>
                    <td><strong>captureVisibleTab</strong></td>
                    <td>
                        ‚Ä¢ Captures ENTIRE visible viewport<br>
                        ‚Ä¢ Requires cropping to get just the element<br>
                        ‚Ä¢ Cropping uses canvas ‚Üí CORS issues appear here<br>
                        ‚Ä¢ Alternative: Store full screenshot + crop rect
                    </td>
                </tr>
            </tbody>
        </table>

        <div class="divider"></div>

        <div class="important-always-visible">
            <h2>üéØ Direct Answers to Your Questions</h2>
            <ol style="margin-left: 24px; line-height: 1.5;">
                <li><strong>IndexedDB "Indexed"?</strong> Refers to database indexes for fast queries (like SQL indexes)</li>
                <li><strong>Built by Chrome?</strong> No - W3C standard, implemented by all browser vendors</li>
                <li><strong>Different from localStorage?</strong> Async, 50MB+, supports objects/blobs, has indexes (vs localStorage: sync, 5-10MB, strings)</li>
                <li><strong>CORS bypass?</strong> No - the issue is EXTERNAL images on webpages you capture, not your code</li>
                <li><strong>Tainted canvas?</strong> Canvas that drew cross-origin content, cannot export to prevent data theft</li>
                <li><strong>activeTab permission?</strong> Declared in manifest.json, grants temporary access on user interaction</li>
                <li><strong>captureVisibleTab captures full viewport?</strong> Yes - requires manual cropping, which is where CORS issues occur</li>
            </ol>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const collapsibles = document.querySelectorAll('.collapsible-header');
            collapsibles.forEach(header => {
                header.addEventListener('click', () => {
                    header.parentElement.classList.toggle('open');
                });
            });
            // Auto-open critical sections
            document.querySelectorAll('.collapsible.critical').forEach(el => {
                el.classList.add('open');
            });
        });
    </script>
</body>
</html>