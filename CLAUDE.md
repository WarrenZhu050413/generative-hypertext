# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Nabokov Web Clipper is a Chrome extension (Manifest V3) for capturing web content and organizing it on a visual canvas. Built with React, TypeScript, and React Flow.

Research citation: Zhu, F. W., Agrawala, M., & Mysore, G. J. (2024). Nabokov: Organize Web Content with LLM-Powered Visual Canvas. UIST '24 Companion, Article 42, 1-3. https://doi.org/10.1145/3698061.3726916

## Development Commands

```bash
# Install dependencies
npm install

# Build extension (TypeScript + Vite)
npm run build

# Watch mode for development
npm run watch:extension

# Type checking (always run before committing)
npm run type-check

# Unit tests (Vitest)
npm test                  # Run once
npm run test:watch        # Watch mode
npm run test:coverage     # With coverage

# E2E tests (Playwright) - requires built extension
npm run test:e2e          # Headless
npm run test:e2e:headed   # With browser UI
npm run test:e2e:debug    # Debug mode

# Manual testing with Playwright (bypasses chrome://extensions)
node test-scripts/test-canvas-direct.mjs
```

## Architecture

### Chrome Extension Structure

**Three execution contexts:**

1. **Background Service Worker** (`src/background/index.ts`)
   - Manifest V3 service worker
   - Handles keyboard commands (`Cmd+Shift+E`)
   - Context menu registration
   - Screenshot capture via `chrome.tabs.captureVisibleTab()`
   - Opens canvas on toolbar icon click

2. **Content Script** (`src/content/index.tsx`)
   - Injected into all pages (`<all_urls>`)
   - Listens for `ACTIVATE_SELECTOR` messages
   - Mounts `ElementSelector` component into Shadow DOM
   - Shadow DOM isolation prevents CSS conflicts

3. **Canvas Page** (`src/canvas/index.html`)
   - Standalone React app
   - React Flow for node-based canvas
   - Accessed via `chrome-extension://<id>/src/canvas/index.html`

### Data Flow

**Element Capture Flow:**
```
User presses Cmd+Shift+E
â†’ Background worker sends ACTIVATE_SELECTOR message
â†’ Content script mounts ElementSelector in Shadow DOM
â†’ User clicks element
â†’ Capture pipeline:
  1. Extract HTML + sanitize (DOMPurify)
  2. Capture screenshot via background worker
  3. Compress screenshot (canvas-based compression)
  4. Generate unique ID (timestamp + random)
  5. Save Card to chrome.storage.local
  6. Save Screenshot to IndexedDB
â†’ Canvas auto-refreshes to show new card
```

**Storage Architecture:**
- **chrome.storage.local**: Card metadata (limit: ~5MB after JSON serialization)
  - Key: `'cards'` â†’ `Card[]`
  - Key: `'nabokov_canvas_state'` â†’ `CanvasState` (positions, zoom)
  - Key: `'nabokov_filters'` â†’ `FilterState`
  - Key: `'nabokov_connections'` â†’ `Connection[]` (card relationships/arrows)
  - Key: `'nabokov_claude_api_key'` â†’ `string` (Claude API key for LLM features)
- **IndexedDB**: Screenshots (limit: much larger, browser-dependent)
  - Database: `'nabokov-clipper'`
  - Store: `'screenshots'`
  - Key: `screenshotId` (matches `Card.screenshotId`)

### Core Type: Card

```typescript
interface Card {
  id: string;                    // Generated by generateId()
  content?: string;              // Sanitized HTML (optional for image-only cards)
  metadata: ClipMetadata;        // url, title, domain, favicon, etc.
  position?: CardPosition;       // Canvas x, y
  size?: CardSize;              // Canvas width, height
  starred: boolean;
  tags: string[];
  createdAt: number;
  updatedAt: number;
  conversation?: Message[];      // Chat history with Claude
  screenshotId?: string;        // Reference to IndexedDB screenshot
  styles?: RelevantStyles;      // Computed CSS for rendering
  context?: string;             // Parent element HTML
  cardType?: 'clipped' | 'generated' | 'note' | 'image';  // Source type
  parentCardId?: string;        // For generated cards (parent relationship)
  generationContext?: {         // Metadata for AI-generated cards
    sourceMessageId: string;
    userPrompt: string;
    timestamp: number;
  };
  imageData?: string;           // Base64 data URL for image cards
  imageDimensions?: {           // Original dimensions for image cards
    width: number;
    height: number;
  };
}
```

### Build System

- **Vite** with `@crxjs/vite-plugin` for Chrome extension support
- **Path aliases**: `@/`, `@components/`, `@utils/`, `@types/`
- **Emotion CSS-in-JS**: Uses `@emotion/react` with JSX pragma
- Build output: `dist/` (git-ignored)
- Manifest copied from `src/manifest.json` â†’ `dist/manifest.json`

### Key Components

**ElementSelector** (`src/components/ElementSelector.tsx`)
- Renders in Shadow DOM to isolate styles
- Visual overlay with Chinese aesthetic (red/gold colors)
- Element info tooltip (tag, classes, dimensions)
- Handles keyboard (ESC to exit)
- Screenshot capture is **optional and non-blocking** (fails silently if blocked by CORS)

**Canvas** (`src/canvas/Canvas.tsx`)
- React Flow wrapper
- Loads cards via `useCanvasState` hook
- Converts Card[] â†’ ReactFlow Node[]
- Debounced auto-save (2 seconds) for position/size changes
- Filter/search bar (Toolbar component)
- Keyboard shortcuts system:
  - `Cmd/Ctrl+N`: Create new note card
  - `Delete/Backspace`: Delete selected cards
  - Arrow keys: Navigate between cards
  - Other shortcuts defined in `src/canvas/keyboardShortcuts.css`

**CardNode** (`src/canvas/CardNode.tsx`)
- Custom React Flow node type
- **Critical**: Always check `card.tags && card.tags.length` (tags may be undefined on old cards)
- Displays sanitized content preview, metadata, tags
- Supports inline editing (double-click content to edit)
- Chinese aesthetic styling

**ChatModal** (`src/canvas/ChatModal.tsx`)
- Modal dialog for conversations with cards
- Maintains chat history in `Card.conversation` array
- Streaming LLM responses (via `mockClaudeAPI`)
- Keyboard: Enter to send, Shift+Enter for newline, Escape to close

**FloatingWindow** (`src/components/FloatingWindow.tsx`)
- Draggable, resizable windows for card interactions
- Used for chat interface (`FloatingWindowChat`)
- Auto-saves conversation on close (optional)
- Supports persistence across sessions

**Toast** (`src/components/Toast.tsx`)
- Notification system for user feedback
- Types: `'loading'`, `'success'`, `'error'`, `'info'`
- Auto-dismiss with configurable duration (0 = no auto-dismiss)
- Used for API calls, card generation, beautification feedback

**Card Generation System**
- **ContextInputModal** (`src/components/ContextInputModal.tsx`): Prompts for context before generating cards
- **cardGenerationService** (`src/services/cardGenerationService.ts`): Generates new cards from button actions
- **Custom Buttons**: Configurable action buttons with template-based prompts
  - Default buttons: Learn More, Summarize, Critique, ELI5, Expand (see `src/config/defaultButtons.ts`)
  - Template variables: `{{content}}`, `{{title}}`, `{{customContext}}`
  - Each button specifies connection type: `'references'`, `'generated-from'`, `'related'`
- Generated cards linked to parent via `parentCardId` and visual arrows
- Auto-creates connections between parent and generated cards
- Uses real Claude API when configured, falls back to mock responses for development

**Claude API Integration**
- **claudeAPIService** (`src/services/claudeAPIService.ts`): Real Anthropic Claude API integration
- **apiConfigService** (`src/services/apiConfig.ts`): Secure API key management
- **APISettings** (`src/components/APISettings.tsx`): UI for API key configuration
- Supports text-only and vision (screenshot analysis) modes
- Default model: `claude-sonnet-4-20250514`
- API key stored securely in chrome.storage.local

**Beautification System**
- **beautificationService** (`src/services/beautificationService.ts`): AI-powered card content enhancement
- Two modes:
  - `'recreate-design'`: Recreate visual design from screenshot with clean HTML
  - `'organize-content'`: Restructure content for better readability
- Uses Claude API with vision capabilities for screenshot analysis
- Always sanitizes output with DOMPurify before storing
- Falls back to mock content in development mode

## Critical Implementation Details

### Screenshot Capture

Screenshot capture can fail due to:
- CORS restrictions (cross-origin images)
- Canvas tainting
- Missing activeTab permission

**Always make screenshot capture optional:**
```typescript
let compressionResult = null;
try {
  const screenshot = await captureElementScreenshot(element);
  compressionResult = await compressScreenshot(screenshot);
} catch (error) {
  console.warn('Screenshot failed (non-blocking):', error);
  // Continue without screenshot
}

const card: Card = {
  // ...
  screenshotId: compressionResult ? screenshotId : undefined,
};
```

### Extension Reload Requirement

After running `npm run build`, Chrome caches the old code. **You must reload the extension:**
1. Navigate to `chrome://extensions`
2. Click the reload icon (ðŸ”„) on the extension card
3. Refresh any open Canvas pages

### Testing Chrome Extensions

**Standard Playwright cannot load Chrome extensions.** Use persistent context with extension loading:

```javascript
import { chromium } from 'playwright';
const ctx = await chromium.launchPersistentContext('', {
  args: [
    '--disable-extensions-except=/path/to/dist',
    '--load-extension=/path/to/dist'
  ]
});
```

Test scripts in `test-scripts/` use this pattern to test the extension without navigating to `chrome://extensions`.

### Path Resolution in Test Scripts

Test scripts moved to `test-scripts/` must use `path.join(__dirname, '..', 'dist')` not `path.join(__dirname, 'dist')`.

### Card Relationships and Connections

**Connection storage** (`src/utils/connectionStorage.ts`):
- Arrows between cards stored in `chrome.storage.local` under key `'nabokov_connections'`
- Each connection has: `id`, `source` (card ID), `target` (card ID), `createdAt`, `connectionType`, optional `label`
- Use `addConnection(sourceId, targetId, connectionType)` to create relationships
- Canvas automatically renders connections as React Flow edges
- Connection types: `'related'`, `'generated-from'`, `'references'`, `'contradicts'`, `'custom'`
- **EdgeEditModal**: UI for editing connection type and custom labels (click on edge to edit)

**Card types and workflows**:
- `'clipped'`: User-captured content via element selector
- `'note'`: Manual note creation (Cmd+N)
- `'generated'`: AI-generated from button actions (linked via `parentCardId`)
- `'image'`: Drag-and-drop image upload (stored as base64 in `imageData`)

### Inline Editing

Cards support inline editing on the canvas:
- **Trigger**: Double-click card content area
- **Implementation**: Uses `contentEditable` div with DOMPurify sanitization
- **Save**: Auto-saves on blur or Cmd/Ctrl+Enter
- **Cancel**: Escape key to revert
- **Critical**: Always sanitize edited content before saving to storage

### Image Upload

Drag-and-drop image upload to canvas:
- **Implementation**: `src/utils/imageUpload.ts`
- **Trigger**: Drag image file onto canvas
- **Storage**: Images converted to base64 data URLs and stored in `Card.imageData`
- **Validation**: Only accepts files with `image/*` MIME type
- **Dimensions**: Original dimensions preserved in `Card.imageDimensions`
- **Card type**: Created as `cardType: 'image'` with optional `content`

### State Refresh Pattern

**Critical**: Never use `window.location.reload()` for state updates. Use event-based refresh:

```typescript
// After modifying cards/connections
window.dispatchEvent(new CustomEvent('nabokov:cards-updated'));

// In useCanvasState.ts, listener auto-refreshes canvas
useEffect(() => {
  const handleCardUpdate = () => {
    loadCards(); // Refresh from storage
  };
  window.addEventListener('nabokov:cards-updated', handleCardUpdate);
  return () => window.removeEventListener('nabokov:cards-updated', handleCardUpdate);
}, []);
```

This pattern eliminates race conditions and provides faster UX than full page reloads.

## Common Issues

**"Cannot read properties of undefined (reading 'length')"** in Canvas
- Usually `card.tags.length` when `tags` is undefined
- Always use `card.tags && card.tags.length` or `card.tags?.length`
- Similarly check `card.content` (optional for image-only cards)

**"Tainted canvases may not be exported"**
- CORS issue with screenshot capture
- Already handled with try-catch wrapper (non-blocking)

**"Claude API key not configured"**
- User must set API key via APISettings component
- Check `apiConfigService.hasAPIKey()` before making API calls
- Service automatically falls back to mock responses in development

**Extension not updating after build**
- Must manually reload extension in `chrome://extensions`
- Playwright tests always load fresh code

**Content script not responding**
- Check manifest: `"matches": ["<all_urls>"]`
- Check `run_at: "document_idle"` (waits for DOM)
- Background worker timing issue (expected, non-critical)

**Cards not appearing after creation in tests**
- Likely storage timing issue with chrome.storage.local
- Use `waitForTimeout(3000)` for async storage operations
- Check console for `[cardGenerationService]` debug logs

## File Organization

```
src/
  background/       # Service worker
  content/          # Content script injection
  components/       # React components (ElementSelector, FloatingWindow, etc.)
  canvas/           # Canvas app (separate React app)
  services/         # API services (Claude API, beautification, card generation)
  config/           # Configuration (default buttons, etc.)
  utils/            # Storage, screenshot, sanitization, image upload
  types/            # TypeScript types (card.ts is source of truth)
  manifest.json     # Extension manifest

test-scripts/       # Manual Playwright tests (bypass chrome://extensions)
tests/              # Vitest unit tests, Playwright E2E
docs/               # Documentation
archive/            # Old implementations (nabokov-clipper/, deprecated tests)
```

## Code Style Notes

- Use `console.log` with prefixes: `[Canvas]`, `[storage]`, `[ElementSelector]`, `[cardGenerationService]`, `[ClaudeAPI]`, `[beautificationService]`
- Shadow DOM components need `/** @jsxImportSource @emotion/react */` pragma
- Always sanitize HTML with DOMPurify before storing (especially for `contentEditable` input, LLM responses, beautified content)
- Use `generateId()` from `@/utils/storage` for all IDs
- Error handling: Fail gracefully, log warnings for non-critical failures
- LLM integration:
  - Real API via `claudeAPIService` when API key configured
  - Falls back to mock responses in development mode
  - Always check `apiConfigService.hasAPIKey()` before API calls

## Testing Strategy

**Unit tests**: Utils, sanitization, storage logic (Vitest + jsdom)
**E2E tests**: Extension loading, element capture, canvas rendering (Playwright)
**Manual tests**: `test-scripts/*.mjs` for quick verification without test harness
