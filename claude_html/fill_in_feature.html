<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fill It In Feature - Nabokov Web Clipper</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #e0e0e0;
        }
        h1, h2, h3 { color: #ffd700; border-left: 4px solid #dc143c; padding-left: 1rem; }
        .hero {
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 100%);
            padding: 2rem;
            border-radius: 12px;
            margin: 2rem 0;
            box-shadow: 0 8px 32px rgba(220, 20, 60, 0.3);
        }
        .hero h2 { border: none; color: #ffd700; }
        .workflow {
            background: #2a2a2a;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #4a90e2;
        }
        .code-block {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        .visual-demo {
            background: #1a1a1a;
            border: 2px dashed #4a90e2;
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
            font-family: monospace;
            white-space: pre;
            line-height: 1.8;
        }
        .feature-box {
            background: linear-gradient(135deg, #2a4858 0%, #3a5868 100%);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #ffd700;
        }
        .implementation-step {
            background: #2a2a2a;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
            border-left: 3px solid #dc143c;
        }
        .note {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        code {
            background: #1a1a1a;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            color: #4a90e2;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        ul, ol { padding-left: 2rem; }
        li { margin: 0.5rem 0; }
        .advantage { color: #90EE90; }
        .challenge { color: #FFB6C1; }
    </style>
</head>
<body>
    <h1>🔗✨ Fill It In Feature</h1>

    <div class="hero">
        <h2>🎯 Develop Ideas Through Connection-Based Synthesis</h2>
        <p><strong>Concept:</strong> Create a sparse note with a basic idea, connect it to relevant existing notes, then use AI to synthesize and integrate information from connected notes to fully develop the new note.</p>
        <p><strong>Why It's Powerful:</strong> Transforms Nabokov from a passive storage system into an active thinking partner that helps you elaborate ideas by intelligently combining knowledge from your existing notes.</p>
    </div>

    <h2>📋 User Workflow</h2>

    <div class="visual-demo">
<span style="color: #ffd700;">Step 1: Create sparse note</span>
┌─────────────────────────┐
│ 💡 "Neural networks    │  <-- User creates basic note (Cmd+N)
│  for time series"      │      with just a title or brief idea
└─────────────────────────┘

<span style="color: #ffd700;">Step 2: Connect to relevant notes</span>
        ┌──────────────┐
        │ RNN basics   │
        │ (from paper) │
        └──────────────┘
               ↓
┌──────────────▼────────────┐         ┌──────────────┐
│ 💡 Neural networks        │←────────│ LSTM gates   │
│  for time series          │         │ (clipped)    │
│                           │         └──────────────┘
│ [Empty - needs filling]   │
└───────────────────────────┘
               ↑
        ┌──────────────┐
        │ Forecasting  │
        │ techniques   │
        └──────────────┘

<span style="color: #ffd700;">Step 3: Trigger "Fill it in"</span>
User right-clicks → "Fill in from connections"
OR clicks "🔗 Fill In" button in card header

<span style="color: #ffd700;">Step 4: AI synthesizes content</span>
┌────────────────────────────────────┐
│ 💡 Neural networks for time series │
│                                    │
│ <span style="color: #90EE90;">[Generated content]</span>              │
│ Neural networks are particularly   │
│ well-suited for time series due to │
│ their ability to capture temporal  │
│ dependencies. RNNs process         │
│ sequential data by maintaining     │
│ hidden states... LSTMs extend this │
│ with gating mechanisms (forget,    │
│ input, output gates) that help     │
│ preserve long-range dependencies...│
│                                    │
│ For forecasting applications,      │
│ encoder-decoder architectures...   │
└────────────────────────────────────┘
    </div>

    <div class="workflow">
        <h3>Detailed Workflow</h3>
        <ol>
            <li><strong>Create Note:</strong> User creates a new note card with a title or brief idea</li>
            <li><strong>Establish Connections:</strong> User draws arrows to connect to 3-5 relevant existing cards</li>
            <li><strong>Trigger Fill-In:</strong> User activates the feature via:
                <ul>
                    <li>Right-click context menu → "Fill in from connections"</li>
                    <li>Button in card header (shows count: "🔗 Fill In (4 cards)")</li>
                    <li>Keyboard shortcut: <code>Cmd+Shift+F</code></li>
                </ul>
            </li>
            <li><strong>Preview Mode:</strong> Modal shows:
                <ul>
                    <li>List of connected cards that will contribute</li>
                    <li>Fill-in strategy options (replace, append, merge)</li>
                    <li>Tone/style controls (academic, creative, concise)</li>
                </ul>
            </li>
            <li><strong>Generation:</strong> System streams AI response into card content</li>
            <li><strong>Review & Edit:</strong> User can edit, accept, or regenerate</li>
            <li><strong>Iterate:</strong> User can connect more cards and fill in again to further develop</li>
        </ol>
    </div>

    <h2>🏗️ Technical Implementation</h2>

    <div class="implementation-step">
        <h3>Step 1: Data Model Extensions</h3>
        <p>Extend Card interface to track fill-in metadata:</p>
        <div class="code-block">
<span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">Card</span> {
  <span style="color: #9cdcfe;">id</span>: <span style="color: #4ec9b0;">string</span>;
  <span style="color: #9cdcfe;">content</span>: <span style="color: #4ec9b0;">string</span>;
  <span style="color: #6a9955;">// ... existing fields</span>

  <span style="color: #6a9955;">// New: Track fill-in history</span>
  <span style="color: #9cdcfe;">fillInHistory</span>?: {
    <span style="color: #9cdcfe;">timestamp</span>: <span style="color: #4ec9b0;">number</span>;
    <span style="color: #9cdcfe;">sourceCardIds</span>: <span style="color: #4ec9b0;">string</span>[];      <span style="color: #6a9955;">// Which cards contributed</span>
    <span style="color: #9cdcfe;">strategy</span>: <span style="color: #ce9178;">'replace'</span> | <span style="color: #ce9178;">'append'</span> | <span style="color: #ce9178;">'merge'</span>;
    <span style="color: #9cdcfe;">userPrompt</span>?: <span style="color: #4ec9b0;">string</span>;         <span style="color: #6a9955;">// Optional user guidance</span>
    <span style="color: #9cdcfe;">previousContent</span>?: <span style="color: #4ec9b0;">string</span>;     <span style="color: #6a9955;">// For undo</span>
  }[];
}

<span style="color: #6a9955;">// Connection interface (already exists)</span>
<span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">CardConnection</span> {
  <span style="color: #9cdcfe;">id</span>: <span style="color: #4ec9b0;">string</span>;
  <span style="color: #9cdcfe;">source</span>: <span style="color: #4ec9b0;">string</span>;      <span style="color: #6a9955;">// Card ID</span>
  <span style="color: #9cdcfe;">target</span>: <span style="color: #4ec9b0;">string</span>;      <span style="color: #6a9955;">// Card ID</span>
  <span style="color: #9cdcfe;">createdAt</span>: <span style="color: #4ec9b0;">number</span>;
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 2: Connection Context Service</h3>
        <p>Create <code>src/services/connectionContextService.ts</code> to gather connected cards:</p>
        <div class="code-block">
<span style="color: #c586c0;">import</span> { Card, CardConnection } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/types/card'</span>;
<span style="color: #c586c0;">import</span> { getConnections } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/utils/connectionStorage'</span>;

<span style="color: #6a9955;">/**
 * Get all cards connected to the target card
 * @param cardId - The card to find connections for
 * @param allCards - All available cards
 * @param direction - Include incoming, outgoing, or both connections
 */</span>
<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">async</span> <span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">getConnectedCards</span>(
  <span style="color: #9cdcfe;">cardId</span>: <span style="color: #4ec9b0;">string</span>,
  <span style="color: #9cdcfe;">allCards</span>: <span style="color: #4ec9b0;">Card</span>[],
  <span style="color: #9cdcfe;">direction</span>: <span style="color: #ce9178;">'incoming'</span> | <span style="color: #ce9178;">'outgoing'</span> | <span style="color: #ce9178;">'both'</span> = <span style="color: #ce9178;">'both'</span>
): <span style="color: #4ec9b0;">Promise</span>&lt;<span style="color: #4ec9b0;">Card</span>[]&gt; {
  <span style="color: #569cd6;">const</span> connections = <span style="color: #569cd6;">await</span> <span style="color: #dcdcaa;">getConnections</span>();

  <span style="color: #569cd6;">const</span> connectedIds = <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Set</span>&lt;<span style="color: #4ec9b0;">string</span>&gt;();

  connections.<span style="color: #dcdcaa;">forEach</span>(<span style="color: #9cdcfe;">conn</span> <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #c586c0;">if</span> (direction === <span style="color: #ce9178;">'outgoing'</span> || direction === <span style="color: #ce9178;">'both'</span>) {
      <span style="color: #c586c0;">if</span> (conn.source === cardId) connectedIds.<span style="color: #dcdcaa;">add</span>(conn.target);
    }
    <span style="color: #c586c0;">if</span> (direction === <span style="color: #ce9178;">'incoming'</span> || direction === <span style="color: #ce9178;">'both'</span>) {
      <span style="color: #c586c0;">if</span> (conn.target === cardId) connectedIds.<span style="color: #dcdcaa;">add</span>(conn.source);
    }
  });

  <span style="color: #c586c0;">return</span> allCards.<span style="color: #dcdcaa;">filter</span>(<span style="color: #9cdcfe;">card</span> <span style="color: #569cd6;">=&gt;</span> connectedIds.<span style="color: #dcdcaa;">has</span>(card.id));
}

<span style="color: #6a9955;">/**
 * Merge contexts from multiple connected cards
 */</span>
<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">buildFillInContext</span>(<span style="color: #9cdcfe;">connectedCards</span>: <span style="color: #4ec9b0;">Card</span>[]): <span style="color: #4ec9b0;">string</span> {
  <span style="color: #c586c0;">return</span> connectedCards
    .<span style="color: #dcdcaa;">map</span>((<span style="color: #9cdcfe;">card</span>, <span style="color: #9cdcfe;">index</span>) <span style="color: #569cd6;">=&gt;</span> {
      <span style="color: #569cd6;">const</span> header = [
        <span style="color: #ce9178;">`[Connected Card </span><span style="color: #569cd6;">${</span>index + <span style="color: #b5cea8;">1</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">: </span><span style="color: #569cd6;">${</span>card.metadata.title<span style="color: #569cd6;">}</span><span style="color: #ce9178;">]`</span>,
        <span style="color: #ce9178;">`Source: </span><span style="color: #569cd6;">${</span>card.metadata.url<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>,
        <span style="color: #ce9178;">`Type: </span><span style="color: #569cd6;">${</span>card.cardType || <span style="color: #ce9178;">'clipped'</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>,
      ].<span style="color: #dcdcaa;">join</span>(<span style="color: #ce9178;">'\n'</span>);

      <span style="color: #569cd6;">const</span> content = card.content || <span style="color: #ce9178;">'[No content]'</span>;

      <span style="color: #c586c0;">return</span> <span style="color: #ce9178;">`</span><span style="color: #569cd6;">${</span>header<span style="color: #569cd6;">}</span><span style="color: #ce9178;">\n\n</span><span style="color: #569cd6;">${</span>content<span style="color: #569cd6;">}</span><span style="color: #ce9178;">\n\n---`</span>;
    })
    .<span style="color: #dcdcaa;">join</span>(<span style="color: #ce9178;">'\n\n'</span>);
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 3: Fill-In Service</h3>
        <p>Create <code>src/services/fillInService.ts</code> with AI integration:</p>
        <div class="code-block">
<span style="color: #c586c0;">import</span> { Card } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/types/card'</span>;
<span style="color: #c586c0;">import</span> { getConnectedCards, buildFillInContext } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'./connectionContextService'</span>;
<span style="color: #c586c0;">import</span> { mockClaudeAPI } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'./chatService'</span>;

<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">type</span> <span style="color: #4ec9b0;">FillInStrategy</span> = <span style="color: #ce9178;">'replace'</span> | <span style="color: #ce9178;">'append'</span> | <span style="color: #ce9178;">'merge'</span>;

<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">FillInOptions</span> {
  <span style="color: #9cdcfe;">strategy</span>: <span style="color: #4ec9b0;">FillInStrategy</span>;
  <span style="color: #9cdcfe;">userPrompt</span>?: <span style="color: #4ec9b0;">string</span>;         <span style="color: #6a9955;">// Optional guidance</span>
  <span style="color: #9cdcfe;">tone</span>?: <span style="color: #ce9178;">'academic'</span> | <span style="color: #ce9178;">'creative'</span> | <span style="color: #ce9178;">'concise'</span>;
}

<span style="color: #6a9955;">/**
 * Generate content for a card based on its connections
 */</span>
<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">async</span> <span style="color: #569cd6;">function</span>* <span style="color: #dcdcaa;">fillInFromConnections</span>(
  <span style="color: #9cdcfe;">targetCard</span>: <span style="color: #4ec9b0;">Card</span>,
  <span style="color: #9cdcfe;">allCards</span>: <span style="color: #4ec9b0;">Card</span>[],
  <span style="color: #9cdcfe;">options</span>: <span style="color: #4ec9b0;">FillInOptions</span>
): <span style="color: #4ec9b0;">AsyncGenerator</span>&lt;<span style="color: #4ec9b0;">string</span>, <span style="color: #4ec9b0;">void</span>, <span style="color: #4ec9b0;">unknown</span>&gt; {
  <span style="color: #6a9955;">// 1. Get connected cards</span>
  <span style="color: #569cd6;">const</span> connectedCards = <span style="color: #569cd6;">await</span> <span style="color: #dcdcaa;">getConnectedCards</span>(targetCard.id, allCards);

  <span style="color: #c586c0;">if</span> (connectedCards.length === <span style="color: #b5cea8;">0</span>) {
    <span style="color: #c586c0;">throw</span> <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Error</span>(<span style="color: #ce9178;">'No connected cards found. Please connect this card to other notes first.'</span>);
  }

  <span style="color: #6a9955;">// 2. Build context from connections</span>
  <span style="color: #569cd6;">const</span> context = <span style="color: #dcdcaa;">buildFillInContext</span>(connectedCards);

  <span style="color: #6a9955;">// 3. Build system prompt based on strategy</span>
  <span style="color: #569cd6;">const</span> systemPrompt = <span style="color: #dcdcaa;">buildSystemPrompt</span>(options);

  <span style="color: #6a9955;">// 4. Build user prompt</span>
  <span style="color: #569cd6;">const</span> userPrompt = <span style="color: #dcdcaa;">buildUserPrompt</span>(targetCard, context, options);

  <span style="color: #6a9955;">// 5. Stream response from LLM</span>
  <span style="color: #569cd6;">const</span> generator = <span style="color: #dcdcaa;">mockClaudeAPI</span>(systemPrompt, userPrompt);

  <span style="color: #c586c0;">for</span> <span style="color: #c586c0;">await</span> (<span style="color: #569cd6;">const</span> chunk <span style="color: #569cd6;">of</span> generator) {
    <span style="color: #c586c0;">yield</span> chunk;
  }
}

<span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">buildSystemPrompt</span>(<span style="color: #9cdcfe;">options</span>: <span style="color: #4ec9b0;">FillInOptions</span>): <span style="color: #4ec9b0;">string</span> {
  <span style="color: #569cd6;">const</span> toneInstructions = {
    <span style="color: #9cdcfe;">academic</span>: <span style="color: #ce9178;">'Write in an academic style with proper citations and formal language.'</span>,
    <span style="color: #9cdcfe;">creative</span>: <span style="color: #ce9178;">'Write in a creative, engaging style with vivid examples and analogies.'</span>,
    <span style="color: #9cdcfe;">concise</span>: <span style="color: #ce9178;">'Write concisely, focusing on key points and avoiding unnecessary detail.'</span>
  };

  <span style="color: #569cd6;">const</span> strategyInstructions = {
    <span style="color: #9cdcfe;">replace</span>: <span style="color: #ce9178;">'Generate a complete, comprehensive note that synthesizes all the connected information.'</span>,
    <span style="color: #9cdcfe;">append</span>: <span style="color: #ce9178;">'Generate additional content that expands on the existing note using the connected information.'</span>,
    <span style="color: #9cdcfe;">merge</span>: <span style="color: #ce9178;">'Intelligently integrate information from connected notes while preserving key insights from the existing content.'</span>
  };

  <span style="color: #c586c0;">return</span> <span style="color: #ce9178;">`You are helping develop a note by synthesizing information from connected notes.

</span><span style="color: #569cd6;">${</span>strategyInstructions[options.strategy]<span style="color: #569cd6;">}</span><span style="color: #ce9178;">
</span><span style="color: #569cd6;">${</span>options.tone ? toneInstructions[options.tone] : <span style="color: #ce9178;">''</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">

Focus on creating coherent, well-structured content that integrates ideas from multiple sources.
Use HTML formatting with proper semantic tags (&lt;p&gt;, &lt;h3&gt;, &lt;ul&gt;, &lt;strong&gt;, etc.).`</span>;
}

<span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">buildUserPrompt</span>(
  <span style="color: #9cdcfe;">targetCard</span>: <span style="color: #4ec9b0;">Card</span>,
  <span style="color: #9cdcfe;">context</span>: <span style="color: #4ec9b0;">string</span>,
  <span style="color: #9cdcfe;">options</span>: <span style="color: #4ec9b0;">FillInOptions</span>
): <span style="color: #4ec9b0;">string</span> {
  <span style="color: #569cd6;">const</span> parts = [
    <span style="color: #ce9178;">`# Target Note`</span>,
    <span style="color: #ce9178;">`Title: </span><span style="color: #569cd6;">${</span>targetCard.metadata?.title || <span style="color: #ce9178;">'Untitled'</span><span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>,
  ];

  <span style="color: #c586c0;">if</span> (targetCard.content && options.strategy !== <span style="color: #ce9178;">'replace'</span>) {
    parts.<span style="color: #dcdcaa;">push</span>(<span style="color: #ce9178;">`Current Content:\n</span><span style="color: #569cd6;">${</span>targetCard.content<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>);
  }

  parts.<span style="color: #dcdcaa;">push</span>(<span style="color: #ce9178;">`\n# Connected Notes\n</span><span style="color: #569cd6;">${</span>context<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>);

  <span style="color: #c586c0;">if</span> (options.userPrompt) {
    parts.<span style="color: #dcdcaa;">push</span>(<span style="color: #ce9178;">`\n# User Instructions\n</span><span style="color: #569cd6;">${</span>options.userPrompt<span style="color: #569cd6;">}</span><span style="color: #ce9178;">`</span>);
  }

  <span style="color: #c586c0;">return</span> parts.<span style="color: #dcdcaa;">join</span>(<span style="color: #ce9178;">'\n\n'</span>);
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 4: Fill-In Modal UI</h3>
        <p>Create <code>src/components/FillInModal.tsx</code>:</p>
        <div class="code-block">
<span style="color: #6a9955;">/** @jsxImportSource @emotion/react */</span>
<span style="color: #c586c0;">import</span> { useState, useEffect } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'react'</span>;
<span style="color: #c586c0;">import</span> { Card } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/types/card'</span>;
<span style="color: #c586c0;">import</span> { fillInFromConnections, FillInStrategy } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/services/fillInService'</span>;
<span style="color: #c586c0;">import</span> { getConnectedCards } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'@/services/connectionContextService'</span>;

<span style="color: #569cd6;">interface</span> <span style="color: #4ec9b0;">FillInModalProps</span> {
  <span style="color: #9cdcfe;">card</span>: <span style="color: #4ec9b0;">Card</span>;
  <span style="color: #9cdcfe;">allCards</span>: <span style="color: #4ec9b0;">Card</span>[];
  <span style="color: #9cdcfe;">onClose</span>: () <span style="color: #569cd6;">=&gt;</span> <span style="color: #4ec9b0;">void</span>;
  <span style="color: #9cdcfe;">onSave</span>: (<span style="color: #9cdcfe;">updatedCard</span>: <span style="color: #4ec9b0;">Card</span>) <span style="color: #569cd6;">=&gt;</span> <span style="color: #4ec9b0;">void</span>;
}

<span style="color: #569cd6;">export</span> <span style="color: #569cd6;">function</span> <span style="color: #dcdcaa;">FillInModal</span>({ <span style="color: #9cdcfe;">card, allCards, onClose, onSave</span> }: <span style="color: #4ec9b0;">FillInModalProps</span>) {
  <span style="color: #569cd6;">const</span> [connectedCards, setConnectedCards] = <span style="color: #dcdcaa;">useState</span>&lt;<span style="color: #4ec9b0;">Card</span>[]&gt;([]);
  <span style="color: #569cd6;">const</span> [strategy, setStrategy] = <span style="color: #dcdcaa;">useState</span>&lt;<span style="color: #4ec9b0;">FillInStrategy</span>&gt;(<span style="color: #ce9178;">'replace'</span>);
  <span style="color: #569cd6;">const</span> [userPrompt, setUserPrompt] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #ce9178;">''</span>);
  <span style="color: #569cd6;">const</span> [generatedContent, setGeneratedContent] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #ce9178;">''</span>);
  <span style="color: #569cd6;">const</span> [isGenerating, setIsGenerating] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #569cd6;">false</span>);

  <span style="color: #6a9955;">// Load connected cards on mount</span>
  <span style="color: #dcdcaa;">useEffect</span>(() <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #dcdcaa;">getConnectedCards</span>(card.id, allCards).<span style="color: #dcdcaa;">then</span>(setConnectedCards);
  }, [card.id, allCards]);

  <span style="color: #569cd6;">const</span> handleGenerate = <span style="color: #569cd6;">async</span> () <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #dcdcaa;">setIsGenerating</span>(<span style="color: #569cd6;">true</span>);
    <span style="color: #dcdcaa;">setGeneratedContent</span>(<span style="color: #ce9178;">''</span>);

    <span style="color: #c586c0;">try</span> {
      <span style="color: #569cd6;">const</span> generator = <span style="color: #dcdcaa;">fillInFromConnections</span>(card, allCards, {
        strategy,
        userPrompt: userPrompt || <span style="color: #569cd6;">undefined</span>
      });

      <span style="color: #c586c0;">for</span> <span style="color: #c586c0;">await</span> (<span style="color: #569cd6;">const</span> chunk <span style="color: #569cd6;">of</span> generator) {
        <span style="color: #dcdcaa;">setGeneratedContent</span>(<span style="color: #9cdcfe;">prev</span> <span style="color: #569cd6;">=&gt;</span> prev + chunk);
      }
    } <span style="color: #c586c0;">catch</span> (<span style="color: #9cdcfe;">error</span>) {
      console.<span style="color: #dcdcaa;">error</span>(<span style="color: #ce9178;">'[FillInModal] Generation failed:'</span>, error);
      <span style="color: #dcdcaa;">alert</span>(error.<span style="color: #dcdcaa;">message</span>);
    } <span style="color: #c586c0;">finally</span> {
      <span style="color: #dcdcaa;">setIsGenerating</span>(<span style="color: #569cd6;">false</span>);
    }
  };

  <span style="color: #569cd6;">const</span> handleSave = () <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #569cd6;">const</span> updatedCard = { ...card };

    <span style="color: #c586c0;">if</span> (strategy === <span style="color: #ce9178;">'replace'</span>) {
      updatedCard.content = generatedContent;
    } <span style="color: #c586c0;">else</span> <span style="color: #c586c0;">if</span> (strategy === <span style="color: #ce9178;">'append'</span>) {
      updatedCard.content = (card.content || <span style="color: #ce9178;">''</span>) + <span style="color: #ce9178;">'\n\n'</span> + generatedContent;
    } <span style="color: #c586c0;">else</span> {
      <span style="color: #6a9955;">// merge - for now, just replace (could be smarter)</span>
      updatedCard.content = generatedContent;
    }

    <span style="color: #6a9955;">// Add to fill-in history</span>
    updatedCard.fillInHistory = [
      ...(card.fillInHistory || []),
      {
        timestamp: <span style="color: #4ec9b0;">Date</span>.<span style="color: #dcdcaa;">now</span>(),
        sourceCardIds: connectedCards.<span style="color: #dcdcaa;">map</span>(<span style="color: #9cdcfe;">c</span> <span style="color: #569cd6;">=&gt;</span> c.id),
        strategy,
        userPrompt: userPrompt || <span style="color: #569cd6;">undefined</span>,
        previousContent: card.content
      }
    ];

    <span style="color: #dcdcaa;">onSave</span>(updatedCard);
    <span style="color: #dcdcaa;">onClose</span>();
  };

  <span style="color: #c586c0;">return</span> (
    <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span> <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"fill-in-modal"</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">h2</span><span style="color: #808080;">&gt;</span>🔗 Fill In from Connections<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">h2</span><span style="color: #808080;">&gt;</span>

      <span style="color: #6a9955;">{/* Connected cards preview */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">h3</span><span style="color: #808080;">&gt;</span>Connected Cards ({connectedCards.length})<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">h3</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">ul</span><span style="color: #808080;">&gt;</span>
          {connectedCards.<span style="color: #dcdcaa;">map</span>(<span style="color: #9cdcfe;">c</span> <span style="color: #569cd6;">=&gt;</span> (
            <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">li</span> <span style="color: #9cdcfe;">key</span>={c.id}<span style="color: #808080;">&gt;</span>{c.metadata?.title || <span style="color: #ce9178;">'Untitled'</span>}<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">li</span><span style="color: #808080;">&gt;</span>
          ))}
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">ul</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>

      <span style="color: #6a9955;">{/* Strategy selector */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">label</span><span style="color: #808080;">&gt;</span>Strategy:<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">label</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">select</span> <span style="color: #9cdcfe;">value</span>={strategy} <span style="color: #9cdcfe;">onChange</span>={<span style="color: #9cdcfe;">e</span> <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setStrategy</span>(e.target.value <span style="color: #569cd6;">as</span> <span style="color: #4ec9b0;">FillInStrategy</span>)}<span style="color: #808080;">&gt;</span>
          <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">option</span> <span style="color: #9cdcfe;">value</span>=<span style="color: #ce9178;">"replace"</span><span style="color: #808080;">&gt;</span>Replace - Start fresh<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">option</span><span style="color: #808080;">&gt;</span>
          <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">option</span> <span style="color: #9cdcfe;">value</span>=<span style="color: #ce9178;">"append"</span><span style="color: #808080;">&gt;</span>Append - Add to existing<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">option</span><span style="color: #808080;">&gt;</span>
          <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">option</span> <span style="color: #9cdcfe;">value</span>=<span style="color: #ce9178;">"merge"</span><span style="color: #808080;">&gt;</span>Merge - Integrate with existing<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">option</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">select</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>

      <span style="color: #6a9955;">{/* Optional user guidance */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">textarea</span>
        <span style="color: #9cdcfe;">placeholder</span>=<span style="color: #ce9178;">"Optional: Provide specific guidance (e.g., 'Focus on practical applications')"</span>
        <span style="color: #9cdcfe;">value</span>={userPrompt}
        <span style="color: #9cdcfe;">onChange</span>={<span style="color: #9cdcfe;">e</span> <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setUserPrompt</span>(e.target.value)}
      <span style="color: #808080;">/&gt;</span>

      <span style="color: #6a9955;">{/* Generated content preview */}</span>
      {generatedContent && (
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span>
          <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"preview"</span>
          <span style="color: #9cdcfe;">dangerouslySetInnerHTML</span>={{ __html: generatedContent }}
        <span style="color: #808080;">/&gt;</span>
      )}

      <span style="color: #6a9955;">{/* Actions */}</span>
      <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span> <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"actions"</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span> <span style="color: #9cdcfe;">onClick</span>={handleGenerate} <span style="color: #9cdcfe;">disabled</span>={isGenerating}<span style="color: #808080;">&gt;</span>
          {isGenerating ? <span style="color: #ce9178;">'Generating...'</span> : <span style="color: #ce9178;">'Generate'</span>}
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span> <span style="color: #9cdcfe;">onClick</span>={handleSave} <span style="color: #9cdcfe;">disabled</span>={!generatedContent}<span style="color: #808080;">&gt;</span>
          Save
        <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
        <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span> <span style="color: #9cdcfe;">onClick</span>={onClose}<span style="color: #808080;">&gt;</span>Cancel<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
      <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
    <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span>
  );
}
        </div>
    </div>

    <div class="implementation-step">
        <h3>Step 5: Integrate into CardNode</h3>
        <p>Add "Fill In" button to cards with connections:</p>
        <div class="code-block">
<span style="color: #6a9955;">// In CardNode.tsx</span>
<span style="color: #569cd6;">const</span> [showFillInModal, setShowFillInModal] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #569cd6;">false</span>);
<span style="color: #569cd6;">const</span> [connectionCount, setConnectionCount] = <span style="color: #dcdcaa;">useState</span>(<span style="color: #b5cea8;">0</span>);

<span style="color: #6a9955;">// Count connections for this card</span>
<span style="color: #dcdcaa;">useEffect</span>(() <span style="color: #569cd6;">=&gt;</span> {
  <span style="color: #dcdcaa;">getConnections</span>().<span style="color: #dcdcaa;">then</span>(<span style="color: #9cdcfe;">connections</span> <span style="color: #569cd6;">=&gt;</span> {
    <span style="color: #569cd6;">const</span> count = connections.<span style="color: #dcdcaa;">filter</span>(
      <span style="color: #9cdcfe;">c</span> <span style="color: #569cd6;">=&gt;</span> c.source === card.id || c.target === card.id
    ).length;
    <span style="color: #dcdcaa;">setConnectionCount</span>(count);
  });
}, [card.id]);

<span style="color: #6a9955;">// In card header, after other buttons:</span>
{connectionCount &gt; <span style="color: #b5cea8;">0</span> && (
  <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">button</span>
    <span style="color: #9cdcfe;">className</span>=<span style="color: #ce9178;">"fill-in-button"</span>
    <span style="color: #9cdcfe;">onClick</span>={() <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setShowFillInModal</span>(<span style="color: #569cd6;">true</span>)}
    <span style="color: #9cdcfe;">title</span>=<span style="color: #ce9178;">"Fill in from connected cards"</span>
  <span style="color: #808080;">&gt;</span>
    🔗 Fill In ({connectionCount})
  <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">button</span><span style="color: #808080;">&gt;</span>
)}

{showFillInModal && (
  <span style="color: #808080;">&lt;</span><span style="color: #4ec9b0;">FillInModal</span>
    <span style="color: #9cdcfe;">card</span>={card}
    <span style="color: #9cdcfe;">allCards</span>={allCards}  <span style="color: #6a9955;">// Pass from Canvas via props</span>
    <span style="color: #9cdcfe;">onClose</span>={() <span style="color: #569cd6;">=&gt;</span> <span style="color: #dcdcaa;">setShowFillInModal</span>(<span style="color: #569cd6;">false</span>)}
    <span style="color: #9cdcfe;">onSave</span>={handleUpdateCard}
  <span style="color: #808080;">/&gt;</span>
)}
        </div>
    </div>

    <h2>🎨 UX Enhancements</h2>

    <div class="feature-box">
        <h3>Visual Feedback</h3>
        <ul>
            <li><strong>Connection Indicators:</strong> Show badge with connection count on all cards</li>
            <li><strong>Source Attribution:</strong> In generated content, highlight which parts came from which connected cards (color-coded)</li>
            <li><strong>Diff View:</strong> Before saving, show side-by-side comparison of old vs. new content</li>
            <li><strong>Animation:</strong> Pulse/glow effect on connected cards during generation</li>
        </ul>
    </div>

    <div class="feature-box">
        <h3>Iterative Refinement</h3>
        <ul>
            <li><strong>Multiple Rounds:</strong> User can connect more cards and fill in again to further develop</li>
            <li><strong>History Timeline:</strong> Show fill-in history with ability to revert to previous versions</li>
            <li><strong>Selective Include:</strong> Choose which connected cards to include in each fill-in operation</li>
            <li><strong>Manual Edits:</strong> User can edit generated content before saving</li>
        </ul>
    </div>

    <div class="feature-box">
        <h3>Smart Connections</h3>
        <ul>
            <li><strong>Auto-Suggest:</strong> When user creates a new note, suggest relevant cards to connect based on content similarity</li>
            <li><strong>Connection Types:</strong> Label connections (supports, contradicts, extends, examples-of)</li>
            <li><strong>Weighted Influence:</strong> Give more weight to certain connections in synthesis</li>
        </ul>
    </div>

    <h2>🔄 Advanced Workflows</h2>

    <div class="workflow">
        <h3>Research Synthesis Workflow</h3>
        <ol>
            <li>Create new note: "Deep learning for healthcare"</li>
            <li>Connect to 5 clipped research papers</li>
            <li>Fill in with strategy: "Replace" → Get comprehensive overview</li>
            <li>Connect 2 more papers with specific techniques</li>
            <li>Fill in again with strategy: "Append" → Add technical details</li>
            <li>Manually edit to add personal insights</li>
            <li>Export as final literature review</li>
        </ol>
    </div>

    <div class="workflow">
        <h3>Concept Development Workflow</h3>
        <ol>
            <li>Create sparse note: "Product idea: AI tutor"</li>
            <li>Connect to market research card</li>
            <li>Fill in → Get market context</li>
            <li>Connect to technical feasibility card</li>
            <li>Fill in (append) → Add technical details</li>
            <li>Connect to competitor analysis card</li>
            <li>Fill in (merge) → Integrate competitive positioning</li>
            <li>Result: Fully developed product proposal</li>
        </ol>
    </div>

    <div class="workflow">
        <h3>Progressive Elaboration</h3>
        <ol>
            <li>Start with minimal note: "Transformer architecture"</li>
            <li>Round 1: Connect to "Attention mechanism" → Fill in basics</li>
            <li>Round 2: Connect to "Positional encoding" → Fill in (append)</li>
            <li>Round 3: Connect to "Multi-head attention" → Fill in (append)</li>
            <li>Round 4: Connect to "Applications" → Fill in (append)</li>
            <li>Result: Comprehensive guide built incrementally</li>
        </ol>
    </div>

    <h2>💡 Implementation Timeline</h2>

    <div class="note">
        <h3>Phase 1: Core Fill-In (6-8 hours)</h3>
        <ul>
            <li>✅ Extend Card type with fillInHistory (30 min)</li>
            <li>✅ Create connectionContextService (1 hour)</li>
            <li>✅ Create fillInService with AI integration (2 hours)</li>
            <li>✅ Build FillInModal UI (2 hours)</li>
            <li>✅ Integrate into CardNode (1 hour)</li>
            <li>✅ Testing and debugging (1.5 hours)</li>
        </ul>
    </div>

    <div class="note">
        <h3>Phase 2: UX Polish (3-4 hours)</h3>
        <ul>
            <li>🔲 Add visual feedback and animations</li>
            <li>🔲 Implement diff view for preview</li>
            <li>🔲 Add undo/history timeline</li>
            <li>🔲 Connection count badges</li>
        </ul>
    </div>

    <div class="note">
        <h3>Phase 3: Advanced Features (4-6 hours)</h3>
        <ul>
            <li>🔲 Auto-suggest relevant connections</li>
            <li>🔲 Connection type labels</li>
            <li>🔲 Selective card inclusion</li>
            <li>🔲 Source attribution in generated content</li>
        </ul>
    </div>

    <h2>🎯 Why This Feature is Powerful</h2>

    <div class="feature-box">
        <p class="advantage">✅ <strong>Active Knowledge Integration:</strong> Transforms passive note storage into active synthesis</p>
        <p class="advantage">✅ <strong>Iterative Thinking:</strong> Supports progressive elaboration of ideas</p>
        <p class="advantage">✅ <strong>Connection-Driven:</strong> Leverages existing connection infrastructure</p>
        <p class="advantage">✅ <strong>Low Barrier:</strong> User just creates sparse note + connections, AI does the heavy lifting</p>
        <p class="advantage">✅ <strong>Preserves Agency:</strong> User controls which cards contribute and can edit results</p>
        <p class="advantage">✅ <strong>Complements Other Features:</strong> Works alongside expandable cards, multi-card queries</p>
    </div>

    <div class="note">
        <h3>🔗 Connection to Literature</h3>
        <p>This feature embodies <strong>Ted Nelson's concept of "transclusion"</strong> - where content from multiple sources is dynamically combined to create new documents. It also aligns with <strong>Vannevar Bush's vision of "trails of association"</strong> where links between documents create meaningful pathways for knowledge exploration.</p>
    </div>

    <h2>🚀 Next Steps</h2>
    <ol>
        <li>Implement Phase 1 (core fill-in functionality)</li>
        <li>Test with real research scenarios</li>
        <li>Gather user feedback on strategy options</li>
        <li>Iterate on UX based on usage patterns</li>
        <li>Consider adding to <code>next-steps.html</code> as a major feature</li>
    </ol>

</body>
</html>