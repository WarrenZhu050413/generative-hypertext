<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Plan: Hypertext UX Improvements</title>
<style>
:root {
    --chinese-red: #8B0000;
    --chinese-gold: #FFD700;
    --jade-green: #00A86B;
    --ink-black: #2B2B2B;
    --paper-beige: #F5F5DC;
    --light-cream: #FAFAF0;
    --level-1: #000;
    --level-2: #333;
    --level-3: #666;
    --level-4: #999;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
    color: var(--ink-black);
    width: 100vw;
    max-width: 100%;
    line-height: 1.2;
    font-size: 14px;
    font-family: "SF Pro Text", "Segoe UI", Roboto, Arial, sans-serif;
}

.container { width: 100%; padding: 0; margin: 0; }

h1 {
    font-size: 24px; font-weight: 900; margin: 4px 0; padding: 6px 4px;
    background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    letter-spacing: -0.5px;
}

h2 {
    font-size: 18px; font-weight: 700; margin: 8px 0 4px 0; padding: 4px;
    border-left: 4px solid var(--chinese-red);
    background: rgba(139, 0, 0, 0.03); color: var(--level-1);
}

h3 {
    font-size: 14px; font-weight: 600; margin: 4px 0 2px 8px;
    color: var(--level-2); text-transform: uppercase; letter-spacing: 0.5px;
}

h4 { font-size: 12px; font-weight: 500; margin: 2px 0 1px 16px; color: var(--level-3); }

.important-always-visible {
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
    border: 2px solid var(--chinese-gold);
    padding: 8px; margin: 8px 0; border-radius: 3px;
}

.critical-issue {
    background: linear-gradient(135deg, rgba(139, 0, 0, 0.15), rgba(255, 215, 0, 0.1));
    border: 3px solid var(--chinese-red);
    padding: 12px; margin: 8px 0; border-radius: 4px;
}

.card {
    background: white;
    border: 1px solid rgba(139, 0, 0, 0.2);
    border-radius: 2px; padding: 6px; margin: 4px 0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.card.priority {
    border: 2px solid var(--chinese-gold);
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
}

pre, code {
    background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
    border: 1px solid rgba(139, 0, 0, 0.15);
    padding: 4px 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;
    line-height: 1.3; overflow-x: auto; border-radius: 2px;
}

pre { padding: 8px; margin: 4px 0; }

.dense-list { list-style: none; padding: 0; margin-left: 8px; }
.dense-list li {
    padding: 2px 0 2px 12px; border-left: 2px solid transparent; position: relative;
}
.dense-list li:before {
    content: "‚ñ∏"; position: absolute; left: 0;
    color: var(--chinese-red); font-size: 10px;
}

.two-column {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
    margin: 4px 0;
}

.divider {
    height: 1px;
    background: linear-gradient(90deg, var(--chinese-red), transparent);
    margin: 8px 0;
}

.collapsible { margin: 4px 0; width: 100%; }

.collapsible-header {
    cursor: pointer; padding: 6px 8px;
    background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
    border-left: 3px solid var(--chinese-gold);
    display: flex; align-items: center; justify-content: space-between;
    user-select: none; transition: all 0.2s ease;
}

.collapsible-header:hover {
    background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
}

.collapsible-header .arrow {
    display: inline-block; transition: transform 0.3s ease;
    color: var(--chinese-red); font-size: 10px;
}

.collapsible.open .arrow { transform: rotate(90deg); }

.collapsible-content {
    max-height: 0; overflow: hidden; transition: max-height 0.3s ease;
    padding: 0 8px; margin-left: 12px;
}

.collapsible.open .collapsible-content {
    max-height: 5000px; padding: 8px;
}

.status-good { color: var(--jade-green); font-weight: 600; }
.status-bad { color: var(--chinese-red); font-weight: 600; }
.status-warn { color: #ff8c00; font-weight: 600; }

button {
    background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
    color: white; border: 1px solid rgba(255, 215, 0, 0.3);
    transition: all 0.2s ease; padding: 2px 6px;
    margin: 1px; font-size: 12px; line-height: 1.1;
    cursor: pointer; border-radius: 3px;
}

button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3);
    border-color: var(--chinese-gold);
}
</style>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
</head>
<body>
<div class="container">

<div style="margin: 8px 0; text-align: right;">
    <button id="expand-all">Expand All</button>
    <button id="collapse-all">Collapse All</button>
</div>

<div class="important-always-visible">
    <h1>üìã Hypertext UX Improvements</h1>
    <div class="two-column">
        <div>
            <h3>Objective</h3>
            <p>Fix newline rendering, markdown display, and improve chat URL sharing in the hypertext system</p>
        </div>
        <div>
            <h3>Approach</h3>
            <p>Centralize escape sequence decoding, fix URL persistence, clarify streaming limitations</p>
            <div style="margin-top: 4px; color: #ff8c00; font-weight: 600;">Complexity: Medium</div>
        </div>
    </div>
</div>

<div class="critical-issue">
    <h2>üîç Codex Review Summary</h2>
    <div class="two-column">
        <div>
            <h4>Key Feedback</h4>
            <ul class="dense-list">
                <li><strong>High Priority:</strong> URL sharing is broken - session IDs not actually persisted for shareability</li>
                <li><strong>Medium:</strong> Streaming "thinking process" needs backend changes - no such markers exist in current SSE stream</li>
                <li><strong>Medium:</strong> Escape decoding must be centralized in renderMarkdown() to avoid inconsistencies</li>
            </ul>
        </div>
        <div>
            <h4>Changes Made</h4>
            <ul class="dense-list">
                <li>Added proper session ID persistence strategy using chrome.storage.local</li>
                <li>Marked streaming thoughts as "future enhancement" requiring backend work</li>
                <li>Consolidated escape decoding into renderMarkdown() function</li>
                <li>Added comprehensive testing for edge cases (double-decode, Unicode, etc.)</li>
            </ul>
        </div>
    </div>
</div>

<div class="divider"></div>

<h2>Implementation Steps</h2>

<div class="card priority">
    <h3>Step 1: Fix Escape Sequence Decoding (hypertext-experience.js)</h3>
    <p><strong>Location:</strong> After line 853 (before renderMarkdown function)</p>
    <p><strong>Action:</strong> Add centralized escape decoder and integrate into renderMarkdown</p>

    <pre>// Add helper function before renderMarkdown (line ~854)
function decodeEscapeSequences(text) {
  if (!text || typeof text !== 'string') return text;

  return text
    // Decode newlines
    .replace(/\\n/g, '\n')
    // Decode tabs
    .replace(/\\t/g, '\t')
    // Decode carriage returns
    .replace(/\\r/g, '\r')
    // Decode quotes (but be careful with JSON)
    .replace(/\\"/g, '"')
    .replace(/\\'/g, "'")
    // Decode backslashes (must be last)
    .replace(/\\\\/g, '\\');
}

function renderMarkdown(text) {
  if (!text) return '';

  <span class="status-good">// NEW: Decode escape sequences FIRST</span>
  const decodedText = decodeEscapeSequences(text);

  // If libraries aren't loaded yet, convert newlines manually
  if (!markdownLibsLoaded || !markedLib || !DOMPurifyLib) {
    <span class="status-good">// Fallback: Convert newlines to &lt;br&gt;</span>
    return decodedText.replace(/\n/g, '&lt;br&gt;');
  }

  try {
    // Parse markdown to HTML
    const rawHtml = markedLib.parse(decodedText, { breaks: true, gfm: true });

    // Sanitize HTML to prevent XSS
    const cleanHtml = DOMPurifyLib.sanitize(rawHtml, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'code', 'pre', 'a', 'ul', 'ol', 'li', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
      ALLOWED_ATTR: ['href', 'target', 'rel'],
      ALLOW_DATA_ATTR: false
    });

    return cleanHtml;
  } catch (error) {
    console.warn('[Hypertext] Markdown rendering failed:', error);
    return decodedText.replace(/\n/g, '&lt;br&gt;');
  }
}</pre>
</div>

<div class="card priority">
    <h3>Step 2: Fix URL Persistence for Sharing (CRITICAL)</h3>
    <p><strong>Problem:</strong> Current implementation doesn't persist session payloads for shareable URLs</p>
    <p><strong>Solution:</strong> Store payloads in chrome.storage.local with persistent keys</p>

    <h4>Modify extension/background.js</h4>
    <pre>async function handleOpenChatPage(message, sender, sendResponse) {
  const { payload, shiftKey } = message;

  try {
    // Generate PERSISTENT session key (not timestamp-based)
    const sessionKey = `hypertext:chat-${payload.subject || 'untitled'}-${Date.now()}`;

    <span class="status-good">// Store in chrome.storage.local (persists across sessions)</span>
    await chrome.storage.local.set({ [sessionKey]: payload });

    // Build extension URL with session parameter
    const chatUrl = chrome.runtime.getURL('demo/simple_chat_page.html');
    const fullUrl = `${chatUrl}?session=${encodeURIComponent(sessionKey)}`;

    if (shiftKey && sender.tab) {
      await chrome.tabs.update(sender.tab.id, { url: fullUrl });
    } else {
      await chrome.tabs.create({ url: fullUrl, active: true });
    }

    sendResponse({ success: true, sessionKey, shareableUrl: fullUrl });

  } catch (error) {
    console.error('[Hypertext Background] Failed to open chat page:', error);
    sendResponse({
      success: false,
      error: error.message || 'Unknown error'
    });
  }
}</pre>

    <h4>Update demo/simple_chat_page.html</h4>
    <pre>async function loadPayload() {
  const params = new URLSearchParams(window.location.search);
  const sessionKey = params.get('session');

  if (sessionKey && typeof chrome !== 'undefined' && chrome.storage?.local) {
    try {
      const result = await chrome.storage.local.get(sessionKey);

      if (result[sessionKey]) {
        const payload = result[sessionKey];

        <span class="status-good">// DO NOT DELETE - keep for sharing/bookmarking</span>
        // chrome.storage.local.remove(sessionKey);

        return payload;
      }
    } catch (error) {
      console.warn('Failed to load from chrome.storage.local:', error);
    }
  }

  // Fallback paths...
  return fallbackPayload();
}</pre>
</div>

<div class="collapsible">
    <div class="collapsible-header">
        <span><strong>Step 3: Streaming Thoughts Display (Future Enhancement)</strong></span>
        <span class="arrow">‚ñ∂</span>
    </div>
    <div class="collapsible-content">
        <div class="card">
            <h4>‚ö†Ô∏è Requires Backend Changes</h4>
            <p><strong>Current State:</strong> SSE stream only contains JSON assembly chunks (no thinking markers)</p>
            <p><strong>What's Needed:</strong></p>
            <ul class="dense-list">
                <li>Backend must send separate SSE field for "thinking" tokens</li>
                <li>Example: <code>data: {"type":"thought","text":"**Analyzing markdown requirements**"}</code></li>
                <li>Frontend accumulator detects type and displays in streaming UI</li>
            </ul>
        </div>

        <div class="card">
            <h4>Frontend Changes (IF backend supports it)</h4>
            <pre>// Modify streamHypertext function (line ~1096)
async function streamHypertext(messages) {
  // ... existing setup ...

  let resultText = '';
  <span class="status-good">let thinkingSteps = [];  // NEW: Track thinking process</span>

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (!line.startsWith('data:')) continue;
      const data = line.slice(5).trim();
      if (!data || data === '[DONE]') continue;

      try {
        const parsed = JSON.parse(data);

        <span class="status-good">// NEW: Handle thinking tokens</span>
        if (parsed.type === 'thought' && parsed.text) {
          thinkingSteps.push(parsed.text);
          // Update UI to show thinking step
          updateStreamingThoughts(thinkingSteps);
        } else if (parsed.delta?.text) {
          resultText += parsed.delta.text;
        }
      } catch (error) {
        console.warn('[Hypertext] Failed to parse SSE chunk:', data);
      }
    }
  }

  return parseHypertextJson(resultText);
}</pre>
        </div>

        <div class="card">
            <h4>UI Update for Streaming Thoughts</h4>
            <pre>// Add to renderConversation function (line ~1521)
if (session.isStreaming) {
  const streamingItem = doc.createElement('li');
  streamingItem.className = 'hx-chat-tooltip__item';

  const content = doc.createElement('div');
  content.className = 'hx-chat-tooltip__content';

  <span class="status-good">// NEW: Show thinking steps if available</span>
  if (session.thinkingSteps && session.thinkingSteps.length > 0) {
    const thoughtsDiv = doc.createElement('div');
    thoughtsDiv.className = 'hx-streaming-thoughts';
    thoughtsDiv.innerHTML = session.thinkingSteps
      .map(step => `<div class="hx-thought-step">${step}</div>`)
      .join('');
    content.appendChild(thoughtsDiv);
  }

  content.innerHTML += '&lt;span class="hx-streaming-text"&gt;Generating‚Ä¶&lt;/span&gt;';
  streamingItem.appendChild(content);
  fragment.appendChild(streamingItem);
}</pre>
        </div>

        <div class="card">
            <h4>CSS for Thinking Steps</h4>
            <pre>/* Add to BASE_STYLES (line ~2) */
.hx-streaming-thoughts {
  background: rgba(177, 60, 60, 0.05);
  border-left: 2px solid rgba(177, 60, 60, 0.3);
  padding: 4px 8px;
  margin-bottom: 8px;
  font-size: 0.9em;
}

.hx-thought-step {
  color: #b83c1f;
  font-style: italic;
  margin: 2px 0;
}</pre>
        </div>
    </div>
</div>

<div class="collapsible">
    <div class="collapsible-header">
        <span><strong>Step 4: System Prompt Documentation</strong></span>
        <span class="arrow">‚ñ∂</span>
    </div>
    <div class="collapsible-content">
        <div class="card">
            <h4>Confirm: JSON Format is Prompt-Engineered</h4>
            <p><strong>Location:</strong> hypertext-experience.js:756-776 (buildSystemPrompt function)</p>
            <p>The JSON response format is intentionally designed via the system prompt:</p>
            <pre>function buildSystemPrompt() {
  return [
    'You are Nabokov\'s Hypertext Generator.',
    'Respond with a single JSON object that matches this schema:',
    '{',
    '  "pillText": string,',
    '  "mode": "inline" | "reference",',
    '  "explanation"?: string,',
    '  "url"?: string',
    '}',
    'Rules:',
    '1. Return JSON only. No extra commentary or Markdown fences.',
    '2. If mode is "inline", include "explanation" (plain text; use \\n for newlines).',
    '3. If mode is "reference", include "url" and add an "explanation" when helpful.',
    '4. Only emit "url" values you are confident exist.',
    '5. You may include both "explanation" and "url" together.',
    '6. Keep pillText under 45 characters.',
    '7. Use double quotes for all JSON keys and strings.',
    '8. If the user provides custom instructions, follow them exactly.'
  ].join('\n');
}</pre>
            <p><strong>Note:</strong> The <code>\n</code> escape sequences in explanation are intentional and handled by decodeEscapeSequences()</p>
        </div>
    </div>
</div>

<div class="divider"></div>

<h2>Testing Strategy</h2>

<div class="two-column">
    <div class="card">
        <h4>Unit Tests: Escape Decoding</h4>
        <ul class="dense-list">
            <li>Test <code>\n</code> ‚Üí newline</li>
            <li>Test <code>\t</code> ‚Üí tab</li>
            <li>Test <code>\\n</code> ‚Üí literal backslash-n (no double-decode)</li>
            <li>Test Unicode sequences</li>
            <li>Test null/undefined/empty input</li>
            <li>Test with real JSON from system prompt</li>
        </ul>
    </div>

    <div class="card">
        <h4>Integration: Markdown Rendering</h4>
        <ul class="dense-list">
            <li>Test multiline markdown with <code>\n</code> sequences</li>
            <li>Test code blocks with newlines</li>
            <li>Test bullet lists</li>
            <li>Test before marked/DOMPurify load (fallback)</li>
            <li>Test XSS prevention still works</li>
        </ul>
    </div>

    <div class="card">
        <h4>E2E: URL Persistence</h4>
        <ul class="dense-list">
            <li>Create hypertext link ‚Üí click ‚Üí verify chat opens</li>
            <li>Copy chat URL ‚Üí paste in new tab ‚Üí verify payload loads</li>
            <li>Bookmark chat URL ‚Üí close browser ‚Üí reopen ‚Üí verify works</li>
            <li>Test with different subjects/payloads</li>
            <li>Test storage quota limits</li>
        </ul>
    </div>

    <div class="card">
        <h4>Manual: Streaming UI (Future)</h4>
        <ul class="dense-list">
            <li>Mock backend with thought tokens</li>
            <li>Verify each thought appears on new line</li>
            <li>Verify final result renders correctly</li>
            <li>Test with/without thoughts in same stream</li>
        </ul>
    </div>
</div>

<div class="divider"></div>

<h2>Risk Assessment</h2>

<div class="card priority">
    <h3>Critical Risks & Mitigations</h3>
    <div class="two-column">
        <div>
            <h4>Risk: Double-Decoding</h4>
            <p>If escape sequences are decoded multiple times, <code>\\n</code> could become a newline</p>
            <p><strong>Mitigation:</strong> Only decode in renderMarkdown(), add guard in decodeEscapeSequences()</p>
        </div>
        <div>
            <h4>Risk: XSS via Markdown</h4>
            <p>Decoded content could introduce script tags</p>
            <p><strong>Mitigation:</strong> DOMPurify sanitization happens AFTER decoding</p>
        </div>
        <div>
            <h4>Risk: Storage Quota</h4>
            <p>chrome.storage.local has ~10MB limit</p>
            <p><strong>Mitigation:</strong> Add cleanup for old sessions, warn on quota errors</p>
        </div>
        <div>
            <h4>Risk: Shared Links Expire</h4>
            <p>If user clears extension data, links break</p>
            <p><strong>Mitigation:</strong> Document limitation, consider export feature</p>
        </div>
    </div>
</div>

<div class="divider"></div>

<h2>Implementation Checklist</h2>

<div class="card">
    <h3>‚úÖ Required Changes</h3>
    <ul class="dense-list">
        <li>‚òê Add decodeEscapeSequences() helper (hypertext-experience.js:854)</li>
        <li>‚òê Integrate escape decoding into renderMarkdown()</li>
        <li>‚òê Add fallback newline-to-br when marked not loaded</li>
        <li>‚òê Change chrome.storage.session ‚Üí chrome.storage.local in background.js</li>
        <li>‚òê Remove auto-delete of session keys in chat page</li>
        <li>‚òê Add "storage" permission to manifest.json (if not present)</li>
        <li>‚òê Write unit tests for decodeEscapeSequences()</li>
        <li>‚òê Write E2E test for URL persistence</li>
        <li>‚òê Test markdown rendering with real LLM responses</li>
        <li>‚òê Update tests/hypertext-demo.spec.mjs</li>
    </ul>
</div>

<div class="card">
    <h3>üîÆ Future Enhancements (Requires Backend)</h3>
    <ul class="dense-list">
        <li>‚òê Backend: Add thought token SSE events</li>
        <li>‚òê Frontend: Add thinkingSteps accumulator</li>
        <li>‚òê Frontend: Add streaming thoughts UI</li>
        <li>‚òê CSS: Add thought step styling</li>
        <li>‚òê Test: Mock SSE with thought tokens</li>
    </ul>
</div>

<div class="divider"></div>

<h2>Example Test Cases</h2>

<div class="card">
    <h3>Test: Escape Decoding</h3>
    <pre>// Test newline conversion
const input = "Line 1\nLine 2\nLine 3";
const decoded = decodeEscapeSequences(input);
assert(decoded === "Line 1\nLine 2\nLine 3");  // Actual newlines

// Test double-decode protection
const doubleEscaped = "Line 1\\\\nLine 2";
const decoded2 = decodeEscapeSequences(doubleEscaped);
assert(decoded2 === "Line 1\\nLine 2");  // Should NOT decode twice

// Test real LLM response
const llmResponse = {
  "pillText": "Markdown sample",
  "mode": "inline",
  "explanation": "# Header\n\n- Bullet 1\n- Bullet 2"
};
const rendered = renderMarkdown(llmResponse.explanation);
assert(rendered.includes("&lt;h1&gt;Header&lt;/h1&gt;"));
assert(rendered.includes("&lt;li&gt;Bullet 1&lt;/li&gt;"));</pre>
</div>

<div class="card">
    <h3>Test: URL Persistence (Playwright)</h3>
    <pre>test('chat URLs are shareable and persistent', async ({ page, context }) => {
  // Load extension
  await page.goto('https://example.com');

  // Create hypertext
  await page.keyboard.press('Control+Shift+K');
  await page.fill('#hx-instruction-input', 'Test markdown');
  await page.click('#hx-generate-button');

  // Click generated link
  const link = page.locator('.hx-highlight');
  await link.click();

  // Get URL of new tab
  const pages = context.pages();
  const chatPage = pages[pages.length - 1];
  const chatUrl = chatPage.url();

  // Close chat tab
  await chatPage.close();

  // Open URL in NEW tab (simulating bookmark/share)
  const newTab = await context.newPage();
  await newTab.goto(chatUrl);

  // Verify payload loaded correctly
  const subject = await newTab.textContent('#chat-subject');
  expect(subject).toContain('Test markdown');
});</pre>
</div>

</div>

<script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'neutral',
    flowchart: { curve: 'basis' }
});

document.querySelectorAll('.collapsible-header').forEach(header => {
    header.addEventListener('click', () => {
        const collapsible = header.parentElement;
        collapsible.classList.toggle('open');
    });
});

document.getElementById('expand-all').addEventListener('click', () => {
    document.querySelectorAll('.collapsible').forEach(c => c.classList.add('open'));
});

document.getElementById('collapse-all').addEventListener('click', () => {
    document.querySelectorAll('.collapsible').forEach(c => c.classList.remove('open'));
});
</script>
</body>
</html>