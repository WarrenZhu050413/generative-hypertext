<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypertext Navigation Features for Nabokov</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFF8DC;
            --ink-black: #2C2C2C;
            --level-1: #8B0000;
            --level-2: #B71C1C;
            --level-3: #666;
            --level-4: #888;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.2;
            font-size: 14px;
            width: 100vw;
            max-width: 100%;
        }

        .container {
            width: 100%;
            padding: 0;
            margin: 0;
        }

        h1 {
            font-size: 24px;
            font-weight: 900;
            margin: 4px 0;
            padding: 6px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 8px 0 4px 0;
            padding: 4px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 4px 0 2px 8px;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 12px;
            font-weight: 500;
            margin: 2px 0 1px 16px;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 8px;
            margin: 8px 0;
            border-radius: 3px;
        }

        .important-always-visible h2 {
            color: var(--chinese-red);
            margin-top: 0;
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 8px 0;
        }

        .collapsible {
            margin: 4px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 6px 8px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 8px;
            margin-left: 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 10000px;
            padding: 8px;
        }

        .collapsible.critical .collapsible-header {
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.08);
            font-weight: 700;
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.1);
            padding: 2px 4px;
            margin: 1px 0;
            font-size: 12px;
            line-height: 1.1;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        pre {
            padding: 4px 6px;
            margin: 2px 0;
            overflow-x: auto;
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin-left: 8px;
        }

        .dense-list li {
            padding: 2px 0 2px 12px;
            border-left: 2px solid transparent;
            position: relative;
        }

        .dense-list li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 2px;
            padding: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 8px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 4px 0;
            font-size: 12px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 2px 4px;
            text-align: left;
            line-height: 1.1;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }

        .workflow {
            background: rgba(255, 215, 0, 0.05);
            border-left: 3px solid var(--chinese-gold);
            padding: 8px;
            margin: 4px 0;
        }

        .workflow-step {
            margin: 4px 0;
            padding-left: 16px;
            position: relative;
        }

        .workflow-step:before {
            content: "→";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-weight: bold;
        }

        .feature-matrix {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 8px 0;
        }

        .feature-card {
            background: white;
            border: 2px solid rgba(139, 0, 0, 0.2);
            border-radius: 4px;
            padding: 8px;
        }

        .feature-card.implemented {
            border-color: #228B22;
            background: linear-gradient(135deg, rgba(34, 139, 34, 0.05), white);
        }

        .feature-card.proposed {
            border-color: var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .status-badge.done {
            background: #228B22;
            color: white;
        }

        .status-badge.new {
            background: var(--chinese-gold);
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hypertext Navigation Features for Nabokov</h1>

        <div class="important-always-visible">
            <h2>Core Vision</h2>
            <p><strong>"Traverse complex networks of information quickly"</strong></p>
            <p style="margin-top: 4px;">Enable readers to freely move among text fragments, find sources, references, definitions, and related passages through bidirectional linking, quote extraction, and hierarchical navigation.</p>
        </div>

        <div class="divider"></div>

        <h2>Feature Matrix: Implemented vs. Proposed</h2>

        <div class="feature-matrix">
            <div class="feature-card implemented">
                <span class="status-badge done">✓ IMPLEMENTED</span>
                <h3>Card Connections</h3>
                <p>Visual arrows linking related cards with typed relationships (references, contradicts, generated-from, etc.)</p>
                <p style="margin-top: 4px; font-size: 11px; color: #666;">File: src/utils/connectionStorage.ts</p>
            </div>

            <div class="feature-card implemented">
                <span class="status-badge done">✓ IMPLEMENTED</span>
                <h3>Conversation Threads</h3>
                <p>Message.parentId enables threading and conversation history on each card</p>
                <p style="margin-top: 4px; font-size: 11px; color: #666;">File: src/types/card.ts:15</p>
            </div>

            <div class="feature-card implemented">
                <span class="status-badge done">✓ IMPLEMENTED</span>
                <h3>Spatial Organization</h3>
                <p>Infinite canvas for arranging cards spatially, creating visual clusters and hierarchies</p>
                <p style="margin-top: 4px; font-size: 11px; color: #666;">File: src/canvas/Canvas.tsx</p>
            </div>

            <div class="feature-card implemented">
                <span class="status-badge done">✓ NEXT-STEPS</span>
                <h3>Multi-Card Queries</h3>
                <p>Select multiple cards and synthesize information across them with LLM</p>
                <p style="margin-top: 4px; font-size: 11px; color: #666;">File: next-steps.html:1482</p>
            </div>

            <div class="feature-card proposed">
                <span class="status-badge new">NEW</span>
                <h3>Quote Extraction</h3>
                <p>Select text → create linked quote card → maintain bidirectional reference</p>
            </div>

            <div class="feature-card proposed">
                <span class="status-badge new">NEW</span>
                <h3>Backlinks Panel</h3>
                <p>Show all cards that reference the current card (reverse connections)</p>
            </div>

            <div class="feature-card proposed">
                <span class="status-badge new">NEW</span>
                <h3>Inline Citations</h3>
                <p>Click quoted text → jump to source card → highlight original passage</p>
            </div>

            <div class="feature-card proposed">
                <span class="status-badge new">NEW</span>
                <h3>Hierarchical Outlines</h3>
                <p>Collapse/expand card clusters, zoom to semantic levels</p>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Priority 1: Quote Extraction & Linking</h2>

        <div class="card priority">
            <h3>User Flow</h3>
            <p>Reading card A → Select passage → "Extract Quote" → Creates card B with quote → Adds citation link → Card A shows "Quoted in: [Card B]"</p>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Implementation Design</strong>
                <span class="arrow">▸</span>
            </div>
            <div class="collapsible-content">
                <h4>1. Selection Detection in CardNode</h4>
                <pre><code>// Add to CardNode.tsx
const handleTextSelection = () => {
  const selection = window.getSelection();
  const text = selection?.toString().trim();

  if (!text || text.length < 10) return;

  // Show quote extraction button
  setShowQuoteButton(true);
  setSelectedText(text);

  // Get selection position for button placement
  const range = selection?.getRangeAt(0);
  const rect = range?.getBoundingClientRect();
  setQuoteButtonPosition({ x: rect.right, y: rect.bottom });
};</code></pre>

                <h4>2. Quote Card Creation</h4>
                <pre><code>// New utility: src/utils/quoteExtraction.ts
interface QuoteCard {
  id: string;
  content: string;  // The quoted text
  cardType: 'quote';
  sourceCardId: string;  // Link to original
  sourceSelection: {
    text: string;
    startOffset: number;
    endOffset: number;
  };
  citation: string;  // "From: [Source Card Title]"
}

async function createQuoteCard(
  sourceCard: Card,
  selectedText: string,
  selectionRange: { start: number; end: number }
): Promise<Card> {
  const quoteCard: Card = {
    id: generateId(),
    content: `<blockquote>${sanitize(selectedText)}</blockquote>`,
    cardType: 'quote',
    parentCardId: sourceCard.id,
    metadata: {
      ...sourceCard.metadata,
      title: `Quote from: ${sourceCard.metadata.title}`,
    },
    tags: ['quote', ...sourceCard.tags],
    createdAt: Date.now(),
    updatedAt: Date.now(),
  };

  // Create bidirectional connection
  await addConnection(quoteCard.id, sourceCard.id, 'references', 'Quoted from');

  return quoteCard;
}</code></pre>

                <h4>3. Highlight Source in Original Card</h4>
                <pre><code>// When viewing source card, highlight quoted passages
const highlightQuotes = (content: string, quotes: QuoteReference[]) => {
  let highlighted = content;

  quotes.forEach(quote => {
    const pattern = escapeRegex(quote.text);
    highlighted = highlighted.replace(
      new RegExp(pattern, 'g'),
      `<mark class="quoted-text" data-quote-id="${quote.quoteCardId}">$&</mark>`
    );
  });

  return highlighted;
};

// CSS for quoted text
<style>
.quoted-text {
  background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
  border-bottom: 2px solid var(--chinese-gold);
  cursor: pointer;
  transition: all 0.2s ease;
}

.quoted-text:hover {
  background: rgba(255, 215, 0, 0.4);
  transform: translateY(-1px);
}
</style></code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Priority 2: Backlinks Panel</h2>

        <div class="card priority">
            <h3>Concept</h3>
            <p>Every card shows a "Referenced by" section listing all cards that link to it, creating bidirectional navigation like Roam Research or Obsidian.</p>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Implementation Design</strong>
                <span class="arrow">▸</span>
            </div>
            <div class="collapsible-content">
                <h4>1. Compute Backlinks</h4>
                <pre><code>// New utility: src/utils/backlinks.ts
interface Backlink {
  cardId: string;
  cardTitle: string;
  connectionType: ConnectionType;
  connectionLabel?: string;
  createdAt: number;
}

function getBacklinks(
  targetCardId: string,
  allConnections: CardConnection[],
  allCards: Card[]
): Backlink[] {
  // Find all connections where target is the destination
  const incomingConnections = allConnections.filter(
    conn => conn.target === targetCardId
  );

  return incomingConnections.map(conn => {
    const sourceCard = allCards.find(c => c.id === conn.source);
    return {
      cardId: conn.source,
      cardTitle: sourceCard?.metadata.title || 'Unknown',
      connectionType: conn.type,
      connectionLabel: conn.label,
      createdAt: conn.metadata.createdAt,
    };
  }).sort((a, b) => b.createdAt - a.createdAt);
}</code></pre>

                <h4>2. Backlinks UI Component</h4>
                <pre><code>// src/components/BacklinksPanel.tsx
interface BacklinksPanelProps {
  cardId: string;
  backlinks: Backlink[];
  onNavigate: (cardId: string) => void;
}

export const BacklinksPanel: React.FC<BacklinksPanelProps> = ({
  cardId,
  backlinks,
  onNavigate,
}) => {
  if (backlinks.length === 0) return null;

  return (
    <div className="backlinks-panel">
      <h4>Referenced by {backlinks.length} card{backlinks.length > 1 ? 's' : ''}</h4>
      <ul className="backlinks-list">
        {backlinks.map(link => (
          <li key={link.cardId} onClick={() => onNavigate(link.cardId)}>
            <span className="connection-type">{link.connectionType}</span>
            <span className="card-title">{link.cardTitle}</span>
            {link.connectionLabel && (
              <span className="connection-label">"{link.connectionLabel}"</span>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
};

// CSS
<style>
.backlinks-panel {
  background: rgba(255, 215, 0, 0.05);
  border-top: 2px solid var(--chinese-gold);
  padding: 8px;
  margin-top: 8px;
}

.backlinks-list {
  list-style: none;
  padding: 0;
}

.backlinks-list li {
  padding: 4px;
  margin: 2px 0;
  cursor: pointer;
  border-left: 2px solid transparent;
  transition: all 0.2s ease;
}

.backlinks-list li:hover {
  background: rgba(139, 0, 0, 0.05);
  border-left-color: var(--chinese-red);
  transform: translateX(2px);
}

.connection-type {
  background: var(--chinese-gold);
  padding: 2px 4px;
  border-radius: 2px;
  font-size: 10px;
  font-weight: 700;
  margin-right: 6px;
}
</style></code></pre>

                <h4>3. Integration in CardNode</h4>
                <pre><code>// In CardNode.tsx
const CardNode = ({ data }: { data: { card: Card } }) => {
  const { connections } = useCanvasState();
  const backlinks = useMemo(() =>
    getBacklinks(data.card.id, connections, allCards),
    [data.card.id, connections]
  );

  return (
    <div className="card-node">
      {/* Existing card content */}
      <div dangerouslySetInnerHTML={{ __html: data.card.content }} />

      {/* Backlinks panel */}
      <BacklinksPanel
        cardId={data.card.id}
        backlinks={backlinks}
        onNavigate={(cardId) => {
          // Focus/highlight the referenced card
          focusCard(cardId);
        }}
      />
    </div>
  );
};</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Priority 3: Inline Citation Jumping</h2>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Implementation Design</strong>
                <span class="arrow">▸</span>
            </div>
            <div class="collapsible-content">
                <h4>1. Citation Markup</h4>
                <pre><code>// When creating quote cards, add citation markers
const citationHTML = `
<blockquote cite="${sourceCard.id}">
  ${quotedText}
  <footer>
    <cite>
      <a href="#" data-card-id="${sourceCard.id}" class="citation-link">
        Source: ${sourceCard.metadata.title}
      </a>
    </cite>
  </footer>
</blockquote>
`;</code></pre>

                <h4>2. Citation Click Handler</h4>
                <pre><code>// In CardNode, attach click handlers to citation links
useEffect(() => {
  const handleCitationClick = (e: MouseEvent) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('citation-link')) {
      e.preventDefault();
      const targetCardId = target.dataset.cardId;
      if (targetCardId) {
        // Zoom to source card and highlight quoted text
        focusCardWithHighlight(targetCardId, quotedText);
      }
    }
  };

  cardElement.addEventListener('click', handleCitationClick);
  return () => cardElement.removeEventListener('click', handleCitationClick);
}, []);</code></pre>

                <h4>3. Focus with Highlight Animation</h4>
                <pre><code>// src/utils/cardNavigation.ts
async function focusCardWithHighlight(
  cardId: string,
  textToHighlight: string
) {
  // 1. Zoom to card
  const { fitView } = useReactFlow();
  fitView({
    nodes: [{ id: cardId }],
    padding: 0.3,
    duration: 600,
  });

  // 2. Highlight text
  await new Promise(resolve => setTimeout(resolve, 700));

  const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
  if (!cardElement) return;

  // Find and highlight text
  const walker = document.createTreeWalker(
    cardElement,
    NodeFilter.SHOW_TEXT
  );

  let node;
  while (node = walker.nextNode()) {
    if (node.textContent?.includes(textToHighlight)) {
      const parent = node.parentElement;
      if (parent) {
        parent.classList.add('citation-highlight');
        setTimeout(() => {
          parent.classList.remove('citation-highlight');
        }, 3000);
      }
    }
  }
}

// CSS
<style>
@keyframes highlight-pulse {
  0%, 100% {
    background: rgba(255, 215, 0, 0.6);
    box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.3);
  }
  50% {
    background: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 0 8px rgba(255, 215, 0, 0.2);
  }
}

.citation-highlight {
  animation: highlight-pulse 1.5s ease-in-out 2;
  border-radius: 3px;
}
</style></code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Priority 4: Hierarchical Outline View</h2>

        <div class="collapsible critical open">
            <div class="collapsible-header" onclick="this.parentElement.classList.toggle('open')">
                <strong>Implementation Design</strong>
                <span class="arrow">▸</span>
            </div>
            <div class="collapsible-content">
                <h4>1. Card Hierarchy Detection</h4>
                <pre><code>// Build tree from connections
interface CardTreeNode {
  card: Card;
  children: CardTreeNode[];
  parent?: CardTreeNode;
  depth: number;
  collapsed: boolean;
}

function buildCardHierarchy(
  cards: Card[],
  connections: CardConnection[]
): CardTreeNode[] {
  // Find root cards (no incoming 'generated-from' connections)
  const childIds = new Set(
    connections
      .filter(c => c.type === 'generated-from')
      .map(c => c.source)
  );

  const roots = cards
    .filter(c => !childIds.has(c.id))
    .map(c => createNode(c, 0));

  // Recursively build tree
  roots.forEach(root => attachChildren(root, cards, connections));

  return roots;
}

function createNode(card: Card, depth: number): CardTreeNode {
  return {
    card,
    children: [],
    depth,
    collapsed: card.collapsed || false,
  };
}

function attachChildren(
  node: CardTreeNode,
  allCards: Card[],
  connections: CardConnection[]
) {
  const childConnections = connections.filter(
    c => c.type === 'generated-from' && c.target === node.card.id
  );

  node.children = childConnections
    .map(conn => {
      const childCard = allCards.find(c => c.id === conn.source);
      if (!childCard) return null;
      const childNode = createNode(childCard, node.depth + 1);
      childNode.parent = node;
      attachChildren(childNode, allCards, connections);
      return childNode;
    })
    .filter(Boolean) as CardTreeNode[];
}</code></pre>

                <h4>2. Outline View Component</h4>
                <pre><code>// src/components/OutlineView.tsx
export const OutlineView: React.FC<{
  roots: CardTreeNode[];
  onToggle: (cardId: string) => void;
  onNavigate: (cardId: string) => void;
}> = ({ roots, onToggle, onNavigate }) => {
  return (
    <div className="outline-view">
      {roots.map(root => (
        <OutlineNode
          key={root.card.id}
          node={root}
          onToggle={onToggle}
          onNavigate={onNavigate}
        />
      ))}
    </div>
  );
};

const OutlineNode: React.FC = ({ node, onToggle, onNavigate }) => {
  return (
    <div className="outline-node" style={{ marginLeft: node.depth * 16 }}>
      <div className="node-header">
        {node.children.length > 0 && (
          <button
            className="collapse-btn"
            onClick={() => onToggle(node.card.id)}
          >
            {node.collapsed ? '▸' : '▾'}
          </button>
        )}
        <span
          className="node-title"
          onClick={() => onNavigate(node.card.id)}
        >
          {node.card.metadata.title}
        </span>
        <span className="node-meta">
          {node.children.length > 0 && `(${node.children.length})`}
        </span>
      </div>

      {!node.collapsed && node.children.length > 0 && (
        <div className="node-children">
          {node.children.map(child => (
            <OutlineNode
              key={child.card.id}
              node={child}
              onToggle={onToggle}
              onNavigate={onNavigate}
            />
          ))}
        </div>
      )}
    </div>
  );
};</code></pre>

                <h4>3. Integration: Toggle Between Canvas & Outline</h4>
                <pre><code>// In Canvas.tsx, add view mode toggle
const [viewMode, setViewMode] = useState<'spatial' | 'outline'>('spatial');

return (
  <>
    {/* View mode toggle */}
    <button onClick={() => setViewMode(viewMode === 'spatial' ? 'outline' : 'spatial')}>
      {viewMode === 'spatial' ? '📋 Outline View' : '🗺️ Spatial View'}
    </button>

    {viewMode === 'spatial' ? (
      <ReactFlow nodes={nodes} edges={edges} />
    ) : (
      <OutlineView
        roots={cardHierarchy}
        onToggle={(cardId) => {
          const card = cards.find(c => c.id === cardId);
          if (card) {
            updateCard({ ...card, collapsed: !card.collapsed });
          }
        }}
        onNavigate={(cardId) => {
          // Switch to spatial view and focus card
          setViewMode('spatial');
          setTimeout(() => focusCard(cardId), 100);
        }}
      />
    )}
  </>
);</code></pre>
            </div>
        </div>

        <div class="divider"></div>

        <h2>Implementation Roadmap</h2>

        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Priority</th>
                    <th>Complexity</th>
                    <th>Time Est.</th>
                    <th>Dependencies</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Quote Extraction</td>
                    <td>🔴 High</td>
                    <td>Medium</td>
                    <td>4-6h</td>
                    <td>Card connections</td>
                </tr>
                <tr>
                    <td>Backlinks Panel</td>
                    <td>🔴 High</td>
                    <td>Low</td>
                    <td>2-3h</td>
                    <td>Card connections</td>
                </tr>
                <tr>
                    <td>Citation Jumping</td>
                    <td>🟡 Medium</td>
                    <td>Medium</td>
                    <td>3-4h</td>
                    <td>Quote extraction</td>
                </tr>
                <tr>
                    <td>Outline View</td>
                    <td>🟡 Medium</td>
                    <td>High</td>
                    <td>6-8h</td>
                    <td>Hierarchy detection</td>
                </tr>
                <tr>
                    <td>Multi-Card Queries</td>
                    <td>🔴 High</td>
                    <td>Medium</td>
                    <td>5-6h</td>
                    <td>ChatService (exists)</td>
                </tr>
            </tbody>
        </table>

        <div class="divider"></div>

        <div class="card priority">
            <h3>Hypertext Navigation: Complete User Journey</h3>
            <div class="workflow">
                <div class="workflow-step">User clips 10 research articles</div>
                <div class="workflow-step">Arranges them spatially by topic</div>
                <div class="workflow-step">Reads article A, finds key quote</div>
                <div class="workflow-step">Selects text → "Extract Quote" → Creates Quote Card B</div>
                <div class="workflow-step">Card A shows "Quoted in: Card B" (backlink)</div>
                <div class="workflow-step">Card B shows "Source: Card A" (citation link)</div>
                <div class="workflow-step">Later, reading Card B</div>
                <div class="workflow-step">Clicks citation link → Zooms to Card A → Highlights original passage</div>
                <div class="workflow-step">Sees Card A has 3 backlinks (Cards B, C, D all quoted it)</div>
                <div class="workflow-step">Switches to Outline View → Sees hierarchical structure</div>
                <div class="workflow-step">Collapses branch → Returns to spatial view</div>
                <div class="workflow-step">Selects Cards A, B, C → Multi-card query "Compare perspectives"</div>
                <div class="workflow-step">LLM synthesizes across all three with citations</div>
            </div>
        </div>

        <div class="important-always-visible" style="margin-top: 8px;">
            <h2>Key Insight</h2>
            <p>Nabokov already has the foundation: connections, conversations, spatial layout. Adding quote extraction, backlinks, and citation jumping transforms it into a <strong>true hypertext system</strong> where information fragments are <strong>densely interconnected and freely traversable</strong>.</p>
        </div>
    </div>

    <script>
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', function() {
                this.parentElement.classList.toggle('open');
            });
        });

        // Auto-open critical sections
        document.querySelectorAll('.collapsible.critical').forEach(el => {
            el.classList.add('open');
        });
    </script>
</body>
</html>