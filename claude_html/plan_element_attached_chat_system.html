<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan: Element-Attached Chat System</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --ink-black: #2C2416;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #8B7355;
            --level-4: #666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.3;
            font-size: 14px;
            padding: 12px;
        }

        h1 {
            font-size: 28px;
            font-weight: 900;
            margin: 8px 0;
            padding: 8px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 {
            font-size: 20px;
            font-weight: 700;
            margin: 12px 0 6px 0;
            padding: 6px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 8px 0 4px 0;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 14px;
            font-weight: 500;
            margin: 4px 0 2px 0;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), white);
            border: 3px solid var(--chinese-gold);
            padding: 20px;
            margin: 12px 0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 10px 0;
        }

        .full-width {
            grid-column: span 2;
        }

        .collapsible {
            margin: 10px 0;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 6px;
            overflow: hidden;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 12px 14px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 4px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 15px;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible.critical .collapsible-header {
            border-left: 5px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.08);
        }

        .collapsible.warning .collapsible-header {
            border-left: 5px solid #F57C00;
            background: rgba(245, 124, 0, 0.08);
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 14px;
            font-weight: bold;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 14px;
        }

        .collapsible.open .collapsible-content {
            max-height: 8000px;
            padding: 18px;
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }

        .dense-list li {
            padding: 8px 0 8px 18px;
            position: relative;
            line-height: 1.6;
        }

        .dense-list li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 14px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .indent-1 { margin-left: 18px; color: var(--level-3); font-size: 13px; margin-top: 4px; }
        .indent-2 { margin-left: 36px; }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 6px;
            padding: 14px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .card.bad {
            border-left: 5px solid #C62828;
            background: linear-gradient(135deg, rgba(198, 40, 40, 0.05), white);
        }

        .card.warning {
            border-left: 5px solid #F57C00;
            background: linear-gradient(135deg, rgba(245, 124, 0, 0.05), white);
        }

        .card.good {
            border-left: 5px solid #2E7D32;
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.05), white);
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.4), rgba(255, 255, 255, 0.6));
            border: 1px solid rgba(139, 0, 0, 0.15);
            padding: 6px 8px;
            margin: 6px 0;
            font-size: 13px;
            line-height: 1.5;
            font-family: 'Monaco', 'Menlo', monospace;
            border-radius: 4px;
        }

        pre {
            padding: 14px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 13px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 10px;
            text-align: left;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }

        .metric {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            margin: 6px 6px 6px 0;
        }

        .metric.important {
            background: linear-gradient(135deg, var(--chinese-gold), #FFE55C);
            color: #5D4E00;
        }

        .metric.critical {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
        }

        button {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 8px 16px;
            margin: 6px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 0, 0, 0.3);
            border-color: var(--chinese-gold);
        }

        .controls {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 20px 0;
        }

        .emoji {
            font-size: 24px;
            margin-right: 10px;
        }

        .status-bad {
            color: #C62828;
            font-weight: 600;
        }

        .status-good {
            color: #2E7D32;
            font-weight: 600;
        }

        .status-warning {
            color: #F57C00;
            font-weight: 600;
        }

        .diagram {
            background: white;
            border: 2px solid var(--chinese-gold);
            border-radius: 6px;
            padding: 16px;
            margin: 12px 0;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.8;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
    </div>

    <div class="important-always-visible">
        <h1><span class="emoji">🎯</span>Plan: Element-Attached Chat System</h1>

        <div class="two-column-layout">
            <div>
                <h3>Objective</h3>
                <p>Transform inline chat from page-level to element-specific, with persistence and multi-window support.</p>

                <h4 style="margin-top: 14px;">Key Requirements</h4>
                <ul class="dense-list">
                    <li><strong>Element Selector:</strong> Ctrl+Shift+C activates element picker</li>
                    <li><strong>Element Attachment:</strong> Chat windows attach to specific DOM elements</li>
                    <li><strong>Persistence:</strong> Chat history persists per element</li>
                    <li><strong>Reopen Behavior:</strong> Selecting same element reopens previous chat</li>
                    <li><strong>Multiple Windows:</strong> Multiple element-chats open simultaneously</li>
                    <li><strong>Visual Indicators:</strong> Show which elements have attached chats</li>
                </ul>
            </div>

            <div>
                <h3>Complexity Assessment</h3>
                <div class="metric critical">Complexity: HIGH</div>
                <div class="metric critical">Time Estimate: 6-8 hours</div>
                <div class="metric important">Risk: MEDIUM</div>

                <h4 style="margin-top: 14px;">Major Components</h4>
                <ul class="dense-list">
                    <li>Element identification system</li>
                    <li>Chat persistence layer</li>
                    <li>Multi-window management</li>
                    <li>Visual indicator overlay</li>
                    <li>Storage architecture redesign</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="divider"></div>

    <h2>🏗️ Architecture Overview</h2>

    <div class="card good">
        <h3>New User Flow</h3>
        <div class="diagram">
1. User presses <strong>Ctrl+Shift+C</strong>
   ↓
2. Element selector activates (chat mode indicator)
   ↓
3. User hovers over elements (highlight + chat icon tooltip)
   ↓
4. User clicks element
   ↓
5. System checks: Does this element have existing chat?
   ├─ YES → Load existing chat history, reopen window
   └─ NO  → Create new chat window, assign element ID
   ↓
6. Chat window appears next to element
   ↓
7. User has conversation (persisted in real-time)
   ↓
8. User closes window (chat history saved)
   ↓
9. Element shows chat indicator (💬 icon overlay)
   ↓
10. User can reselect same element to reopen chat
        </div>
    </div>

    <div class="two-column-layout">
        <div class="card warning">
            <h3>Current State</h3>
            <ul class="dense-list">
                <li><strong>Shortcut:</strong> Opens page-level chat</li>
                <li><strong>Single Instance:</strong> One chat at a time</li>
                <li><strong>No Persistence:</strong> History lost on close</li>
                <li><strong>No Element Link:</strong> Not tied to specific elements</li>
            </ul>
        </div>

        <div class="card good">
            <h3>Desired State</h3>
            <ul class="dense-list">
                <li><strong>Shortcut:</strong> Activates element picker</li>
                <li><strong>Multi-Instance:</strong> Multiple chats simultaneously</li>
                <li><strong>Persistence:</strong> History saved per element</li>
                <li><strong>Element-Linked:</strong> Each chat tied to DOM element</li>
            </ul>
        </div>
    </div>

    <div class="divider"></div>

    <div class="collapsible critical open">
        <div class="collapsible-header">
            <span>🔧 Implementation Steps</span>
            <span class="arrow">▶</span>
        </div>
        <div class="collapsible-content">
            <h2>Phase 1: Element Identification System</h2>

            <ol class="dense-list">
                <li><strong>Create element ID assignment service</strong>
                    <div class="indent-1">File: <code>src/services/elementIdService.ts</code></div>
                    <div class="indent-1">Function: <code>assignElementChatId(element: HTMLElement): string</code></div>
                    <div class="indent-1">Add <code>data-nabokov-chat-id</code> attribute to element</div>
                    <div class="indent-1">Generate stable ID: <code>generateElementId(element)</code> using CSS path + position</div>
                </li>

                <li><strong>Create element lookup service</strong>
                    <div class="indent-1">Function: <code>findElementByChatId(chatId: string): HTMLElement | null</code></div>
                    <div class="indent-1">Search DOM for elements with matching data-nabokov-chat-id</div>
                    <div class="indent-1">Fallback: Use CSS selector path if element moved</div>
                </li>

                <li><strong>Create stable element descriptor</strong>
                    <div class="indent-1">Store: tagName, id, classes, text content preview</div>
                    <div class="indent-1">CSS selector path for relocating element</div>
                    <div class="indent-1">XPath as backup identifier</div>
                </li>
            </ol>

            <h2>Phase 2: Chat Storage Architecture</h2>

            <ol class="dense-list" start="4">
                <li><strong>Design storage schema</strong>
                    <div class="indent-1">File: <code>src/types/elementChat.ts</code></div>
                    <pre><code>interface ElementChatSession {
  chatId: string;              // Unique chat session ID
  elementId: string;           // Element's data-nabokov-chat-id
  pageUrl: string;             // URL where element exists
  elementDescriptor: {         // For relocating element
    tagName: string;
    cssSelector: string;
    xpath: string;
    textPreview: string;
  };
  messages: Message[];         // Chat history
  windowState?: {              // Last window position/size
    position: { x: number; y: number };
    size: { width: number; height: number };
    collapsed: boolean;
  };
  createdAt: number;
  lastActive: number;
}</code></pre>
                </li>

                <li><strong>Create chat persistence service</strong>
                    <div class="indent-1">File: <code>src/services/elementChatService.ts</code></div>
                    <div class="indent-1"><code>saveElementChat(session: ElementChatSession)</code></div>
                    <div class="indent-1"><code>loadElementChat(elementId: string, pageUrl: string): ElementChatSession | null</code></div>
                    <div class="indent-1"><code>getAllElementChats(pageUrl: string): ElementChatSession[]</code></div>
                    <div class="indent-1"><code>deleteElementChat(chatId: string)</code></div>
                </li>

                <li><strong>Implement storage key structure</strong>
                    <div class="indent-1">Key: <code>nabokov_element_chats_${hashedUrl}</code></div>
                    <div class="indent-1">Value: <code>Map&lt;elementId, ElementChatSession&gt;</code></div>
                    <div class="indent-1">Separate key per page URL to avoid storage bloat</div>
                </li>
            </ol>

            <h2>Phase 3: ElementSelector Chat Mode</h2>

            <ol class="dense-list" start="7">
                <li><strong>Add mode parameter to ElementSelector</strong>
                    <div class="indent-1">File: <code>src/components/ElementSelector.tsx</code></div>
                    <div class="indent-1">Prop: <code>mode: 'capture' | 'chat'</code></div>
                    <div class="indent-1">Change visual indicator based on mode</div>
                </li>

                <li><strong>Update visual styling for chat mode</strong>
                    <div class="indent-1">Mode indicator: <strong>💬 CHAT MODE</strong> (blue gradient)</div>
                    <div class="indent-1">Tooltip shows: "Click to attach chat" + existing chat indicator</div>
                    <div class="indent-1">Highlight elements with existing chats in green</div>
                </li>

                <li><strong>Handle element click in chat mode</strong>
                    <div class="indent-1">Assign element ID if not present</div>
                    <div class="indent-1">Check for existing chat session</div>
                    <div class="indent-1">Call <code>onChatSelect(element, existingChat)</code> callback</div>
                </li>

                <li><strong>Show existing chat indicators</strong>
                    <div class="indent-1">On hover, show 💬 icon if element has chat history</div>
                    <div class="indent-1">Tooltip: "This element has a chat (3 messages)"</div>
                </li>
            </ol>

            <h2>Phase 4: Multi-Window Chat Management</h2>

            <ol class="dense-list" start="11">
                <li><strong>Create ElementChatWindowManager</strong>
                    <div class="indent-1">File: <code>src/services/elementChatWindowManager.ts</code></div>
                    <div class="indent-1">Track multiple chat windows by elementId</div>
                    <div class="indent-1">Manage z-index ordering</div>
                    <div class="indent-1">Auto-position windows near elements</div>
                </li>

                <li><strong>Window positioning strategy</strong>
                    <div class="indent-1">Calculate position relative to element's bounding rect</div>
                    <div class="indent-1">Prefer right side, fallback to left if no space</div>
                    <div class="indent-1">Ensure window stays within viewport</div>
                    <div class="indent-1">Collision detection with other chat windows</div>
                </li>

                <li><strong>Update InlineChatWindow for element attachment</strong>
                    <div class="indent-1">File: <code>src/components/InlineChatWindow.tsx</code></div>
                    <div class="indent-1">Prop: <code>attachedElement?: HTMLElement</code></div>
                    <div class="indent-1">Prop: <code>chatSession?: ElementChatSession</code></div>
                    <div class="indent-1">Load initial messages from session</div>
                    <div class="indent-1">Auto-save messages on change</div>
                </li>

                <li><strong>Add connection line to element</strong>
                    <div class="indent-1">Draw line from window to element (optional visual enhancement)</div>
                    <div class="indent-1">Update line position on window drag</div>
                </li>
            </ol>

            <h2>Phase 5: Content Script Integration</h2>

            <ol class="dense-list" start="15">
                <li><strong>Update content script message handler</strong>
                    <div class="indent-1">File: <code>src/content/index.tsx</code></div>
                    <div class="indent-1">Change <code>OPEN_INLINE_CHAT</code> → <code>ACTIVATE_CHAT_SELECTOR</code></div>
                    <div class="indent-1">Activate ElementSelector in chat mode</div>
                </li>

                <li><strong>Handle element selection callback</strong>
                    <div class="indent-1">Function: <code>handleChatElementSelected(element, existingChat)</code></div>
                    <div class="indent-1">Load or create chat session</div>
                    <div class="indent-1">Open InlineChatWindow attached to element</div>
                </li>

                <li><strong>Manage multiple chat windows</strong>
                    <div class="indent-1">Use ElementChatWindowManager to track all open chats</div>
                    <div class="indent-1">Allow multiple windows simultaneously</div>
                    <div class="indent-1">Auto-save on close, restore on reopen</div>
                </li>

                <li><strong>Add visual indicator overlay</strong>
                    <div class="indent-1">Inject small 💬 icon next to elements with chats</div>
                    <div class="indent-1">Icon positioned absolutely relative to element</div>
                    <div class="indent-1">Click icon to reopen chat</div>
                    <div class="indent-1">Update on page scroll/resize</div>
                </li>
            </ol>

            <h2>Phase 6: Background Script Updates</h2>

            <ol class="dense-list" start="19">
                <li><strong>Update keyboard command handler</strong>
                    <div class="indent-1">File: <code>src/background/index.ts</code></div>
                    <div class="indent-1">Change command: <code>toggle-inline-chat</code> → <code>activate-chat-selector</code></div>
                    <div class="indent-1">Send <code>ACTIVATE_CHAT_SELECTOR</code> message</div>
                </li>

                <li><strong>Update context menu</strong>
                    <div class="indent-1">Keep existing "Chat about this" context menu</div>
                    <div class="indent-1">Should also use element selector for consistency</div>
                </li>
            </ol>

            <h2>Phase 7: Testing & Polish</h2>

            <ol class="dense-list" start="21">
                <li><strong>Test element identification</strong>
                    <div class="indent-1">Verify stable IDs across page reloads</div>
                    <div class="indent-1">Test with dynamic content (SPAs)</div>
                </li>

                <li><strong>Test persistence</strong>
                    <div class="indent-1">Chat history saves correctly</div>
                    <div class="indent-1">Reopening element loads history</div>
                    <div class="indent-1">Multiple chats on same page persist independently</div>
                </li>

                <li><strong>Test multiple windows</strong>
                    <div class="indent-1">Open 3+ chat windows simultaneously</div>
                    <div class="indent-1">Verify z-index management</div>
                    <div class="indent-1">Check window positioning doesn't overlap</div>
                </li>

                <li><strong>Performance testing</strong>
                    <div class="indent-1">Test with 10+ elements with chat history</div>
                    <div class="indent-1">Verify no lag on page load</div>
                </li>

                <li><strong>UI polish</strong>
                    <div class="indent-1">Chat indicators styled consistently</div>
                    <div class="indent-1">Smooth animations for window open/close</div>
                    <div class="indent-1">Proper error handling for missing elements</div>
                </li>
            </ol>
        </div>
    </div>

    <div class="divider"></div>

    <div class="two-column-layout">
        <div class="collapsible critical open">
            <div class="collapsible-header">
                <span>🗂️ New File Structure</span>
                <span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <h4>New Services</h4>
                <pre><code>src/services/
  elementIdService.ts
    - assignElementChatId()
    - findElementByChatId()
    - generateElementDescriptor()

  elementChatService.ts
    - saveElementChat()
    - loadElementChat()
    - getAllElementChats()
    - deleteElementChat()

  elementChatWindowManager.ts
    - openChatWindow()
    - closeChatWindow()
    - getChatWindow()
    - getAllWindows()
    - calculatePosition()
    - bringToFront()</code></pre>

                <h4>New Types</h4>
                <pre><code>src/types/
  elementChat.ts
    - ElementChatSession
    - ElementDescriptor
    - ChatWindowState</code></pre>
            </div>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header">
                <span>🎨 Visual Indicator Component</span>
                <span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <h4>ChatIndicatorOverlay.tsx</h4>
                <pre><code>// Renders 💬 icons next to elements with chats
interface ChatIndicatorProps {
  pageUrl: string;
  onIndicatorClick: (elementId: string) => void;
}

// Positioned absolutely, updates on scroll
// Shows message count on hover
// Click to reopen chat</code></pre>

                <h4>Styling</h4>
                <ul class="dense-list">
                    <li>Small 💬 icon (16×16px)</li>
                    <li>Gold background with red border</li>
                    <li>Pulse animation to draw attention</li>
                    <li>Badge showing message count</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="divider"></div>

    <div class="collapsible open full-width">
        <div class="collapsible-header">
            <span>✅ Testing Checklist</span>
            <span class="arrow">▶</span>
        </div>
        <div class="collapsible-content">
            <h3>Element Selection Flow</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test</th>
                        <th>Action</th>
                        <th>Expected Result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Activate selector</td>
                        <td>Press Ctrl+Shift+C</td>
                        <td>Element selector activates in chat mode (blue indicator)</td>
                    </tr>
                    <tr>
                        <td>Hover element</td>
                        <td>Move mouse over elements</td>
                        <td>Elements highlight, tooltip shows "Click to attach chat"</td>
                    </tr>
                    <tr>
                        <td>Click element (new)</td>
                        <td>Click element without existing chat</td>
                        <td>New chat window opens next to element</td>
                    </tr>
                    <tr>
                        <td>Click element (existing)</td>
                        <td>Click element with chat history</td>
                        <td>Chat window opens with previous messages loaded</td>
                    </tr>
                    <tr>
                        <td>Element ID assigned</td>
                        <td>Inspect element after selection</td>
                        <td>Has data-nabokov-chat-id attribute</td>
                    </tr>
                </tbody>
            </table>

            <h3>Chat Window Behavior</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test</th>
                        <th>Action</th>
                        <th>Expected Result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Window positioning</td>
                        <td>Open chat on various elements</td>
                        <td>Window appears to right (or left if no space)</td>
                    </tr>
                    <tr>
                        <td>Send message</td>
                        <td>Type and send message</td>
                        <td>Message appears, auto-saved to storage</td>
                    </tr>
                    <tr>
                        <td>Close window</td>
                        <td>Click close button</td>
                        <td>Window closes, chat indicator appears on element</td>
                    </tr>
                    <tr>
                        <td>Reopen window</td>
                        <td>Click element or indicator again</td>
                        <td>Window reopens with full history</td>
                    </tr>
                    <tr>
                        <td>Multiple windows</td>
                        <td>Open 3+ chat windows</td>
                        <td>All windows visible, independently draggable</td>
                    </tr>
                    <tr>
                        <td>Page reload</td>
                        <td>Reload page</td>
                        <td>Chat indicators reappear, history accessible</td>
                    </tr>
                </tbody>
            </table>

            <h3>Persistence & Storage</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test</th>
                        <th>Action</th>
                        <th>Expected Result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Message persistence</td>
                        <td>Send message, close, reopen</td>
                        <td>Message still there</td>
                    </tr>
                    <tr>
                        <td>Multiple elements</td>
                        <td>Chat with 3 different elements</td>
                        <td>Each has independent history</td>
                    </tr>
                    <tr>
                        <td>Cross-session</td>
                        <td>Close browser, reopen page</td>
                        <td>All chats still accessible</td>
                    </tr>
                    <tr>
                        <td>Element moved</td>
                        <td>Element moves in DOM</td>
                        <td>Chat still linked (via ID)</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="divider"></div>

    <div class="collapsible warning open full-width">
        <div class="collapsible-header">
            <span>⚠️ Potential Issues & Mitigations</span>
            <span class="arrow">▶</span>
        </div>
        <div class="collapsible-content">
            <h3>Issue 1: Element Identification on Dynamic Pages</h3>
            <p><strong>Problem:</strong> SPAs may replace DOM elements, breaking element ID links</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Use multiple identifiers (data attribute + CSS selector + XPath)</li>
                <li>Implement fuzzy matching if exact element not found</li>
                <li>Show warning if element can't be located</li>
            </ul>

            <h3>Issue 2: Storage Limits</h3>
            <p><strong>Problem:</strong> chrome.storage.local has ~5MB limit, chat history could fill it</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Implement chat history pruning (keep last 50 messages per element)</li>
                <li>Store per-page to isolate storage usage</li>
                <li>Add "Clear old chats" functionality</li>
                <li>Warning when storage reaches 80% capacity</li>
            </ul>

            <h3>Issue 3: Performance with Many Chat Indicators</h3>
            <p><strong>Problem:</strong> 100+ chat indicators could slow page load</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Lazy render indicators (only visible ones)</li>
                <li>Use IntersectionObserver for efficient updates</li>
                <li>Debounce scroll/resize handlers</li>
            </ul>

            <h3>Issue 4: Window Positioning Conflicts</h3>
            <p><strong>Problem:</strong> Multiple windows may overlap or go off-screen</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Collision detection algorithm</li>
                <li>Cascade positioning for multiple windows</li>
                <li>Boundary checking to keep windows in viewport</li>
            </ul>

            <h3>Issue 5: Element Moved Off-Screen</h3>
            <p><strong>Problem:</strong> Chat window attached to element that scrolls away</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Option 1: Window stays fixed at last position</li>
                <li>Option 2: Window follows element (update on scroll)</li>
                <li>Option 3: Show indicator when element off-screen</li>
                <li><strong>Recommended:</strong> Option 1 for simplicity</li>
            </ul>
        </div>
    </div>

    <div class="divider"></div>

    <div class="important-always-visible">
        <h2>📊 Implementation Breakdown</h2>

        <div class="two-column-layout">
            <div>
                <h3>Phase Estimates</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Element ID System</td>
                            <td>1-1.5 hours</td>
                        </tr>
                        <tr>
                            <td>Storage Architecture</td>
                            <td>1.5-2 hours</td>
                        </tr>
                        <tr>
                            <td>ElementSelector Updates</td>
                            <td>1 hour</td>
                        </tr>
                        <tr>
                            <td>Window Management</td>
                            <td>1.5-2 hours</td>
                        </tr>
                        <tr>
                            <td>Content Script Integration</td>
                            <td>1 hour</td>
                        </tr>
                        <tr>
                            <td>Testing & Polish</td>
                            <td>1 hour</td>
                        </tr>
                        <tr>
                            <th>Total</th>
                            <th>6-8 hours</th>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div>
                <h3>Success Criteria</h3>
                <ul class="dense-list">
                    <li>✅ Ctrl+Shift+C activates element selector</li>
                    <li>✅ Clicking element opens attached chat window</li>
                    <li>✅ Chat history persists per element</li>
                    <li>✅ Closing and reopening restores full history</li>
                    <li>✅ Multiple chat windows work simultaneously</li>
                    <li>✅ Visual indicators show elements with chats</li>
                    <li>✅ Works across page reloads</li>
                    <li>✅ No performance degradation</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('open');
        }

        function expandAll() {
            document.querySelectorAll('.collapsible').forEach(el => {
                el.classList.add('open');
            });
        }

        function collapseAll() {
            document.querySelectorAll('.collapsible').forEach(el => {
                el.classList.remove('open');
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => toggleCollapsible(header));
            });
        });
    </script>
</body>
</html>