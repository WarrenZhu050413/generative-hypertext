<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan: Element-Attached Chat System</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --ink-black: #2C2416;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #8B7355;
            --level-4: #666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.3;
            font-size: 14px;
            padding: 12px;
        }

        h1 {
            font-size: 28px;
            font-weight: 900;
            margin: 8px 0;
            padding: 8px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 {
            font-size: 20px;
            font-weight: 700;
            margin: 12px 0 6px 0;
            padding: 6px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 8px 0 4px 0;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 14px;
            font-weight: 500;
            margin: 4px 0 2px 0;
            color: var(--level-3);
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), white);
            border: 3px solid var(--chinese-gold);
            padding: 20px;
            margin: 12px 0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 10px 0;
        }

        .full-width {
            grid-column: span 2;
        }

        .collapsible {
            margin: 10px 0;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 6px;
            overflow: hidden;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 12px 14px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 4px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 15px;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible.critical .collapsible-header {
            border-left: 5px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.08);
        }

        .collapsible.warning .collapsible-header {
            border-left: 5px solid #F57C00;
            background: rgba(245, 124, 0, 0.08);
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 14px;
            font-weight: bold;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 14px;
        }

        .collapsible.open .collapsible-content {
            max-height: 8000px;
            padding: 18px;
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }

        .dense-list li {
            padding: 8px 0 8px 18px;
            position: relative;
            line-height: 1.6;
        }

        .dense-list li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 14px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .indent-1 { margin-left: 18px; color: var(--level-3); font-size: 13px; margin-top: 4px; }
        .indent-2 { margin-left: 36px; }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 6px;
            padding: 14px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .card.bad {
            border-left: 5px solid #C62828;
            background: linear-gradient(135deg, rgba(198, 40, 40, 0.05), white);
        }

        .card.warning {
            border-left: 5px solid #F57C00;
            background: linear-gradient(135deg, rgba(245, 124, 0, 0.05), white);
        }

        .card.good {
            border-left: 5px solid #2E7D32;
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.05), white);
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.4), rgba(255, 255, 255, 0.6));
            border: 1px solid rgba(139, 0, 0, 0.15);
            padding: 6px 8px;
            margin: 6px 0;
            font-size: 13px;
            line-height: 1.5;
            font-family: 'Monaco', 'Menlo', monospace;
            border-radius: 4px;
        }

        pre {
            padding: 14px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 13px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 10px;
            text-align: left;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }

        .metric {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            margin: 6px 6px 6px 0;
        }

        .metric.important {
            background: linear-gradient(135deg, var(--chinese-gold), #FFE55C);
            color: #5D4E00;
        }

        .metric.critical {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
        }

        button {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 8px 16px;
            margin: 6px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 0, 0, 0.3);
            border-color: var(--chinese-gold);
        }

        .controls {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 20px 0;
        }

        .emoji {
            font-size: 24px;
            margin-right: 10px;
        }

        .status-bad {
            color: #C62828;
            font-weight: 600;
        }

        .status-good {
            color: #2E7D32;
            font-weight: 600;
        }

        .status-warning {
            color: #F57C00;
            font-weight: 600;
        }

        .diagram {
            background: white;
            border: 2px solid var(--chinese-gold);
            border-radius: 6px;
            padding: 16px;
            margin: 12px 0;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.8;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
    </div>

    <div class="important-always-visible">
        <h1><span class="emoji">üéØ</span>Plan: Element-Attached Chat System</h1>

        <div class="two-column-layout">
            <div>
                <h3>Objective</h3>
                <p>Transform inline chat from page-level to element-specific, with persistence and multi-window support.</p>

                <h4 style="margin-top: 14px;">Key Requirements</h4>
                <ul class="dense-list">
                    <li><strong>Element Selector:</strong> Ctrl+Shift+C activates element picker</li>
                    <li><strong>Element Attachment:</strong> Chat windows attach to specific DOM elements</li>
                    <li><strong>Persistence:</strong> Chat history persists per element</li>
                    <li><strong>Reopen Behavior:</strong> Selecting same element reopens previous chat</li>
                    <li><strong>Multiple Windows:</strong> Multiple element-chats open simultaneously</li>
                    <li><strong>Visual Indicators:</strong> Show which elements have attached chats</li>
                </ul>
            </div>

            <div>
                <h3>Complexity Assessment</h3>
                <div class="metric critical">Complexity: HIGH</div>
                <div class="metric critical">Time Estimate: 6-8 hours</div>
                <div class="metric important">Risk: MEDIUM</div>

                <h4 style="margin-top: 14px;">Major Components</h4>
                <ul class="dense-list">
                    <li>Element identification system</li>
                    <li>Chat persistence layer</li>
                    <li>Multi-window management</li>
                    <li>Visual indicator overlay</li>
                    <li>Storage architecture redesign</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="divider"></div>

    <h2>üèóÔ∏è Architecture Overview</h2>

    <div class="card good">
        <h3>New User Flow</h3>
        <div class="diagram">
1. User presses <strong>Ctrl+Shift+C</strong>
   ‚Üì
2. Element selector activates (chat mode indicator)
   ‚Üì
3. User hovers over elements (highlight + chat icon tooltip)
   ‚Üì
4. User clicks element
   ‚Üì
5. System checks: Does this element have existing chat?
   ‚îú‚îÄ YES ‚Üí Load existing chat history, reopen window
   ‚îî‚îÄ NO  ‚Üí Create new chat window, assign element ID
   ‚Üì
6. Chat window appears next to element
   ‚Üì
7. User has conversation (persisted in real-time)
   ‚Üì
8. User closes window (chat history saved)
   ‚Üì
9. Element shows chat indicator (üí¨ icon overlay)
   ‚Üì
10. User can reselect same element to reopen chat
        </div>
    </div>

    <div class="two-column-layout">
        <div class="card warning">
            <h3>Current State</h3>
            <ul class="dense-list">
                <li><strong>Shortcut:</strong> Opens page-level chat</li>
                <li><strong>Single Instance:</strong> One chat at a time</li>
                <li><strong>No Persistence:</strong> History lost on close</li>
                <li><strong>No Element Link:</strong> Not tied to specific elements</li>
            </ul>
        </div>

        <div class="card good">
            <h3>Desired State</h3>
            <ul class="dense-list">
                <li><strong>Shortcut:</strong> Activates element picker</li>
                <li><strong>Multi-Instance:</strong> Multiple chats simultaneously</li>
                <li><strong>Persistence:</strong> History saved per element</li>
                <li><strong>Element-Linked:</strong> Each chat tied to DOM element</li>
            </ul>
        </div>
    </div>

    <div class="divider"></div>

    <div class="collapsible critical open">
        <div class="collapsible-header">
            <span>üîß Implementation Steps</span>
            <span class="arrow">‚ñ∂</span>
        </div>
        <div class="collapsible-content">
            <h2>Phase 1: Element Identification System</h2>

            <ol class="dense-list">
                <li><strong>Create element ID assignment service</strong>
                    <div class="indent-1">File: <code>src/services/elementIdService.ts</code></div>
                    <div class="indent-1">Function: <code>assignElementChatId(element: HTMLElement): string</code></div>
                    <div class="indent-1">Add <code>data-nabokov-chat-id</code> attribute to element</div>
                    <div class="indent-1">Generate stable ID: <code>generateElementId(element)</code> using CSS path + position</div>
                </li>

                <li><strong>Create element lookup service</strong>
                    <div class="indent-1">Function: <code>findElementByChatId(chatId: string): HTMLElement | null</code></div>
                    <div class="indent-1">Search DOM for elements with matching data-nabokov-chat-id</div>
                    <div class="indent-1">Fallback: Use CSS selector path if element moved</div>
                </li>

                <li><strong>Create stable element descriptor</strong>
                    <div class="indent-1">Store: tagName, id, classes, text content preview</div>
                    <div class="indent-1">CSS selector path for relocating element</div>
                    <div class="indent-1">XPath as backup identifier</div>
                </li>
            </ol>

            <h2>Phase 2: Chat Storage Architecture</h2>

            <ol class="dense-list" start="4">
                <li><strong>Design storage schema</strong>
                    <div class="indent-1">File: <code>src/types/elementChat.ts</code></div>
                    <pre><code>interface ElementChatSession {
  chatId: string;              // Unique chat session ID
  elementId: string;           // Element's data-nabokov-chat-id
  pageUrl: string;             // URL where element exists
  elementDescriptor: {         // For relocating element
    tagName: string;
    cssSelector: string;
    xpath: string;
    textPreview: string;
  };
  messages: Message[];         // Chat history
  windowState?: {              // Last window position/size
    position: { x: number; y: number };
    size: { width: number; height: number };
    collapsed: boolean;
  };
  createdAt: number;
  lastActive: number;
}</code></pre>
                </li>

                <li><strong>Create chat persistence service</strong>
                    <div class="indent-1">File: <code>src/services/elementChatService.ts</code></div>
                    <div class="indent-1"><code>saveElementChat(session: ElementChatSession)</code></div>
                    <div class="indent-1"><code>loadElementChat(elementId: string, pageUrl: string): ElementChatSession | null</code></div>
                    <div class="indent-1"><code>getAllElementChats(pageUrl: string): ElementChatSession[]</code></div>
                    <div class="indent-1"><code>deleteElementChat(chatId: string)</code></div>
                </li>

                <li><strong>Implement storage key structure</strong>
                    <div class="indent-1">Key: <code>nabokov_element_chats_${hashedUrl}</code></div>
                    <div class="indent-1">Value: <code>Map&lt;elementId, ElementChatSession&gt;</code></div>
                    <div class="indent-1">Separate key per page URL to avoid storage bloat</div>
                </li>
            </ol>

            <h2>Phase 3: ElementSelector Chat Mode</h2>

            <ol class="dense-list" start="7">
                <li><strong>Add mode parameter to ElementSelector</strong>
                    <div class="indent-1">File: <code>src/components/ElementSelector.tsx</code></div>
                    <div class="indent-1">Prop: <code>mode: 'capture' | 'chat'</code></div>
                    <div class="indent-1">Change visual indicator based on mode</div>
                </li>

                <li><strong>Update visual styling for chat mode</strong>
                    <div class="indent-1">Mode indicator: <strong>üí¨ CHAT MODE</strong> (blue gradient)</div>
                    <div class="indent-1">Tooltip shows: "Click to attach chat" + existing chat indicator</div>
                    <div class="indent-1">Highlight elements with existing chats in green</div>
                </li>

                <li><strong>Handle element click in chat mode</strong>
                    <div class="indent-1">Assign element ID if not present</div>
                    <div class="indent-1">Check for existing chat session</div>
                    <div class="indent-1">Call <code>onChatSelect(element, existingChat)</code> callback</div>
                </li>

                <li><strong>Show existing chat indicators</strong>
                    <div class="indent-1">On hover, show üí¨ icon if element has chat history</div>
                    <div class="indent-1">Tooltip: "This element has a chat (3 messages)"</div>
                </li>
            </ol>

            <h2>Phase 4: Multi-Window Chat Management</h2>

            <ol class="dense-list" start="11">
                <li><strong>Create ElementChatWindowManager</strong>
                    <div class="indent-1">File: <code>src/services/elementChatWindowManager.ts</code></div>
                    <div class="indent-1">Track multiple chat windows by elementId</div>
                    <div class="indent-1">Manage z-index ordering</div>
                    <div class="indent-1">Auto-position windows near elements</div>
                </li>

                <li><strong>Window positioning strategy</strong>
                    <div class="indent-1">Calculate position relative to element's bounding rect</div>
                    <div class="indent-1">Prefer right side, fallback to left if no space</div>
                    <div class="indent-1">Ensure window stays within viewport</div>
                    <div class="indent-1">Collision detection with other chat windows</div>
                </li>

                <li><strong>Update InlineChatWindow for element attachment</strong>
                    <div class="indent-1">File: <code>src/components/InlineChatWindow.tsx</code></div>
                    <div class="indent-1">Prop: <code>attachedElement?: HTMLElement</code></div>
                    <div class="indent-1">Prop: <code>chatSession?: ElementChatSession</code></div>
                    <div class="indent-1">Load initial messages from session</div>
                    <div class="indent-1">Auto-save messages on change</div>
                </li>

                <li><strong>Add connection line to element</strong>
                    <div class="indent-1">Draw line from window to element (optional visual enhancement)</div>
                    <div class="indent-1">Update line position on window drag</div>
                </li>
            </ol>

            <h2>Phase 5: Content Script Integration</h2>

            <ol class="dense-list" start="15">
                <li><strong>Update content script message handler</strong>
                    <div class="indent-1">File: <code>src/content/index.tsx</code></div>
                    <div class="indent-1">Change <code>OPEN_INLINE_CHAT</code> ‚Üí <code>ACTIVATE_CHAT_SELECTOR</code></div>
                    <div class="indent-1">Activate ElementSelector in chat mode</div>
                </li>

                <li><strong>Handle element selection callback</strong>
                    <div class="indent-1">Function: <code>handleChatElementSelected(element, existingChat)</code></div>
                    <div class="indent-1">Load or create chat session</div>
                    <div class="indent-1">Open InlineChatWindow attached to element</div>
                </li>

                <li><strong>Manage multiple chat windows</strong>
                    <div class="indent-1">Use ElementChatWindowManager to track all open chats</div>
                    <div class="indent-1">Allow multiple windows simultaneously</div>
                    <div class="indent-1">Auto-save on close, restore on reopen</div>
                </li>

                <li><strong>Add visual indicator overlay</strong>
                    <div class="indent-1">Inject small üí¨ icon next to elements with chats</div>
                    <div class="indent-1">Icon positioned absolutely relative to element</div>
                    <div class="indent-1">Click icon to reopen chat</div>
                    <div class="indent-1">Update on page scroll/resize</div>
                </li>
            </ol>

            <h2>Phase 6: Background Script Updates</h2>

            <ol class="dense-list" start="19">
                <li><strong>Update keyboard command handler</strong>
                    <div class="indent-1">File: <code>src/background/index.ts</code></div>
                    <div class="indent-1">Change command: <code>toggle-inline-chat</code> ‚Üí <code>activate-chat-selector</code></div>
                    <div class="indent-1">Send <code>ACTIVATE_CHAT_SELECTOR</code> message</div>
                </li>

                <li><strong>Update context menu</strong>
                    <div class="indent-1">Keep existing "Chat about this" context menu</div>
                    <div class="indent-1">Should also use element selector for consistency</div>
                </li>
            </ol>

            <h2>Phase 7: Testing & Polish</h2>

            <ol class="dense-list" start="21">
                <li><strong>Test element identification</strong>
                    <div class="indent-1">Verify stable IDs across page reloads</div>
                    <div class="indent-1">Test with dynamic content (SPAs)</div>
                </li>

                <li><strong>Test persistence</strong>
                    <div class="indent-1">Chat history saves correctly</div>
                    <div class="indent-1">Reopening element loads history</div>
                    <div class="indent-1">Multiple chats on same page persist independently</div>
                </li>

                <li><strong>Test multiple windows</strong>
                    <div class="indent-1">Open 3+ chat windows simultaneously</div>
                    <div class="indent-1">Verify z-index management</div>
                    <div class="indent-1">Check window positioning doesn't overlap</div>
                </li>

                <li><strong>Performance testing</strong>
                    <div class="indent-1">Test with 10+ elements with chat history</div>
                    <div class="indent-1">Verify no lag on page load</div>
                </li>

                <li><strong>UI polish</strong>
                    <div class="indent-1">Chat indicators styled consistently</div>
                    <div class="indent-1">Smooth animations for window open/close</div>
                    <div class="indent-1">Proper error handling for missing elements</div>
                </li>
            </ol>
        </div>
    </div>

    <div class="divider"></div>

    <div class="two-column-layout">
        <div class="collapsible critical open">
            <div class="collapsible-header">
                <span>üóÇÔ∏è New File Structure</span>
                <span class="arrow">‚ñ∂</span>
            </div>
            <div class="collapsible-content">
                <h4>New Services</h4>
                <pre><code>src/services/
  elementIdService.ts
    - assignElementChatId()
    - findElementByChatId()
    - generateElementDescriptor()

  elementChatService.ts
    - saveElementChat()
    - loadElementChat()
    - getAllElementChats()
    - deleteElementChat()

  elementChatWindowManager.ts
    - openChatWindow()
    - closeChatWindow()
    - getChatWindow()
    - getAllWindows()
    - calculatePosition()
    - bringToFront()</code></pre>

                <h4>New Types</h4>
                <pre><code>src/types/
  elementChat.ts
    - ElementChatSession
    - ElementDescriptor
    - ChatWindowState</code></pre>
            </div>
        </div>

        <div class="collapsible critical open">
            <div class="collapsible-header">
                <span>üé® Visual Indicator Component</span>
                <span class="arrow">‚ñ∂</span>
            </div>
            <div class="collapsible-content">
                <h4>ChatIndicatorOverlay.tsx</h4>
                <pre><code>// Renders üí¨ icons next to elements with chats
interface ChatIndicatorProps {
  pageUrl: string;
  onIndicatorClick: (elementId: string) => void;
}

// Positioned absolutely, updates on scroll
// Shows message count on hover
// Click to reopen chat</code></pre>

                <h4>Styling</h4>
                <ul class="dense-list">
                    <li>Small üí¨ icon (16√ó16px)</li>
                    <li>Gold background with red border</li>
                    <li>Pulse animation to draw attention</li>
                    <li>Badge showing message count</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="divider"></div>

    <div class="collapsible open full-width">
        <div class="collapsible-header">
            <span>‚úÖ Testing Checklist</span>
            <span class="arrow">‚ñ∂</span>
        </div>
        <div class="collapsible-content">
            <h3>Element Selection Flow</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test</th>
                        <th>Action</th>
                        <th>Expected Result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Activate selector</td>
                        <td>Press Ctrl+Shift+C</td>
                        <td>Element selector activates in chat mode (blue indicator)</td>
                    </tr>
                    <tr>
                        <td>Hover element</td>
                        <td>Move mouse over elements</td>
                        <td>Elements highlight, tooltip shows "Click to attach chat"</td>
                    </tr>
                    <tr>
                        <td>Click element (new)</td>
                        <td>Click element without existing chat</td>
                        <td>New chat window opens next to element</td>
                    </tr>
                    <tr>
                        <td>Click element (existing)</td>
                        <td>Click element with chat history</td>
                        <td>Chat window opens with previous messages loaded</td>
                    </tr>
                    <tr>
                        <td>Element ID assigned</td>
                        <td>Inspect element after selection</td>
                        <td>Has data-nabokov-chat-id attribute</td>
                    </tr>
                </tbody>
            </table>

            <h3>Chat Window Behavior</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test</th>
                        <th>Action</th>
                        <th>Expected Result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Window positioning</td>
                        <td>Open chat on various elements</td>
                        <td>Window appears to right (or left if no space)</td>
                    </tr>
                    <tr>
                        <td>Send message</td>
                        <td>Type and send message</td>
                        <td>Message appears, auto-saved to storage</td>
                    </tr>
                    <tr>
                        <td>Close window</td>
                        <td>Click close button</td>
                        <td>Window closes, chat indicator appears on element</td>
                    </tr>
                    <tr>
                        <td>Reopen window</td>
                        <td>Click element or indicator again</td>
                        <td>Window reopens with full history</td>
                    </tr>
                    <tr>
                        <td>Multiple windows</td>
                        <td>Open 3+ chat windows</td>
                        <td>All windows visible, independently draggable</td>
                    </tr>
                    <tr>
                        <td>Page reload</td>
                        <td>Reload page</td>
                        <td>Chat indicators reappear, history accessible</td>
                    </tr>
                </tbody>
            </table>

            <h3>Persistence & Storage</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test</th>
                        <th>Action</th>
                        <th>Expected Result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Message persistence</td>
                        <td>Send message, close, reopen</td>
                        <td>Message still there</td>
                    </tr>
                    <tr>
                        <td>Multiple elements</td>
                        <td>Chat with 3 different elements</td>
                        <td>Each has independent history</td>
                    </tr>
                    <tr>
                        <td>Cross-session</td>
                        <td>Close browser, reopen page</td>
                        <td>All chats still accessible</td>
                    </tr>
                    <tr>
                        <td>Element moved</td>
                        <td>Element moves in DOM</td>
                        <td>Chat still linked (via ID)</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="divider"></div>

    <div class="collapsible warning open full-width">
        <div class="collapsible-header">
            <span>‚ö†Ô∏è Potential Issues & Mitigations</span>
            <span class="arrow">‚ñ∂</span>
        </div>
        <div class="collapsible-content">
            <h3>Issue 1: Element Identification on Dynamic Pages</h3>
            <p><strong>Problem:</strong> SPAs may replace DOM elements, breaking element ID links</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Use multiple identifiers (data attribute + CSS selector + XPath)</li>
                <li>Implement fuzzy matching if exact element not found</li>
                <li>Show warning if element can't be located</li>
            </ul>

            <h3>Issue 2: Storage Limits</h3>
            <p><strong>Problem:</strong> chrome.storage.local has ~5MB limit, chat history could fill it</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Implement chat history pruning (keep last 50 messages per element)</li>
                <li>Store per-page to isolate storage usage</li>
                <li>Add "Clear old chats" functionality</li>
                <li>Warning when storage reaches 80% capacity</li>
            </ul>

            <h3>Issue 3: Performance with Many Chat Indicators</h3>
            <p><strong>Problem:</strong> 100+ chat indicators could slow page load</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Lazy render indicators (only visible ones)</li>
                <li>Use IntersectionObserver for efficient updates</li>
                <li>Debounce scroll/resize handlers</li>
            </ul>

            <h3>Issue 4: Window Positioning Conflicts</h3>
            <p><strong>Problem:</strong> Multiple windows may overlap or go off-screen</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Collision detection algorithm</li>
                <li>Cascade positioning for multiple windows</li>
                <li>Boundary checking to keep windows in viewport</li>
            </ul>

            <h3>Issue 5: Element Moved Off-Screen</h3>
            <p><strong>Problem:</strong> Chat window attached to element that scrolls away</p>
            <p><strong>Mitigation:</strong></p>
            <ul class="dense-list">
                <li>Option 1: Window stays fixed at last position</li>
                <li>Option 2: Window follows element (update on scroll)</li>
                <li>Option 3: Show indicator when element off-screen</li>
                <li><strong>Recommended:</strong> Option 1 for simplicity</li>
            </ul>
        </div>
    </div>

    <div class="divider"></div>

    <div class="important-always-visible">
        <h2>üìä Implementation Breakdown</h2>

        <div class="two-column-layout">
            <div>
                <h3>Phase Estimates</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Element ID System</td>
                            <td>1-1.5 hours</td>
                        </tr>
                        <tr>
                            <td>Storage Architecture</td>
                            <td>1.5-2 hours</td>
                        </tr>
                        <tr>
                            <td>ElementSelector Updates</td>
                            <td>1 hour</td>
                        </tr>
                        <tr>
                            <td>Window Management</td>
                            <td>1.5-2 hours</td>
                        </tr>
                        <tr>
                            <td>Content Script Integration</td>
                            <td>1 hour</td>
                        </tr>
                        <tr>
                            <td>Testing & Polish</td>
                            <td>1 hour</td>
                        </tr>
                        <tr>
                            <th>Total</th>
                            <th>6-8 hours</th>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div>
                <h3>Success Criteria</h3>
                <ul class="dense-list">
                    <li>‚úÖ Ctrl+Shift+C activates element selector</li>
                    <li>‚úÖ Clicking element opens attached chat window</li>
                    <li>‚úÖ Chat history persists per element</li>
                    <li>‚úÖ Closing and reopening restores full history</li>
                    <li>‚úÖ Multiple chat windows work simultaneously</li>
                    <li>‚úÖ Visual indicators show elements with chats</li>
                    <li>‚úÖ Works across page reloads</li>
                    <li>‚úÖ No performance degradation</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('open');
        }

        function expandAll() {
            document.querySelectorAll('.collapsible').forEach(el => {
                el.classList.add('open');
            });
        }

        function collapseAll() {
            document.querySelectorAll('.collapsible').forEach(el => {
                el.classList.remove('open');
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => toggleCollapsible(header));
            });
        });
    </script>
</body>
</html>