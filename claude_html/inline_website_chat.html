<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inline Website Chat - UI Mockup & Implementation Plan</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --ink-black: #1a1a1a;
            --level-1: #8B0000;
            --level-2: #CD5C5C;
            --level-3: #666;
            --level-4: #999;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            margin: 0;
            padding: 0;
            width: 100vw;
            max-width: 100%;
            line-height: 1.2;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro", "Segoe UI", Roboto, Arial, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            padding: 12px;
            margin: 0;
        }

        h1 {
            font-size: 24px;
            font-weight: 900;
            margin: 4px 0;
            padding: 6px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 18px;
            font-weight: 700;
            margin: 8px 0 4px 0;
            padding: 4px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03);
            color: var(--level-1);
        }

        h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 4px 0 2px 8px;
            color: var(--level-2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h4 {
            font-size: 12px;
            font-weight: 500;
            margin: 2px 0 1px 16px;
            color: var(--level-3);
        }

        .collapsible {
            margin: 4px 0;
            width: 100%;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 6px 8px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 10px;
            margin-right: 8px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 8px;
            margin-left: 12px;
        }

        .collapsible.open .collapsible-content {
            max-height: 5000px;
            padding: 8px;
        }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 8px;
            margin: 8px 0;
            border-radius: 3px;
        }

        .important-always-visible h2 {
            color: var(--chinese-red);
            margin-top: 0;
        }

        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 8px 0;
        }

        .mockup-container {
            background: white;
            border: 2px solid var(--chinese-red);
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(139, 0, 0, 0.15);
        }

        .mockup-image {
            background: #f8f8f8;
            border: 1px dashed var(--chinese-gold);
            padding: 20px;
            text-align: center;
            margin: 8px 0;
            position: relative;
        }

        .chat-window-mockup {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 215, 0, 0.02));
            border: 2px solid var(--chinese-red);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            width: 400px;
            height: 500px;
            margin: 12px auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .chat-header {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 13px;
        }

        .chat-header-actions {
            display: flex;
            gap: 4px;
        }

        .chat-header-button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 3px;
            padding: 2px 6px;
            color: white;
            font-size: 11px;
            cursor: pointer;
        }

        .chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: white;
        }

        .chat-message {
            margin: 6px 0;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
        }

        .chat-message.user {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
            border-left: 3px solid var(--chinese-red);
            margin-left: 20px;
        }

        .chat-message.assistant {
            background: rgba(0, 0, 0, 0.03);
            border-left: 3px solid var(--chinese-gold);
            margin-right: 20px;
        }

        .chat-input-container {
            border-top: 1px solid rgba(139, 0, 0, 0.2);
            padding: 8px;
            display: flex;
            gap: 6px;
            background: rgba(245, 245, 220, 0.3);
        }

        .chat-input {
            flex: 1;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
            font-family: inherit;
        }

        .chat-send-button {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .trigger-button-mockup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            border: 2px solid var(--chinese-gold);
            border-radius: 50%;
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(139, 0, 0, 0.3);
            cursor: pointer;
        }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.1);
            padding: 2px 4px;
            margin: 1px 0;
            font-size: 11px;
            line-height: 1.3;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
        }

        pre {
            padding: 6px 8px;
            margin: 4px 0;
            overflow-x: auto;
        }

        .dense-list {
            list-style: none;
            padding: 0;
            margin-left: 8px;
        }

        .dense-list li {
            padding: 2px 0 2px 12px;
            border-left: 2px solid transparent;
            position: relative;
            line-height: 1.4;
        }

        .dense-list li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: var(--chinese-red);
            font-size: 10px;
        }

        .dense-list li strong {
            color: var(--level-2);
            font-weight: 600;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 3px;
            padding: 8px;
            margin: 6px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
            margin: 8px 0;
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 12px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 6px 0;
            font-size: 12px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 4px 6px;
            text-align: left;
            line-height: 1.3;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 600;
        }

        .keyboard-shortcut {
            display: inline-block;
            background: rgba(139, 0, 0, 0.1);
            border: 1px solid var(--chinese-red);
            border-radius: 3px;
            padding: 2px 6px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            font-weight: 600;
        }

        .indent-1 { margin-left: 12px; }
        .indent-2 { margin-left: 24px; }
        .indent-3 { margin-left: 36px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🗨️ Inline Website Chat - UI Mockup & Implementation Plan</h1>

        <div class="important-always-visible">
            <h2>Core Concept</h2>
            <p><strong>Goal:</strong> Enable users to chat with any website inline using a floating chat interface similar to the canvas chat, accessible via keyboard shortcut or floating button.</p>
            <ul class="dense-list" style="margin-top: 6px;">
                <li><strong>Trigger:</strong> <span class="keyboard-shortcut">Ctrl+Shift+C</span> or floating chat button</li>
                <li><strong>Context:</strong> Auto-captures visible page content for AI conversation</li>
                <li><strong>UI:</strong> Draggable, resizable floating window with Shadow DOM isolation</li>
                <li><strong>Backend:</strong> Uses existing Claude API infrastructure via local backend</li>
            </ul>
        </div>

        <div class="mockup-container" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), white);">
            <h2>♻️ Component Reuse Strategy</h2>
            <p style="margin-bottom: 8px;"><strong>Maximize code reuse by leveraging existing infrastructure:</strong></p>
            <div class="feature-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="card priority">
                    <h3>Existing Components to Reuse</h3>
                    <ul class="dense-list">
                        <li><strong>FloatingWindow</strong> (<code>src/components/FloatingWindow.tsx</code>) - Drag, resize, positioning</li>
                        <li><strong>ChatModal</strong> (<code>src/canvas/ChatModal.tsx</code>) - Message rendering, streaming logic</li>
                        <li><strong>claudeAPIService</strong> (<code>src/services/claudeAPIService.ts</code>) - API calls, auth</li>
                        <li><strong>Toast</strong> (<code>src/components/Toast.tsx</code>) - Error/success notifications</li>
                        <li><strong>Shadow DOM pattern</strong> from ElementSelector - CSS isolation</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>New Components Needed</h3>
                    <ul class="dense-list">
                        <li><strong>InlineChatWindow</strong> - Wrapper combining FloatingWindow + chat logic</li>
                        <li><strong>pageContextCapture.ts</strong> - Extract page content for context</li>
                        <li><strong>FloatingChatButton</strong> - Trigger button UI</li>
                        <li><strong>Message handlers</strong> in content script - Listen for Ctrl+Shift+C</li>
                    </ul>
                </div>
            </div>
            <p style="margin-top: 8px; padding: 6px; background: rgba(139, 0, 0, 0.05); border-left: 3px solid var(--chinese-red);"><strong>Key benefit:</strong> ~60-70% code reuse = faster implementation, consistent UX, fewer bugs</p>
        </div>

        <div class="mockup-container">
            <h2>UI Mockup: Inline Chat Interface</h2>

            <div class="chat-window-mockup">
                <div class="chat-header">
                    <span>💬 Chat with Page</span>
                    <div class="chat-header-actions">
                        <div class="chat-header-button">📋 Capture</div>
                        <div class="chat-header-button">📌 Pin</div>
                        <div class="chat-header-button">✕</div>
                    </div>
                </div>
                <div class="chat-body">
                    <div class="chat-message assistant">
                        <strong>Assistant:</strong> I can see this page about React hooks. What would you like to know?
                    </div>
                    <div class="chat-message user">
                        <strong>You:</strong> Explain the useEffect hook with examples
                    </div>
                    <div class="chat-message assistant">
                        <strong>Assistant:</strong> Based on this page, useEffect is a Hook that lets you perform side effects in function components. Here are the key points from the content...
                    </div>
                </div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" placeholder="Ask about this page..." />
                    <button class="chat-send-button">Send</button>
                </div>
            </div>

            <div style="text-align: center; margin-top: 12px; font-size: 12px; color: #666;">
                <strong>Floating Trigger Button:</strong> Appears in bottom-right corner when chat is closed
            </div>
        </div>

        <div class="divider"></div>

        <h2>Key Features</h2>
        <div class="feature-grid">
            <div class="card priority">
                <h3>🎯 Auto Context Capture</h3>
                <ul class="dense-list">
                    <li>Automatically extracts visible page content (DOM text, headings, links)</li>
                    <li>Sanitizes and summarizes for LLM context window</li>
                    <li>Includes page metadata (title, URL, description)</li>
                    <li>Manual "Capture" button for refresh/selection</li>
                </ul>
            </div>

            <div class="card priority">
                <h3>💬 Conversational Interface</h3>
                <ul class="dense-list">
                    <li>Streaming responses like canvas chat</li>
                    <li>Maintains conversation history in session</li>
                    <li>Option to save conversation to canvas as card</li>
                    <li>Quick actions: summarize, explain, ask questions</li>
                </ul>
            </div>

            <div class="card">
                <h3>🪟 Floating Window</h3>
                <ul class="dense-list">
                    <li>Draggable, resizable (reuse FloatingWindow component)</li>
                    <li>Shadow DOM isolation (no CSS conflicts)</li>
                    <li>Persistent position across page scrolling</li>
                    <li>Minimize to floating button</li>
                </ul>
            </div>

            <div class="card">
                <h3>⌨️ Keyboard Shortcuts</h3>
                <ul class="dense-list">
                    <li><span class="keyboard-shortcut">Ctrl+Shift+C</span> - Toggle chat</li>
                    <li><span class="keyboard-shortcut">Enter</span> - Send message</li>
                    <li><span class="keyboard-shortcut">Shift+Enter</span> - New line</li>
                    <li><span class="keyboard-shortcut">Escape</span> - Close/minimize</li>
                </ul>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>Implementation Plan (6 Phases)</strong></div>
            </div>
            <div class="collapsible-content">
                <div class="two-column-layout">
                    <div class="card priority">
                        <h3>Phase 1: Component Setup</h3>
                        <h4>Files to Create/Modify:</h4>
                        <ul class="dense-list">
                            <li><code>src/components/InlineChatWindow.tsx</code> - New component</li>
                            <li><code>src/content/index.tsx</code> - Add chat mounting logic</li>
                            <li><code>src/background/index.ts</code> - Register <span class="keyboard-shortcut">Ctrl+Shift+C</span> command</li>
                        </ul>
                        <h4>Tasks:</h4>
                        <ul class="dense-list">
                            <li>Create InlineChatWindow component extending FloatingWindow</li>
                            <li>Add Shadow DOM mounting in content script</li>
                            <li>Register keyboard command in background worker</li>
                            <li>Implement toggle show/hide logic</li>
                        </ul>
                    </div>

                    <div class="card priority">
                        <h3>Phase 2: Context Capture</h3>
                        <h4>Files to Create:</h4>
                        <ul class="dense-list">
                            <li><code>src/services/pageContextCapture.ts</code> - New service</li>
                            <li><code>src/utils/contextSummarizer.ts</code> - Context compression</li>
                        </ul>
                        <h4>Tasks:</h4>
                        <ul class="dense-list">
                            <li>Extract visible DOM text (headings, paragraphs, lists)</li>
                            <li>Capture page metadata (title, URL, meta tags)</li>
                            <li>Implement smart summarization (token limit ~4000)</li>
                            <li>Handle dynamic content (SPAs, infinite scroll)</li>
                        </ul>
                    </div>

                    <div class="card">
                        <h3>Phase 3: Chat Interface</h3>
                        <h4>Components:</h4>
                        <ul class="dense-list">
                            <li>Message display with user/assistant styling</li>
                            <li>Input field with auto-resize</li>
                            <li>Streaming response handler</li>
                            <li>Loading states and error handling</li>
                        </ul>
                        <h4>Reuse from Canvas:</h4>
                        <ul class="dense-list">
                            <li><code>src/canvas/ChatModal.tsx</code> - Message rendering logic</li>
                            <li><code>src/services/claudeAPIService.ts</code> - API calls</li>
                            <li>Emotion CSS styling patterns</li>
                        </ul>
                    </div>

                    <div class="card">
                        <h3>Phase 4: API Integration</h3>
                        <h4>Files to Modify:</h4>
                        <ul class="dense-list">
                            <li><code>src/services/claudeAPIService.ts</code> - Add inline chat method</li>
                        </ul>
                        <h4>Tasks:</h4>
                        <ul class="dense-list">
                            <li>Create <code>chatWithPage(context, messages)</code> method</li>
                            <li>Format page context as system prompt</li>
                            <li>Handle streaming responses</li>
                            <li>Use existing backend auth (Agent SDK)</li>
                        </ul>
                    </div>

                    <div class="card">
                        <h3>Phase 5: Floating Button</h3>
                        <h4>Files to Create:</h4>
                        <ul class="dense-list">
                            <li><code>src/components/FloatingChatButton.tsx</code></li>
                        </ul>
                        <h4>Features:</h4>
                        <ul class="dense-list">
                            <li>Fixed position bottom-right (matching mockup)</li>
                            <li>Animated on hover (pulse/glow)</li>
                            <li>Notification badge for new capabilities</li>
                            <li>Hidden when chat window open</li>
                        </ul>
                    </div>

                    <div class="card">
                        <h3>Phase 6: Advanced Features</h3>
                        <h4>Optional Enhancements:</h4>
                        <ul class="dense-list">
                            <li><strong>Save to Canvas:</strong> Convert conversation to card</li>
                            <li><strong>Quick Actions:</strong> Pre-defined prompts (summarize, ELI5)</li>
                            <li><strong>Element Selection:</strong> Right-click element → "Chat about this"</li>
                            <li><strong>Multi-page Memory:</strong> Persist conversations per domain</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>Technical Architecture</strong></div>
            </div>
            <div class="collapsible-content">
                <h3>Message Flow</h3>
                <pre>
User presses Ctrl+Shift+C
→ Background worker sends OPEN_INLINE_CHAT message
→ Content script:
  1. Captures page context (pageContextCapture.ts)
  2. Mounts InlineChatWindow in Shadow DOM
  3. Initializes chat with context
→ User sends message
→ InlineChatWindow → claudeAPIService.chatWithPage()
→ API request to backend (localhost:3100) with:
  - System prompt: page context
  - User message: query
  - Conversation history: previous messages
→ Streaming response rendered in chat window
→ Option to save conversation to canvas as card</pre>

                <h3>Storage Strategy</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Storage Location</th>
                            <th>Persistence</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Active conversation</td>
                            <td>In-memory (component state)</td>
                            <td>Session only</td>
                        </tr>
                        <tr>
                            <td>Window position/size</td>
                            <td>chrome.storage.local <code>'inline_chat_position'</code></td>
                            <td>Persistent</td>
                        </tr>
                        <tr>
                            <td>Saved conversations</td>
                            <td>Canvas cards (optional)</td>
                            <td>Permanent</td>
                        </tr>
                        <tr>
                            <td>Page context cache</td>
                            <td>sessionStorage per tab</td>
                            <td>Tab lifetime</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Shadow DOM Structure</h3>
                <pre>
&lt;div id="nabokov-inline-chat-root"&gt;  ← Mounted by content script
  #shadow-root
    &lt;style&gt;...isolated styles...&lt;/style&gt;
    &lt;InlineChatWindow&gt;
      &lt;FloatingWindow draggable resizable&gt;
        &lt;ChatHeader /&gt;
        &lt;MessageList messages={conversation} /&gt;
        &lt;ChatInput onSend={handleSend} /&gt;
      &lt;/FloatingWindow&gt;
    &lt;/InlineChatWindow&gt;
&lt;/div&gt;</pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>Detailed Code Structure</strong></div>
            </div>
            <div class="collapsible-content">
                <h3>New Files to Create</h3>
                <div class="card">
                    <h4>src/components/InlineChatWindow.tsx</h4>
                    <pre>
interface InlineChatWindowProps {
  onClose: () => void;
  initialContext: PageContext;
}

export const InlineChatWindow: React.FC&lt;InlineChatWindowProps&gt; = ({
  onClose,
  initialContext
}) => {
  const [messages, setMessages] = useState&lt;Message[]&gt;([]);
  const [isStreaming, setIsStreaming] = useState(false);

  const handleSendMessage = async (text: string) => {
    // 1. Add user message
    // 2. Call claudeAPIService.chatWithPage(context, messages)
    // 3. Stream assistant response
    // 4. Update messages state
  };

  return (
    &lt;FloatingWindow title="Chat with Page" onClose={onClose}&gt;
      &lt;ChatMessages messages={messages} /&gt;
      &lt;ChatInput onSend={handleSendMessage} disabled={isStreaming} /&gt;
    &lt;/FloatingWindow&gt;
  );
};</pre>
                </div>

                <div class="card">
                    <h4>src/services/pageContextCapture.ts</h4>
                    <pre>
export interface PageContext {
  url: string;
  title: string;
  description?: string;
  content: string; // Extracted text
  headings: string[];
  metadata: Record&lt;string, string&gt;;
}

export function capturePageContext(): PageContext {
  return {
    url: window.location.href,
    title: document.title,
    description: document.querySelector('meta[name="description"]')?.content,
    content: extractVisibleText(),
    headings: extractHeadings(),
    metadata: extractMetaTags()
  };
}

function extractVisibleText(): string {
  // Extract text from visible elements
  // Prioritize: h1-h6, p, li, article, main
  // Skip: nav, footer, ads, scripts
  // Limit to ~4000 tokens
}</pre>
                </div>

                <div class="card">
                    <h4>src/content/index.tsx (modifications)</h4>
                    <pre>
// Add chat mounting logic
let inlineChatRoot: HTMLDivElement | null = null;

chrome.runtime.onMessage.addListener((message) => {
  if (message.type === "OPEN_INLINE_CHAT") {
    toggleInlineChat();
  }
});

function toggleInlineChat() {
  if (inlineChatRoot) {
    // Close if open
    inlineChatRoot.remove();
    inlineChatRoot = null;
  } else {
    // Mount chat
    const context = capturePageContext();
    inlineChatRoot = document.createElement('div');
    inlineChatRoot.id = 'nabokov-inline-chat-root';
    document.body.appendChild(inlineChatRoot);

    const shadowRoot = inlineChatRoot.attachShadow({ mode: 'open' });
    const root = createRoot(shadowRoot);
    root.render(&lt;InlineChatWindow context={context} onClose={toggleInlineChat} /&gt;);
  }
}</pre>
                </div>

                <div class="card">
                    <h4>src/background/index.ts (modifications)</h4>
                    <pre>
chrome.commands.onCommand.addListener((command) => {
  if (command === "toggle-inline-chat") {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]?.id) {
        chrome.tabs.sendMessage(tabs[0].id, { type: "OPEN_INLINE_CHAT" });
      }
    });
  }
});</pre>
                </div>

                <div class="card">
                    <h4>src/manifest.json (modifications)</h4>
                    <pre>
{
  "commands": {
    "toggle-inline-chat": {
      "suggested_key": {
        "default": "Ctrl+Shift+C",
        "mac": "Ctrl+Shift+C"
      },
      "description": "Toggle inline chat with page"
    }
  }
}</pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>API Integration Details</strong></div>
            </div>
            <div class="collapsible-content">
                <h3>Claude API Service Extension</h3>
                <pre>
// src/services/claudeAPIService.ts

export async function chatWithPage(
  pageContext: PageContext,
  messages: Message[]
): Promise&lt;ReadableStream&lt;string&gt;&gt; {
  const systemPrompt = formatPageContextAsPrompt(pageContext);

  const response = await fetch('http://localhost:3100/api/claude', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      system: systemPrompt,
      messages: messages,
      stream: true
    })
  });

  return response.body!;
}

function formatPageContextAsPrompt(context: PageContext): string {
  return `You are helping the user understand and interact with a web page.

Page Details:
- URL: ${context.url}
- Title: ${context.title}
- Description: ${context.description || 'N/A'}

Page Content:
${context.content}

Main Headings:
${context.headings.join('\n')}

Answer questions about this page, provide explanations, summaries, or analysis as requested.`;
}</pre>

                <h3>Streaming Response Handler</h3>
                <pre>
async function handleStreamingResponse(
  stream: ReadableStream&lt;string&gt;,
  onChunk: (text: string) => void
) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n').filter(line => line.startsWith('data: '));

    for (const line of lines) {
      const data = JSON.parse(line.slice(6));
      if (data.delta?.text) {
        onChunk(data.delta.text);
      }
    }
  }
}</pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>UX Enhancements & Edge Cases</strong></div>
            </div>
            <div class="collapsible-content">
                <h3>Smart Context Capture</h3>
                <ul class="dense-list">
                    <li><strong>Dynamic content:</strong> Re-capture on scroll or mutation observer triggers</li>
                    <li><strong>Large pages:</strong> Summarize intelligently, prioritize visible viewport</li>
                    <li><strong>Code-heavy pages:</strong> Detect and format code blocks with syntax awareness</li>
                    <li><strong>SPAs:</strong> Monitor route changes, offer to re-capture context</li>
                </ul>

                <h3>User Interactions</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Action</th>
                            <th>Behavior</th>
                            <th>Implementation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Drag window</td>
                            <td>Smooth dragging, snap to edges</td>
                            <td>Reuse FloatingWindow drag logic</td>
                        </tr>
                        <tr>
                            <td>Resize window</td>
                            <td>Min 300×400, max 800×800</td>
                            <td>CSS resize + bounds checking</td>
                        </tr>
                        <tr>
                            <td>Minimize</td>
                            <td>Collapse to floating button</td>
                            <td>Animate scale-down, unmount window</td>
                        </tr>
                        <tr>
                            <td>Save to canvas</td>
                            <td>Create card with conversation</td>
                            <td>Format messages as HTML, save Card</td>
                        </tr>
                        <tr>
                            <td>Capture refresh</td>
                            <td>Re-extract page content</td>
                            <td>Call pageContextCapture again</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Error Handling</h3>
                <ul class="dense-list">
                    <li><strong>API errors:</strong> Show inline error message, offer retry</li>
                    <li><strong>Network timeout:</strong> Graceful fallback, cache last request</li>
                    <li><strong>Context too large:</strong> Auto-summarize or prompt user to select specific section</li>
                    <li><strong>No API key:</strong> Show settings prompt inline with link to APISettings</li>
                </ul>

                <h3>Performance Optimizations</h3>
                <ul class="dense-list">
                    <li>Debounce context re-capture (2 second delay after scroll/mutation)</li>
                    <li>Cache context per tab in sessionStorage (avoid re-extraction)</li>
                    <li>Lazy-load chat component (code-split, only load on first open)</li>
                    <li>Virtual scroll for long conversations (100+ messages)</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <div class="important-always-visible">
            <h2>🚀 Implementation Order & Timeline</h2>
            <table>
                <thead>
                    <tr>
                        <th>Phase</th>
                        <th>Priority</th>
                        <th>Estimated Effort</th>
                        <th>Deliverable</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Phase 1:</strong> Component Setup</td>
                        <td style="color: var(--chinese-red); font-weight: 700;">CRITICAL</td>
                        <td>2-3 hours</td>
                        <td>Chat window appears on Ctrl+Shift+C</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 2:</strong> Context Capture</td>
                        <td style="color: var(--chinese-red); font-weight: 700;">CRITICAL</td>
                        <td>2-3 hours</td>
                        <td>Page content extracted and formatted</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 3:</strong> Chat Interface</td>
                        <td style="color: var(--chinese-red); font-weight: 700;">CRITICAL</td>
                        <td>3-4 hours</td>
                        <td>Functional chat with message history</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 4:</strong> API Integration</td>
                        <td style="color: var(--chinese-red); font-weight: 700;">CRITICAL</td>
                        <td>2 hours</td>
                        <td>Real Claude API responses with streaming</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 5:</strong> Floating Button</td>
                        <td style="color: var(--level-2);">HIGH</td>
                        <td>1-2 hours</td>
                        <td>Persistent chat access button</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 6:</strong> Advanced Features</td>
                        <td style="color: var(--level-3);">MEDIUM</td>
                        <td>4-6 hours</td>
                        <td>Save to canvas, quick actions, etc.</td>
                    </tr>
                </tbody>
            </table>
            <p style="margin-top: 8px;"><strong>Total MVP Time:</strong> ~10-14 hours (Phases 1-4) | <strong>Full Feature Set:</strong> ~15-22 hours (All phases)</p>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>Testing Strategy</strong></div>
            </div>
            <div class="collapsible-content">
                <h3>Manual Testing Checklist</h3>
                <ul class="dense-list">
                    <li>✓ Chat window appears on <span class="keyboard-shortcut">Ctrl+Shift+C</span></li>
                    <li>✓ Page context captured correctly (text, headings, metadata)</li>
                    <li>✓ Message sending works (user → assistant)</li>
                    <li>✓ Streaming responses display properly</li>
                    <li>✓ Window draggable and resizable without conflicts</li>
                    <li>✓ Shadow DOM prevents CSS conflicts with host page</li>
                    <li>✓ Works on various sites (Wikipedia, GitHub, documentation)</li>
                    <li>✓ Large pages handled gracefully (context summarization)</li>
                    <li>✓ Error states display clearly (API failures, network issues)</li>
                    <li>✓ Position persists across page reloads</li>
                </ul>

                <h3>Automated Tests</h3>
                <pre>
// tests/inline-chat.spec.ts
test('opens inline chat with keyboard shortcut', async ({ page }) => {
  await page.goto('https://example.com');
  await page.keyboard.press('Control+Shift+C');

  const chatRoot = await page.locator('#nabokov-inline-chat-root');
  await expect(chatRoot).toBeVisible();
});

test('captures page context', async ({ page }) => {
  await page.goto('https://example.com');
  const context = await page.evaluate(() => {
    return window.capturePageContext();
  });

  expect(context.title).toBe('Example Domain');
  expect(context.content).toContain('Example');
});</pre>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <div><span class="arrow">▶</span><strong>Future Enhancements</strong></div>
            </div>
            <div class="collapsible-content">
                <ul class="dense-list">
                    <li><strong>Multi-modal context:</strong> Include images/screenshots from page in conversation</li>
                    <li><strong>Collaborative chats:</strong> Share chat sessions via URL</li>
                    <li><strong>Custom prompts:</strong> User-defined quick actions (like custom buttons)</li>
                    <li><strong>Cross-page memory:</strong> "Remember this for later" - domain-level conversation persistence</li>
                    <li><strong>Element-specific chat:</strong> Right-click any element → "Chat about this element"</li>
                    <li><strong>Voice input:</strong> Speech-to-text for hands-free queries</li>
                    <li><strong>Export options:</strong> Save as PDF, Markdown, or share to canvas</li>
                    <li><strong>Translation mode:</strong> Real-time page translation with context</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('open');
        }

        // Open first two collapsibles by default
        document.addEventListener('DOMContentLoaded', () => {
            const collapsibles = document.querySelectorAll('.collapsible');
            if (collapsibles[0]) collapsibles[0].classList.add('open');
            if (collapsibles[1]) collapsibles[1].classList.add('open');
        });
    </script>
</body>
</html>