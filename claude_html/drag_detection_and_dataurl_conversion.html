<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag Detection & Data URL Conversion - Deep Dive</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --ink-black: #1a1a1a;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.5;
            font-size: 14px;
        }

        h1 {
            font-size: 32px;
            font-weight: 900;
            margin: 0 0 24px 0;
            padding: 16px 12px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            border-bottom: 4px solid var(--chinese-gold);
        }

        h2 {
            font-size: 22px;
            font-weight: 700;
            margin: 24px 0 12px 0;
            padding: 10px;
            border-left: 5px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.06);
            color: var(--chinese-red);
        }

        h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 16px 0 8px 0;
            color: #CD5C5C;
        }

        h4 {
            font-size: 15px;
            font-weight: 600;
            margin: 12px 0 6px 0;
            color: #666;
        }

        .critical-box {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), white);
            border: 3px solid var(--chinese-gold);
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(139, 0, 0, 0.1);
        }

        .flow-diagram {
            background: white;
            border: 2px solid var(--chinese-red);
            padding: 20px;
            margin: 16px 0;
            border-radius: 6px;
        }

        .flow-step {
            display: flex;
            align-items: flex-start;
            margin: 12px 0;
            padding: 12px;
            background: rgba(139, 0, 0, 0.04);
            border-left: 4px solid var(--chinese-gold);
            border-radius: 3px;
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: var(--chinese-red);
            color: white;
            border-radius: 50%;
            font-weight: 700;
            font-size: 14px;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .flow-arrow {
            text-align: center;
            color: var(--chinese-red);
            font-size: 24px;
            margin: 8px 0;
        }

        pre {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.5), rgba(255, 255, 255, 0.7));
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-left: 4px solid var(--chinese-gold);
            padding: 16px;
            margin: 12px 0;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.6;
            border-radius: 4px;
        }

        code {
            background: rgba(139, 0, 0, 0.08);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: "SF Mono", Monaco, monospace;
            font-size: 13px;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 16px 0;
        }

        .column {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 4px;
            padding: 16px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        }

        .highlight {
            background: rgba(255, 215, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        ul {
            margin: 12px 0 12px 24px;
        }

        li {
            margin: 6px 0;
            line-height: 1.6;
        }

        strong {
            color: var(--chinese-red);
            font-weight: 600;
        }

        .api-box {
            background: white;
            border: 2px solid rgba(139, 0, 0, 0.3);
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
        }

        .api-signature {
            background: rgba(139, 0, 0, 0.05);
            padding: 10px 12px;
            border-left: 4px solid var(--chinese-red);
            font-family: "SF Mono", Monaco, monospace;
            font-size: 13px;
            margin: 8px 0;
            border-radius: 3px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            background: white;
            border-radius: 4px;
            overflow: hidden;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 10px 14px;
            text-align: left;
        }

        th {
            background: rgba(139, 0, 0, 0.1);
            font-weight: 700;
            color: var(--chinese-red);
        }

        .warning {
            background: rgba(255, 165, 0, 0.1);
            border-left: 4px solid orange;
            padding: 12px;
            margin: 12px 0;
            border-radius: 3px;
        }

        .info {
            background: rgba(0, 123, 255, 0.08);
            border-left: 4px solid #007bff;
            padding: 12px;
            margin: 12px 0;
            border-radius: 3px;
        }

        .collapsible {
            margin: 16px 0;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.08), rgba(255, 215, 0, 0.05));
            border-left: 4px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            border-radius: 4px;
            font-weight: 600;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.12), rgba(255, 215, 0, 0.08));
        }

        .collapsible-header .arrow {
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 14px;
            margin-right: 12px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 16px;
        }

        .collapsible.open .collapsible-content {
            max-height: 5000px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <h1>üéØ Drag Detection & Data URL Conversion</h1>

    <div class="critical-box">
        <h2>Quick Answer</h2>
        <p><strong>1. Drag Detection:</strong> The browser fires <code>dragenter</code> events when files enter the window. Your code checks <code>e.dataTransfer.types</code> for the string <code>'Files'</code> to confirm files (not text) are being dragged.</p>
        <p style="margin-top: 12px;"><strong>2. Data URL Conversion:</strong> Uses the <code>FileReader</code> Web API to read the file as a data URL. Call <code>readAsDataURL(file)</code>, then listen for the <code>load</code> event which provides the base64-encoded result.</p>
    </div>

    <h2>üîç Part 1: Drag Detection Mechanism</h2>

    <h3>The Browser Drag & Drop Event Lifecycle</h3>
    <div class="flow-diagram">
        <div class="flow-step">
            <div class="step-number">1</div>
            <div class="step-content">
                <strong>dragenter</strong> - Fires when dragged item enters a valid drop target
                <div class="info" style="margin-top: 8px;">This is where you detect "something is being dragged"</div>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">2</div>
            <div class="step-content">
                <strong>dragover</strong> - Fires continuously while dragging over the target (every ~50-100ms)
                <div class="info" style="margin-top: 8px;">Must call <code>e.preventDefault()</code> to signal drop is allowed</div>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">3</div>
            <div class="step-content">
                <strong>dragleave</strong> - Fires when dragged item leaves the drop target
                <div class="info" style="margin-top: 8px;">This is where you hide the overlay</div>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">4</div>
            <div class="step-content">
                <strong>drop</strong> - Fires when item is dropped on the target
                <div class="info" style="margin-top: 8px;">Access files via <code>e.dataTransfer.files</code></div>
            </div>
        </div>
    </div>

    <h3>Your Implementation in ImageUploadZone.tsx</h3>

    <h4>1. Drag Enter - Detection Phase</h4>
    <pre><code>const handleDragEnter = useCallback((e: DragEvent&lt;HTMLDivElement&gt;) => {
  e.preventDefault();
  e.stopPropagation();

  if (disabled) return;

  // <span class="highlight">üîë KEY: Check if dragging files (not text/links)</span>
  if (e.dataTransfer.types.includes('Files')) {
    setIsDragging(true);  // Show overlay
  }
}, [disabled]);</code></pre>

    <div class="info">
        <strong>Why check <code>e.dataTransfer.types</code>?</strong>
        <ul>
            <li>Dragging a file ‚Üí <code>types</code> contains <code>'Files'</code></li>
            <li>Dragging text ‚Üí <code>types</code> contains <code>'text/plain'</code></li>
            <li>Dragging a link ‚Üí <code>types</code> contains <code>'text/uri-list'</code></li>
        </ul>
        This prevents showing the overlay when dragging non-file content.
    </div>

    <h4>2. Drag Over - Permission Phase</h4>
    <pre><code>const handleDragOver = useCallback((e: DragEvent&lt;HTMLDivElement&gt;) => {
  e.preventDefault();    // <span class="highlight">üîë CRITICAL: Allow drop</span>
  e.stopPropagation();   // Prevent parent handlers
}, []);</code></pre>

    <div class="warning">
        <strong>‚ö†Ô∏è Must call <code>e.preventDefault()</code></strong>
        <p>Without this, the browser's default behavior prevents the drop. The <code>drop</code> event will never fire.</p>
    </div>

    <h4>3. Drag Leave - Cleanup Phase</h4>
    <pre><code>const handleDragLeave = useCallback((e: DragEvent&lt;HTMLDivElement&gt;) => {
  e.preventDefault();
  e.stopPropagation();

  // <span class="highlight">üîë Only hide overlay if leaving the container entirely</span>
  if (e.currentTarget === e.target) {
    setIsDragging(false);
  }
}, []);</code></pre>

    <div class="info">
        <strong>Why <code>e.currentTarget === e.target</code>?</strong>
        <p><code>dragleave</code> fires when leaving ANY child element. This check ensures we only hide the overlay when leaving the outermost container, not when moving between children.</p>
    </div>

    <h4>4. Drop - File Access Phase</h4>
    <pre><code>const handleDrop = useCallback(async (e: DragEvent&lt;HTMLDivElement&gt;) => {
  e.preventDefault();
  e.stopPropagation();

  setIsDragging(false);  // Hide overlay

  if (disabled) return;

  // <span class="highlight">üîë Extract files from dataTransfer</span>
  const files = Array.from(e.dataTransfer.files);

  // <span class="highlight">üîë Filter to only image files</span>
  const imageFiles = files.filter(file => file.type.startsWith('image/'));

  if (imageFiles.length === 0) {
    console.warn('[ImageUploadZone] No image files found in drop');
    return;
  }

  // Upload first image file
  const file = imageFiles[0];
  try {
    await onImageUpload(file);
    console.log('[ImageUploadZone] Image uploaded:', file.name);
  } catch (error) {
    console.error('[ImageUploadZone] Upload failed:', error);
  }
}, [onImageUpload, disabled]);</code></pre>

    <h3>DataTransfer API Reference</h3>
    <table>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>dataTransfer.types</code></td>
            <td><code>string[]</code></td>
            <td>Array of MIME types being dragged (e.g., <code>['Files']</code>)</td>
        </tr>
        <tr>
            <td><code>dataTransfer.files</code></td>
            <td><code>FileList</code></td>
            <td>List of <code>File</code> objects (only available in <code>drop</code> event)</td>
        </tr>
        <tr>
            <td><code>dataTransfer.items</code></td>
            <td><code>DataTransferItemList</code></td>
            <td>More detailed item list (can contain directories)</td>
        </tr>
    </table>

    <h2>üíæ Part 2: File to Data URL Conversion</h2>

    <h3>The FileReader API</h3>
    <div class="api-box">
        <div class="api-signature">
            interface FileReader extends EventTarget
        </div>
        <p><strong>Purpose:</strong> Asynchronously read the contents of files stored on the user's computer.</p>
        <h4>Key Methods:</h4>
        <ul>
            <li><code>readAsDataURL(file)</code> - Read as base64-encoded data URL</li>
            <li><code>readAsText(file)</code> - Read as text string</li>
            <li><code>readAsArrayBuffer(file)</code> - Read as binary array buffer</li>
        </ul>
    </div>

    <h3>Your Implementation in imageUpload.ts</h3>
    <pre><code>/**
 * Convert File to base64 data URL
 */
function fileToDataURL(file: File): Promise&lt;string&gt; {
  return new Promise((resolve, reject) => {
    // <span class="highlight">üîë Create FileReader instance</span>
    const reader = new FileReader();

    // <span class="highlight">üîë Register success handler</span>
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);  // Data URL string
      } else {
        reject(new Error('Failed to read file as data URL'));
      }
    };

    // <span class="highlight">üîë Register error handler</span>
    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };

    // <span class="highlight">üîë Start reading the file</span>
    reader.readAsDataURL(file);
  });
}</code></pre>

    <h3>What is a Data URL?</h3>
    <div class="critical-box">
        <p>A data URL is a way to embed file data directly in a string using base64 encoding.</p>
        <h4>Format:</h4>
        <div class="api-signature">
            data:[MIME-type];base64,[base64-encoded-data]
        </div>
        <h4>Example:</h4>
        <pre><code>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...</code></pre>
        <ul>
            <li><strong>Protocol:</strong> <code>data:</code></li>
            <li><strong>MIME type:</strong> <code>image/png</code></li>
            <li><strong>Encoding:</strong> <code>base64</code></li>
            <li><strong>Data:</strong> Binary image data encoded as base64 string</li>
        </ul>
    </div>

    <h3>Complete Conversion Flow</h3>
    <div class="flow-diagram">
        <div class="flow-step">
            <div class="step-number">1</div>
            <div class="step-content">
                <strong>User drops image file</strong>
                <pre style="margin-top: 8px;"><code>File { name: "photo.png", size: 45678, type: "image/png" }</code></pre>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">2</div>
            <div class="step-content">
                <strong>Create FileReader</strong>
                <pre style="margin-top: 8px;"><code>const reader = new FileReader();</code></pre>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">3</div>
            <div class="step-content">
                <strong>Register event handlers</strong>
                <pre style="margin-top: 8px;"><code>reader.onload = () => resolve(reader.result);
reader.onerror = () => reject(error);</code></pre>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">4</div>
            <div class="step-content">
                <strong>Start reading</strong>
                <pre style="margin-top: 8px;"><code>reader.readAsDataURL(file);</code></pre>
                <div class="info" style="margin-top: 8px;">This is asynchronous - returns immediately, processes in background</div>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">5</div>
            <div class="step-content">
                <strong>Browser reads file</strong>
                <ul style="margin-top: 8px;">
                    <li>Reads binary data from disk</li>
                    <li>Encodes as base64 string</li>
                    <li>Prepends data URL prefix</li>
                </ul>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">6</div>
            <div class="step-content">
                <strong>onload fires with result</strong>
                <pre style="margin-top: 8px;"><code>reader.result === "data:image/png;base64,iVBORw0KGgo..."</code></pre>
            </div>
        </div>
        <div class="flow-arrow">‚Üì</div>
        <div class="flow-step">
            <div class="step-number">7</div>
            <div class="step-content">
                <strong>Promise resolves</strong>
                <pre style="margin-top: 8px;"><code>const dataURL = await fileToDataURL(file);
// Now can store in chrome.storage.local or use in &lt;img src={dataURL} /&gt;</code></pre>
            </div>
        </div>
    </div>

    <h3>Why Use Data URLs?</h3>
    <div class="two-column">
        <div class="column">
            <h4>‚úÖ Advantages</h4>
            <ul>
                <li><strong>Self-contained:</strong> Image data embedded in string</li>
                <li><strong>No external files:</strong> No need to manage separate image files</li>
                <li><strong>Works in storage:</strong> Can save directly to chrome.storage.local</li>
                <li><strong>Works in HTML:</strong> Can use directly in <code>&lt;img src=""&gt;</code></li>
                <li><strong>Serializable:</strong> JSON-safe for storage</li>
            </ul>
        </div>
        <div class="column">
            <h4>‚ùå Disadvantages</h4>
            <ul>
                <li><strong>Size increase:</strong> Base64 adds ~33% overhead</li>
                <li><strong>Storage limits:</strong> chrome.storage.local has ~5MB total limit</li>
                <li><strong>Performance:</strong> Large data URLs can slow parsing</li>
                <li><strong>Memory:</strong> Entire image loaded into memory as string</li>
            </ul>
        </div>
    </div>

    <h2>üîó How They Work Together</h2>
    <div class="critical-box">
        <h3>Complete User Flow</h3>
        <pre><code>// 1. User drags image over window
handleDragEnter ‚Üí checks e.dataTransfer.types.includes('Files') ‚Üí setIsDragging(true)

// 2. Overlay appears
{isDragging && &lt;div&gt;Drop image to upload&lt;/div&gt;}

// 3. User drops image
handleDrop ‚Üí extracts e.dataTransfer.files ‚Üí filters to image files

// 4. Convert to data URL
const file = imageFiles[0];
const reader = new FileReader();
reader.onload = () => resolve(reader.result);  // Wait for async read
reader.readAsDataURL(file);

// 5. Get dimensions
const img = new Image();
img.src = dataURL;
img.onload = () => resolve({ width: img.width, height: img.height });

// 6. Create card
const card = {
  id: generateId(),
  cardType: 'image',
  imageData: dataURL,  // "data:image/png;base64,..."
  imageDimensions: { width: 800, height: 600 },
  ...metadata
};

// 7. Save to storage
await chrome.storage.local.set({ cards: [...existingCards, card] });

// 8. Broadcast update
window.dispatchEvent(new CustomEvent('nabokov:cards-updated'));
chrome.runtime.sendMessage({ type: 'CARD_CREATED', cardId: card.id });

// 9. UI refreshes to show new card
&lt;img src={card.imageData} alt="Uploaded image" /&gt;</code></pre>
    </div>

    <h2>üìä Performance Considerations</h2>

    <div class="collapsible open">
        <div class="collapsible-header">
            <span><span class="arrow">‚ñ∂</span>File Size Impact</span>
        </div>
        <div class="collapsible-content">
            <table>
                <tr>
                    <th>Original Size</th>
                    <th>Base64 Size</th>
                    <th>Overhead</th>
                    <th>Read Time</th>
                </tr>
                <tr>
                    <td>100 KB</td>
                    <td>133 KB</td>
                    <td>+33%</td>
                    <td>~10ms</td>
                </tr>
                <tr>
                    <td>500 KB</td>
                    <td>665 KB</td>
                    <td>+33%</td>
                    <td>~50ms</td>
                </tr>
                <tr>
                    <td>1 MB</td>
                    <td>1.33 MB</td>
                    <td>+33%</td>
                    <td>~100ms</td>
                </tr>
                <tr>
                    <td>5 MB</td>
                    <td>6.65 MB</td>
                    <td>+33%</td>
                    <td>~500ms</td>
                </tr>
            </table>
            <div class="warning">
                <strong>‚ö†Ô∏è Storage Limit:</strong> chrome.storage.local has ~5MB limit after JSON serialization. A single 5MB image will consume the entire quota!
            </div>
        </div>
    </div>

    <h2>üêõ Common Issues & Solutions</h2>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">‚ñ∂</span>Drag events not firing</span>
        </div>
        <div class="collapsible-content">
            <h4>Problem:</h4>
            <p>Drag events don't fire, overlay never shows.</p>
            <h4>Causes:</h4>
            <ul>
                <li>Forgot to attach event listeners to container</li>
                <li>Event listeners on wrong element</li>
                <li>CSS <code>pointer-events: none</code> on overlay blocking events</li>
            </ul>
            <h4>Solution:</h4>
            <pre><code>&lt;div
  onDragEnter={handleDragEnter}
  onDragOver={handleDragOver}
  onDragLeave={handleDragLeave}
  onDrop={handleDrop}
&gt;
  {children}
  {isDragging && &lt;div style={{pointerEvents: 'none'}}&gt;Overlay&lt;/div&gt;}
&lt;/div&gt;</code></pre>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">‚ñ∂</span>Drop event not firing</span>
        </div>
        <div class="collapsible-content">
            <h4>Problem:</h4>
            <p><code>drop</code> event never fires, files not accessible.</p>
            <h4>Cause:</h4>
            <p>Forgot <code>e.preventDefault()</code> in <code>dragover</code> handler.</p>
            <h4>Solution:</h4>
            <pre><code>const handleDragOver = (e) => {
  e.preventDefault();  // <span class="highlight">MUST call this!</span>
  e.stopPropagation();
};</code></pre>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">‚ñ∂</span>FileReader result is null</span>
        </div>
        <div class="collapsible-content">
            <h4>Problem:</h4>
            <p><code>reader.result</code> is null or undefined.</p>
            <h4>Causes:</h4>
            <ul>
                <li>Accessing <code>result</code> before <code>onload</code> fires</li>
                <li>File read error (permissions, corrupted file)</li>
            </ul>
            <h4>Solution:</h4>
            <pre><code>reader.onload = () => {
  if (reader.result) {
    console.log('Success:', reader.result);
  } else {
    console.error('Result is null');
  }
};

reader.onerror = () => {
  console.error('Read error:', reader.error);
};

reader.readAsDataURL(file);  // Start async read</code></pre>
        </div>
    </div>

    <div class="collapsible">
        <div class="collapsible-header">
            <span><span class="arrow">‚ñ∂</span>Overlay flickers when dragging over children</span>
        </div>
        <div class="collapsible-content">
            <h4>Problem:</h4>
            <p>Overlay shows and hides rapidly when moving mouse over child elements.</p>
            <h4>Cause:</h4>
            <p><code>dragleave</code> fires when entering child elements.</p>
            <h4>Solution:</h4>
            <pre><code>const handleDragLeave = (e) => {
  // Only hide overlay when leaving the outermost container
  if (e.currentTarget === e.target) {
    setIsDragging(false);
  }
};</code></pre>
        </div>
    </div>

    <script>
        // Add collapsible functionality
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                const collapsible = header.parentElement;
                collapsible.classList.toggle('open');
            });
        });

        // Open critical sections by default
        document.querySelectorAll('.collapsible.open').forEach(el => {
            el.classList.add('open');
        });
    </script>
</body>
</html>