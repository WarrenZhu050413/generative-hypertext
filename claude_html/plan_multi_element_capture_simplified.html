<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan: Multi-Element Capture (Simplified)</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --paper-beige: #F5F5DC;
            --light-cream: #FFFEF0;
            --ink-black: #1a1a1a;
            --level-1: #8B0000;
            --level-2: #B22222;
            --level-3: #CD5C5C;
            --level-4: #666;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.2;
            width: 100vw;
            max-width: 100%;
            padding: 8px;
        }

        .container { width: 100%; padding: 0; }

        h1 {
            font-size: 24px; font-weight: 900; margin: 4px 0; padding: 6px 4px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 18px; font-weight: 700; margin: 8px 0 4px 0; padding: 4px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.03); color: var(--level-1);
        }

        h3 {
            font-size: 14px; font-weight: 600; margin: 4px 0 2px 8px;
            color: var(--level-2); text-transform: uppercase; letter-spacing: 0.5px;
        }

        h4 { font-size: 12px; font-weight: 500; margin: 2px 0 1px 16px; color: var(--level-3); }
        h5 { font-size: 11px; font-weight: 500; margin: 1px 0 1px 24px; color: var(--level-4); }

        button, .button {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white; border: 1px solid rgba(255, 215, 0, 0.3);
            transition: all 0.2s ease; padding: 4px 8px; margin: 2px;
            font-size: 12px; cursor: pointer; border-radius: 2px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3);
            border-color: var(--chinese-gold);
        }

        .collapsible { margin: 4px 0; width: 100%; }

        .collapsible-header {
            cursor: pointer; padding: 6px 8px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 3px solid var(--chinese-gold);
            display: flex; align-items: center; justify-content: space-between;
            user-select: none; transition: all 0.2s ease;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            display: inline-block; transition: transform 0.3s ease;
            color: var(--chinese-red); font-size: 10px; margin-left: 8px;
        }

        .collapsible.open .arrow { transform: rotate(90deg); }

        .collapsible-content {
            max-height: 0; overflow: hidden; transition: max-height 0.3s ease;
            padding: 0 8px; margin-left: 12px;
        }

        .collapsible.open .collapsible-content { max-height: 5000px; padding: 8px; }

        .important-always-visible {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 8px; margin: 8px 0; border-radius: 3px;
        }

        .primary-section {
            border: 2px solid var(--chinese-red);
            background: white; margin: 6px 0; padding: 6px;
        }

        .secondary-section {
            border-left: 3px solid var(--chinese-gold);
            background: rgba(255, 215, 0, 0.05);
            margin: 4px 0 4px 8px; padding: 4px;
        }

        .card {
            background: white; border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 2px; padding: 6px; margin: 4px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .card.critical {
            border: 2px solid var(--chinese-red);
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), white);
        }

        .dense-list { list-style: none; padding: 0; margin-left: 8px; }

        .dense-list li {
            padding: 2px 0 2px 12px; border-left: 2px solid transparent;
            position: relative; line-height: 1.4;
        }

        .dense-list li:before {
            content: "▸"; position: absolute; left: 0;
            color: var(--chinese-red); font-size: 10px;
        }

        .dense-list li strong { color: var(--level-2); font-weight: 600; }

        pre, code {
            background: linear-gradient(135deg, rgba(245, 245, 220, 0.3), rgba(255, 255, 255, 0.5));
            border: 1px solid rgba(139, 0, 0, 0.1);
            padding: 2px 4px; margin: 1px 0; font-size: 12px; line-height: 1.3;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
        }

        pre { padding: 6px 8px; margin: 4px 0; overflow-x: auto; }

        .two-column-layout {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 8px; margin: 8px 0;
        }

        .full-width { grid-column: span 2; }

        .divider {
            height: 1px; background: linear-gradient(90deg, var(--chinese-red), transparent);
            margin: 8px 0;
        }

        .indent-1 { margin-left: 12px; }
        .indent-2 { margin-left: 24px; }
        .indent-3 { margin-left: 36px; }

        .metric {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
            margin: 2px 4px 2px 0;
        }

        .metric.important { background: #ffebee; color: #c62828; }
        .metric.success { background: #e8f5e9; color: #2e7d32; }
        .metric.info { background: #e3f2fd; color: #1565c0; }

        table {
            width: 100%; border-collapse: collapse; margin: 4px 0; font-size: 12px;
        }

        th, td {
            border: 1px solid rgba(139, 0, 0, 0.2);
            padding: 3px 6px; text-align: left; line-height: 1.2;
        }

        th { background: rgba(139, 0, 0, 0.1); font-weight: 600; }

        .mockup {
            background: #f5f5f5;
            border: 2px dashed var(--chinese-gold);
            padding: 8px;
            margin: 6px 0;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        .expand-collapse-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 4px;
        }

        .muted { color: #666; font-size: 11px; }

        .step-number {
            display: inline-block;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 700;
            font-size: 12px;
            margin-right: 8px;
        }

        ol.implementation-steps {
            list-style: none;
            counter-reset: step-counter;
            padding: 0;
        }

        ol.implementation-steps > li {
            counter-increment: step-counter;
            margin: 8px 0;
            padding: 8px;
            background: white;
            border-left: 4px solid var(--chinese-gold);
            position: relative;
        }

        ol.implementation-steps > li:before {
            content: counter(step-counter);
            display: inline-block;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            text-align: center;
            line-height: 28px;
            font-weight: 700;
            font-size: 14px;
            margin-right: 12px;
            float: left;
        }

        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 8px 0;
        }

        .comparison-column {
            padding: 8px;
            border-radius: 3px;
        }

        .comparison-column.old {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid #ccc;
        }

        .comparison-column.new {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid var(--chinese-gold);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="expand-collapse-controls">
            <button onclick="toggleAll(true)">Expand All</button>
            <button onclick="toggleAll(false)">Collapse All</button>
        </div>

        <h1>📋 Implementation Plan: Multi-Element Capture (Simplified)</h1>

        <div class="important-always-visible">
            <div class="two-column-layout">
                <div>
                    <h2 style="margin-top: 0;">🎯 Objective</h2>
                    <p>Enable users to select multiple HTML elements with Cmd+Click, combining them into a single card or using them for chat context.</p>
                    <div style="margin-top: 8px;">
                        <div class="metric important">Complexity: Medium</div>
                        <div class="metric info">Est. Time: 12-16 hours</div>
                        <div class="metric success">Impact: High</div>
                    </div>
                </div>
                <div>
                    <h2 style="margin-top: 0;">⚡ Approach</h2>
                    <ul class="dense-list">
                        <li><strong>Canvas/Stash modes:</strong> Cmd+Click multiple elements → Always combine into ONE card</li>
                        <li><strong>Chat mode:</strong> Activate chat FIRST → Click elements → Chat opens with selected context</li>
                        <li><strong>No choices:</strong> Simplified UX, no action panel needed</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <h2>🔄 Workflow Comparison</h2>

        <div class="comparison-table">
            <div class="comparison-column old">
                <h3 style="margin-top: 0; color: #666;">❌ Previous Complex Approach</h3>
                <ol class="dense-list">
                    <li>Press hotkey</li>
                    <li>Cmd+Click elements</li>
                    <li><strong style="color: #c62828;">Choose action from panel</strong>
                        <ul class="dense-list indent-1">
                            <li>Single card</li>
                            <li>Multiple cards</li>
                            <li>Chat</li>
                        </ul>
                    </li>
                    <li>Execute chosen action</li>
                </ol>
                <div class="muted" style="margin-top: 8px;">Issues: Too many choices, confusing UX, over-engineered</div>
            </div>

            <div class="comparison-column new">
                <h3 style="margin-top: 0; color: var(--chinese-red);">✅ New Simplified Approach</h3>

                <h4 style="margin-left: 0; color: var(--level-2);">Canvas/Stash Mode:</h4>
                <ol class="dense-list">
                    <li>Press Cmd+E or Cmd+Shift+E</li>
                    <li>Cmd+Click multiple elements</li>
                    <li><strong style="color: #2e7d32;">Press Enter → ONE combined card created</strong></li>
                </ol>

                <h4 style="margin-left: 0; margin-top: 8px; color: var(--level-2);">Chat Mode:</h4>
                <ol class="dense-list">
                    <li>Press Ctrl+Shift+C (chat first!)</li>
                    <li>Click element(s) - Cmd+Click for multiple</li>
                    <li><strong style="color: #2e7d32;">Chat opens with selected context</strong></li>
                </ol>

                <div class="muted" style="margin-top: 8px;">Benefits: Simple, predictable, no decision fatigue</div>
            </div>
        </div>

        <div class="divider"></div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><strong>📍 Prerequisites & Context</strong></span>
                <span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <h3>Files to Examine</h3>
                <table>
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Purpose</th>
                            <th>What to Check</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>src/components/ElementSelector.tsx</code></td>
                            <td>Element selection UI</td>
                            <td>Click handlers, state management, overlay rendering</td>
                        </tr>
                        <tr>
                            <td><code>src/background/index.ts</code></td>
                            <td>Hotkey handlers</td>
                            <td>Message passing to content script, mode parameters</td>
                        </tr>
                        <tr>
                            <td><code>src/components/InlineChatWindow.tsx</code></td>
                            <td>Chat UI</td>
                            <td>How chat is activated, context injection</td>
                        </tr>
                        <tr>
                            <td><code>src/utils/storage.ts</code></td>
                            <td>Card creation</td>
                            <td><code>addCard()</code> function, Card type structure</td>
                        </tr>
                        <tr>
                            <td><code>src/types/card.ts</code></td>
                            <td>Type definitions</td>
                            <td>Card interface, ensure it supports combined content</td>
                        </tr>
                    </tbody>
                </table>

                <h3 style="margin-top: 8px;">Existing State to Understand</h3>
                <ul class="dense-list">
                    <li><strong>Current single-element flow:</strong> How does click → capture work now?</li>
                    <li><strong>Mode indicators:</strong> How are Canvas Mode vs Stash Mode displayed?</li>
                    <li><strong>Chat activation:</strong> How does Ctrl+Shift+C currently work?</li>
                    <li><strong>Shadow DOM setup:</strong> How are overlays and components isolated?</li>
                </ul>
            </div>
        </div>

        <div class="collapsible open critical">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><strong>⚡ Implementation Steps</strong></span>
                <span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <ol class="implementation-steps">
                    <li>
                        <strong>Update ElementSelector.tsx - Add Multi-Select State</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code></p>
                            <p><strong>Changes:</strong></p>
                            <pre><code>// Add state for selected elements
const [selectedElements, setSelectedElements] = useState&lt;SelectedElement[]&gt;([]);

interface SelectedElement {
  element: HTMLElement;
  index: number;           // 1, 2, 3...
  html: string;            // Sanitized HTML
  metadata: ClipMetadata;
  styles: RelevantStyles;
  context?: string;
}</code></pre>
                            <div class="muted">Store array of selected elements with their metadata</div>
                        </div>
                    </li>

                    <li>
                        <strong>Implement Cmd+Click Detection Logic</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code></p>
                            <p><strong>Logic:</strong></p>
                            <pre><code>const handleElementClick = async (e: MouseEvent, element: HTMLElement) => {
  e.preventDefault();
  e.stopPropagation();

  const isCmdHeld = e.metaKey || e.ctrlKey;

  if (isCmdHeld) {
    // MULTI-SELECT MODE
    toggleElementSelection(element);
  } else {
    // SINGLE-SELECT MODE (backward compatibility)
    if (selectedElements.length === 0) {
      // No elements selected → immediate single capture
      await captureSingleElement(element);
      cleanup();
    } else {
      // Elements already selected → finalize with this element
      await finalizeMultiCapture([...selectedElements, element]);
      cleanup();
    }
  }
};

const toggleElementSelection = (element: HTMLElement) => {
  const existingIndex = selectedElements.findIndex(
    sel => sel.element === element
  );

  if (existingIndex >= 0) {
    // Remove if already selected
    setSelectedElements(prev =>
      prev.filter((_, i) => i !== existingIndex)
    );
  } else {
    // Add to selection
    const newSelection: SelectedElement = {
      element,
      index: selectedElements.length + 1,
      html: DOMPurify.sanitize(element.outerHTML),
      metadata: extractMetadata(element),
      styles: getRelevantStyles(element),
      context: element.parentElement?.outerHTML
    };
    setSelectedElements(prev => [...prev, newSelection]);
  }
};</code></pre>
                            <div class="muted">Cmd+Click toggles selection, regular click finalizes or does single capture</div>
                        </div>
                    </li>

                    <li>
                        <strong>Visual Feedback - Golden Overlays & Number Badges</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code></p>
                            <p><strong>Rendering:</strong></p>
                            <pre><code>// Render overlay for each selected element
{selectedElements.map((sel) => {
  const rect = sel.element.getBoundingClientRect();
  return (
    &lt;div
      key={sel.index}
      css={selectedOverlayStyle}
      style={{
        top: rect.top + window.scrollY,
        left: rect.left + window.scrollX,
        width: rect.width,
        height: rect.height
      }}
    &gt;
      &lt;div css={numberBadgeStyle}&gt;{sel.index}&lt;/div&gt;
    &lt;/div&gt;
  );
})}

// Styles
const selectedOverlayStyle = css\`
  position: absolute;
  border: 3px solid #FFD700;
  box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
  pointer-events: none;
  z-index: 999998;
  animation: pulse-gold 1.5s infinite;
\`;

const numberBadgeStyle = css\`
  position: absolute;
  top: -12px;
  left: -12px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: linear-gradient(135deg, #8B0000, #FFD700);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 14px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
\`;

const pulseGoldAnimation = \`
  @keyframes pulse-gold {
    0%, 100% { box-shadow: 0 0 12px rgba(255, 215, 0, 0.6); }
    50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.9); }
  }
\`;</code></pre>
                            <div class="muted">Golden border + numbered badge for each selected element</div>
                        </div>
                    </li>

                    <li>
                        <strong>Add Selection Status HUD</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code></p>
                            <p><strong>Purpose:</strong> Show count and instructions</p>
                            <pre><code>// Render floating status HUD when elements selected
{selectedElements.length > 0 && (
  &lt;div css={statusHudStyle}&gt;
    &lt;div css={statusTextStyle}&gt;
      📦 {selectedElements.length} element{selectedElements.length !== 1 ? 's' : ''} selected
    &lt;/div&gt;
    &lt;div css={statusInstructionsStyle}&gt;
      Press &lt;kbd&gt;Enter&lt;/kbd&gt; to create card • &lt;kbd&gt;Esc&lt;/kbd&gt; to cancel
    &lt;/div&gt;
  &lt;/div&gt;
)}

const statusHudStyle = css\`
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(205, 92, 92, 0.95));
  color: white;
  padding: 12px 24px;
  border-radius: 8px;
  border: 2px solid rgba(255, 215, 0, 0.5);
  box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  z-index: 999999;
  backdrop-filter: blur(8px);
\`;

const statusTextStyle = css\`
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 4px;
\`;

const statusInstructionsStyle = css\`
  font-size: 12px;
  opacity: 0.9;
\`;

kbd {
  background: rgba(255, 255, 255, 0.2);
  padding: 2px 6px;
  border-radius: 3px;
  font-family: monospace;
  font-size: 11px;
}</code></pre>
                            <div class="muted">Bottom-center HUD shows selection count and keyboard instructions</div>
                        </div>
                    </li>

                    <li>
                        <strong>Keyboard Shortcuts - Enter to Finalize, Escape to Clear</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code></p>
                            <pre><code>useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      // Clear all selections and exit
      setSelectedElements([]);
      cleanup();
    } else if (e.key === 'Enter' && selectedElements.length > 0) {
      // Finalize multi-capture
      e.preventDefault();
      finalizeMultiCapture(selectedElements);
    } else if ((e.key === 'Backspace' || e.key === 'Delete') && selectedElements.length > 0) {
      // Remove last element
      e.preventDefault();
      setSelectedElements(prev => prev.slice(0, -1));
    }
  };

  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [selectedElements]);</code></pre>
                            <div class="muted">Enter = finalize, Escape = cancel, Backspace = remove last</div>
                        </div>
                    </li>

                    <li>
                        <strong>Create Combined Card from Multiple Elements</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code> (or new <code>src/utils/multiElementCapture.ts</code>)</p>
                            <p><strong>Function:</strong></p>
                            <pre><code>async function finalizeMultiCapture(elements: SelectedElement[]) {
  if (elements.length === 0) return;

  // Build combined HTML with section markers
  const combinedHTML = elements
    .map((el, i) => \`
      &lt;div class="captured-element-section" data-index="\${i + 1}"&gt;
        &lt;div class="element-header"&gt;
          &lt;span class="element-number"&gt;\${i + 1}&lt;/span&gt;
          &lt;span class="element-info"&gt;\${el.metadata.title || 'Element'}&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="element-content"&gt;
          \${el.html}
        &lt;/div&gt;
      &lt;/div&gt;
    \`)
    .join('&lt;hr class="element-separator"&gt;');

  // Wrap in container
  const finalHTML = \`
    &lt;div class="multi-element-capture" data-count="\${elements.length}"&gt;
      \${combinedHTML}
    &lt;/div&gt;
  \`;

  // Sanitize entire combined HTML
  const sanitizedHTML = DOMPurify.sanitize(finalHTML);

  // Use first element's metadata as base
  const baseMetadata = elements[0].metadata;

  // Create card
  const card: Card = {
    id: generateId(),
    content: sanitizedHTML,
    metadata: {
      ...baseMetadata,
      title: \`Multi-Element Capture (\${elements.length} items)\`
    },
    cardType: 'clipped',
    tags: ['multi-element-capture', \`\${elements.length}-elements\`],
    createdAt: Date.now(),
    updatedAt: Date.now(),
    starred: false,
    stashed: mode === 'stash' // Respect stash mode
  };

  // Save card
  await addCard(card);

  // Show success toast
  showToast(\`✓ Created card with \${elements.length} elements\`, 'success');

  // Broadcast update
  window.dispatchEvent(new CustomEvent('nabokov:cards-updated'));
}</code></pre>
                            <div class="muted">Combines all HTML into ONE card with section markers</div>
                        </div>
                    </li>

                    <li>
                        <strong>Style the Combined Card Content</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> Create <code>src/styles/multiElementCard.css</code> or add to existing styles</p>
                            <pre><code>.multi-element-capture {
  padding: 8px;
}

.captured-element-section {
  margin: 12px 0;
  padding: 8px;
  border-left: 4px solid rgba(139, 0, 0, 0.3);
  background: rgba(255, 215, 0, 0.05);
}

.element-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  font-weight: 600;
  color: #8B0000;
}

.element-number {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: linear-gradient(135deg, #8B0000, #FFD700);
  color: white;
  font-size: 12px;
  font-weight: 700;
  margin-right: 8px;
}

.element-info {
  font-size: 14px;
  color: #B22222;
}

.element-content {
  padding-left: 32px;
}

.element-separator {
  border: none;
  height: 2px;
  background: linear-gradient(90deg, rgba(139, 0, 0, 0.3), transparent);
  margin: 16px 0;
}</code></pre>
                            <div class="muted">Chinese aesthetic for combined card sections</div>
                        </div>
                    </li>

                    <li>
                        <strong>Update Chat Mode - Element Selection After Activation</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/background/index.ts</code></p>
                            <p><strong>Changes:</strong> Update Ctrl+Shift+C handler to activate selector in "chat" mode</p>
                            <pre><code>// Current: Ctrl+Shift+C opens chat immediately
// New: Ctrl+Shift+C activates element selector in "chat" mode

chrome.commands.onCommand.addListener((command) => {
  if (command === 'toggle-inline-chat') {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]?.id) {
        // Send message to activate selector in CHAT mode
        chrome.tabs.sendMessage(tabs[0].id, {
          type: 'ACTIVATE_CHAT_SELECTOR'
        });
      }
    });
  }
});</code></pre>
                        </div>
                    </li>

                    <li>
                        <strong>Update Content Script - Handle Chat Selector Mode</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/content/index.tsx</code></p>
                            <pre><code>chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === 'ACTIVATE_CHAT_SELECTOR') {
    // Mount ElementSelector in "chat" mode
    mountElementSelector('chat');
    sendResponse({ success: true });
  }
  // ... existing ACTIVATE_SELECTOR handler ...
});

function mountElementSelector(mode: 'canvas' | 'stash' | 'chat') {
  // Mount ElementSelector component with mode prop
  const root = createRoot(container);
  root.render(
    &lt;ElementSelector
      mode={mode}
      onComplete={(elements) => {
        if (mode === 'chat') {
          openChatWithElements(elements);
        } else {
          createCardFromElements(elements, mode);
        }
      }}
    /&gt;
  );
}</code></pre>
                        </div>
                    </li>

                    <li>
                        <strong>Update ElementSelector - Chat Mode Behavior</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/ElementSelector.tsx</code></p>
                            <p><strong>Changes:</strong> Accept mode prop, customize behavior for chat</p>
                            <pre><code>interface ElementSelectorProps {
  mode: 'canvas' | 'stash' | 'chat';
  onComplete: (elements: SelectedElement[]) => void;
}

export function ElementSelector({ mode, onComplete }: ElementSelectorProps) {
  // ... existing state ...

  const finalizeSelection = async () => {
    if (selectedElements.length === 0) return;

    if (mode === 'chat') {
      // Chat mode: pass elements to chat opener
      onComplete(selectedElements);
    } else {
      // Canvas/Stash mode: create combined card
      await createCombinedCard(selectedElements, mode);
      onComplete(selectedElements);
    }

    cleanup();
  };

  // Update mode indicator text
  const modeText = mode === 'chat'
    ? '💬 CHAT MODE - Select elements to discuss'
    : mode === 'stash'
    ? '📥 STASH MODE'
    : '🎨 CANVAS MODE';

  return (
    &lt;&gt;
      {/* Mode indicator banner */}
      &lt;div css={modeIndicatorStyle}&gt;{modeText}&lt;/div&gt;

      {/* ... rest of component ... */}
    &lt;/&gt;
  );
}</code></pre>
                        </div>
                    </li>

                    <li>
                        <strong>Open Chat with Selected Elements Context</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/content/index.tsx</code> or <code>src/components/InlineChatWindow.tsx</code></p>
                            <pre><code>function openChatWithElements(elements: SelectedElement[]) {
  // Build context from selected elements
  const context = elements
    .map((el, i) => \`
      === Element \${i + 1}: \${el.metadata.title || 'Untitled'} ===
      \${el.html}
    \`)
    .join('\\n\\n');

  // Open inline chat with context
  const chatWindow = mountInlineChatWindow({
    initialContext: context,
    contextSummary: \`\${elements.length} element\${elements.length !== 1 ? 's' : ''} from this page\`,
    enableSaveToCanvas: true
  });
}</code></pre>
                        </div>
                    </li>

                    <li>
                        <strong>Update InlineChatWindow - Accept Initial Context</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>src/components/InlineChatWindow.tsx</code></p>
                            <pre><code>interface InlineChatWindowProps {
  initialContext?: string;
  contextSummary?: string;
  enableSaveToCanvas?: boolean;
}

export function InlineChatWindow({
  initialContext,
  contextSummary,
  enableSaveToCanvas = false
}: InlineChatWindowProps) {
  const [context] = useState(initialContext || '');

  // Display context summary in header
  return (
    &lt;div css={chatWindowStyle}&gt;
      {contextSummary && (
        &lt;div css={contextBadgeStyle}&gt;
          📦 Context: {contextSummary}
        &lt;/div&gt;
      )}

      {/* Chat messages */}
      &lt;div css={messagesStyle}&gt;
        {/* ... */}
      &lt;/div&gt;

      {/* Input */}
      &lt;div css={inputAreaStyle}&gt;
        &lt;textarea
          placeholder="Ask about the selected elements..."
          // ...
        /&gt;

        {enableSaveToCanvas && (
          &lt;button onClick={saveConversationToCanvas}&gt;
            💾 Save to Canvas
          &lt;/button&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

async function saveConversationToCanvas() {
  // Create note card with conversation history
  const conversationHTML = messages
    .map(msg => \`
      &lt;div class="message \${msg.role}"&gt;
        &lt;strong&gt;\${msg.role}:&lt;/strong&gt; \${msg.content}
      &lt;/div&gt;
    \`)
    .join('');

  const card: Card = {
    id: generateId(),
    content: DOMPurify.sanitize(conversationHTML),
    cardType: 'note',
    metadata: {
      url: window.location.href,
      title: 'Chat Conversation',
      // ...
    },
    tags: ['chat-conversation'],
    // ...
  };

  await addCard(card);
  showToast('✓ Conversation saved to canvas', 'success');
}</code></pre>
                        </div>
                    </li>

                    <li>
                        <strong>Testing & Validation</strong>
                        <div class="indent-2">
                            <p><strong>Manual Tests:</strong></p>
                            <ul class="dense-list">
                                <li><strong>Canvas Mode Multi-Select:</strong>
                                    <ol class="dense-list indent-1">
                                        <li>Press Cmd+E</li>
                                        <li>Cmd+Click 3 elements (verify golden overlays + badges)</li>
                                        <li>Press Enter</li>
                                        <li>✓ Verify ONE card created with all 3 elements</li>
                                        <li>✓ Verify card has proper section markers and styling</li>
                                    </ol>
                                </li>
                                <li><strong>Stash Mode Multi-Select:</strong>
                                    <ol class="dense-list indent-1">
                                        <li>Press Cmd+Shift+E</li>
                                        <li>Cmd+Click 2 elements</li>
                                        <li>Press Enter</li>
                                        <li>✓ Verify card created in stash (not canvas)</li>
                                        <li>✓ Open side panel, verify card visible</li>
                                    </ol>
                                </li>
                                <li><strong>Chat Mode Element Selection:</strong>
                                    <ol class="dense-list indent-1">
                                        <li>Press Ctrl+Shift+C</li>
                                        <li>Cmd+Click 2 elements</li>
                                        <li>Press Enter</li>
                                        <li>✓ Verify chat opens with context summary</li>
                                        <li>✓ Ask question, verify Claude responds with context</li>
                                        <li>✓ Click "Save to Canvas", verify note card created</li>
                                    </ol>
                                </li>
                                <li><strong>Backward Compatibility:</strong>
                                    <ol class="dense-list indent-1">
                                        <li>Press Cmd+E</li>
                                        <li>Click element WITHOUT Cmd key</li>
                                        <li>✓ Verify single element captured immediately (old behavior)</li>
                                    </ol>
                                </li>
                                <li><strong>Edge Cases:</strong>
                                    <ul class="dense-list indent-1">
                                        <li>Select same element twice (should deselect)</li>
                                        <li>Press Escape with elements selected (should clear all)</li>
                                        <li>Press Backspace (should remove last element)</li>
                                        <li>Select elements, then click without Cmd (should finalize)</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </li>

                    <li>
                        <strong>Update Documentation</strong>
                        <div class="indent-2">
                            <p><strong>File:</strong> <code>CLAUDE.md</code></p>
                            <p><strong>Add section:</strong></p>
                            <pre><code>**Multi-Element Capture**

Users can select multiple HTML elements before creating a card or starting a chat:

**Canvas/Stash Modes (Cmd+E, Cmd+Shift+E):**
- Press hotkey to activate selector
- Cmd+Click to select multiple elements (golden highlights + number badges)
- Press Enter to create ONE combined card
- All elements combined into single card with section markers

**Chat Mode (Ctrl+Shift+C):**
- Press Ctrl+Shift+C to activate chat selector
- Click one or more elements (Cmd+Click for multiple)
- Press Enter to open chat with selected elements as context
- Option to save conversation to canvas as note card

**Keyboard Shortcuts:**
- Cmd/Ctrl+Click: Toggle element selection
- Enter: Finalize and create card/chat
- Escape: Cancel and clear selections
- Backspace: Remove last selected element

**Card Structure:**
Combined cards contain all selected elements with:
- Numbered section headers (1, 2, 3...)
- Element separators (horizontal rules)
- Chinese aesthetic styling (red/gold borders)
- Tag: 'multi-element-capture'</code></pre>
                        </div>
                    </li>
                </ol>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><strong>⚠️ Potential Issues & Mitigations</strong></span>
                <span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <table>
                    <thead>
                        <tr>
                            <th>Potential Issue</th>
                            <th>Mitigation Strategy</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Elements removed from DOM during selection</strong></td>
                            <td>Store HTML/metadata immediately on selection, don't rely on live elements. Add try-catch in finalize.</td>
                        </tr>
                        <tr>
                            <td><strong>Very large combined content exceeds storage quota</strong></td>
                            <td>Check total size before saving. Warn user and offer to truncate or split. Max ~5MB for chrome.storage.local.</td>
                        </tr>
                        <tr>
                            <td><strong>Nested elements selected (e.g., parent + child)</strong></td>
                            <td>Detect nesting and warn user or auto-filter to only keep outermost elements.</td>
                        </tr>
                        <tr>
                            <td><strong>Overlays don't reposition on scroll/resize</strong></td>
                            <td>Add scroll/resize event listeners to update overlay positions in real-time.</td>
                        </tr>
                        <tr>
                            <td><strong>Chat context too large for API</strong></td>
                            <td>Truncate or summarize context. Claude API has ~200k token limit (should be fine).</td>
                        </tr>
                        <tr>
                            <td><strong>User confusion between modes</strong></td>
                            <td>Prominent mode indicator banner at top. Different colors for each mode.</td>
                        </tr>
                        <tr>
                            <td><strong>Selection state lost on page navigation</strong></td>
                            <td>Expected behavior - content script unloads. Could add warning if user navigates with active selection.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><strong>📊 Post-Implementation Tasks</strong></span>
                <span class="arrow">▶</span>
            </div>
            <div class="collapsible-content">
                <h3>Documentation</h3>
                <ul class="dense-list">
                    <li>Update <code>CLAUDE.md</code> with multi-element capture workflow</li>
                    <li>Add JSDoc comments to all new functions</li>
                    <li>Create user-facing help tooltip in ElementSelector (explain Cmd+Click)</li>
                </ul>

                <h3>Testing</h3>
                <ul class="dense-list">
                    <li>Write E2E test: Multi-select → single card creation</li>
                    <li>Write E2E test: Chat mode element selection</li>
                    <li>Unit tests for <code>finalizeMultiCapture()</code> function</li>
                    <li>Manual testing on 10+ different websites</li>
                </ul>

                <h3>Performance Optimization</h3>
                <ul class="dense-list">
                    <li>Debounce overlay position updates on scroll/resize</li>
                    <li>Memoize expensive computations (metadata extraction, style calculation)</li>
                    <li>Add loading indicator for large captures (>100KB combined)</li>
                </ul>

                <h3>Future Enhancements (Optional)</h3>
                <ul class="dense-list">
                    <li><strong>Smart selection:</strong> "Select all similar elements" (AI-powered)</li>
                    <li><strong>Selection presets:</strong> Save multi-element patterns for reuse</li>
                    <li><strong>Visual link indicator:</strong> Draw lines connecting selected elements</li>
                    <li><strong>Undo last deselection:</strong> Cmd+Z to undo toggle</li>
                </ul>
            </div>
        </div>

        <div class="divider"></div>

        <div class="important-always-visible">
            <h2>📈 Success Criteria</h2>
            <div class="two-column-layout">
                <div class="card">
                    <h3 style="margin-top: 0;">Functional Requirements</h3>
                    <ul class="dense-list">
                        <li>✅ Cmd+Click toggles element selection</li>
                        <li>✅ Golden overlays + number badges visible</li>
                        <li>✅ Enter creates ONE combined card</li>
                        <li>✅ Chat mode: select elements → chat opens with context</li>
                        <li>✅ Backward compatible (single-click still works)</li>
                        <li>✅ Respects stash mode</li>
                        <li>✅ Keyboard shortcuts work (Enter, Esc, Backspace)</li>
                    </ul>
                </div>
                <div class="card">
                    <h3 style="margin-top: 0;">Quality Requirements</h3>
                    <ul class="dense-list">
                        <li>✅ No console errors or warnings</li>
                        <li>✅ Smooth animations (60fps)</li>
                        <li>✅ Works on 5+ different websites</li>
                        <li>✅ Combined cards styled with Chinese aesthetic</li>
                        <li>✅ All HTML sanitized with DOMPurify</li>
                        <li>✅ Documentation updated</li>
                        <li>✅ E2E tests passing</li>
                    </ul>
                </div>
            </div>

            <div style="margin-top: 12px; padding: 8px; background: rgba(46, 125, 50, 0.1); border-left: 4px solid #2e7d32;">
                <strong style="color: #2e7d32;">Total Estimated Time: 12-16 hours</strong>
                <div class="muted" style="margin-top: 4px;">
                    Breakdown: UI (4-5h) + Card Creation (3-4h) + Chat Integration (3-4h) + Testing (2-3h)
                </div>
            </div>
        </div>

        <div class="mockup" style="margin-top: 16px;">
<strong>Example: Combined Card HTML Structure</strong>

&lt;div class="multi-element-capture" data-count="3"&gt;
  &lt;div class="captured-element-section" data-index="1"&gt;
    &lt;div class="element-header"&gt;
      &lt;span class="element-number"&gt;1&lt;/span&gt;
      &lt;span class="element-info"&gt;Article Title&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="element-content"&gt;
      &lt;h2&gt;Breaking News&lt;/h2&gt;
      &lt;p&gt;Lorem ipsum dolor sit amet...&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;hr class="element-separator"&gt;

  &lt;div class="captured-element-section" data-index="2"&gt;
    &lt;div class="element-header"&gt;
      &lt;span class="element-number"&gt;2&lt;/span&gt;
      &lt;span class="element-info"&gt;Sidebar Widget&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="element-content"&gt;
      &lt;div class="widget"&gt;...&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;hr class="element-separator"&gt;

  &lt;div class="captured-element-section" data-index="3"&gt;
    &lt;div class="element-header"&gt;
      &lt;span class="element-number"&gt;3&lt;/span&gt;
      &lt;span class="element-info"&gt;Comment Section&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="element-content"&gt;
      &lt;div class="comments"&gt;...&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
        </div>

    </div>

    <script>
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('open');
        }

        function toggleAll(open) {
            const collapsibles = document.querySelectorAll('.collapsible');
            collapsibles.forEach(c => {
                if (open) {
                    c.classList.add('open');
                } else {
                    c.classList.remove('open');
                }
            });
        }

        // Initialize collapsibles based on data-collapsible attribute
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.collapsible').forEach(c => {
                const shouldOpen = c.getAttribute('data-collapsible') === 'open';
                if (shouldOpen) {
                    c.classList.add('open');
                }
            });
        });
    </script>
</body>
</html>